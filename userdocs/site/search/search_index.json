{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"backstage/","title":"Backstage Plugin for Flux","text":"<p>Are you running Backstage and Flux? Do you want to expose the state of your Flux resources in your Backstage portal?</p> <p>The <code>@weaveworksoss/backstage-plugin-flux</code> Backstage plugin provides a set of components that you can add to your existing Backstage app to display the state of Flux resources.</p>"},{"location":"backstage/#installation","title":"Installation","text":"<p>We provide the full installation instructions in the plugin repository. But first you will need to install the Kubernetes plugin and configure it to access the clusters you want to query Flux resources from.</p> <p>You will need to install the plugin to your frontend app:</p> <pre><code># From your Backstage root directory\nyarn add --cwd packages/app @weaveworksoss/backstage-plugin-flux\n</code></pre> <p>Then add the components you want to your EntityPage.</p> <p>Currently, the Backstage plugin provides the following components:</p> <ul> <li>EntityFluxDeploymentsCard - shows a combined view of HelmReleases and Kustomizations</li> <li>EntityFluxSourcesCard - shows a combined view of GitRepositories, OCIRepositories and HelmRepositories</li> <li>EntityFluxHelmReleasesCard</li> <li>EntityFluxKustomizationsCard</li> <li>EntityFluxGitRepositoriesCard</li> <li>EntityFluxOCIRepositoriesCard</li> <li>EntityFluxHelmRepositoriesCard</li> </ul> <p>For example, to add the <code>EntityFluxHelmReleasesCard</code> to your Entity home page for components with the <code>backstage.io/kubernetes-id</code> entity annotation.</p> packages/app/src/components/catalog/EntityPage.tsx<pre><code>import {\n  EntityFluxHelmReleasesCard,\n} from '@weaveworksoss/backstage-plugin-flux';\nimport { isKubernetesAvailable } from '@backstage/plugin-kubernetes';\n\nconst overviewContent = (\n  &lt;Grid item md={6}&gt;\n   &lt;EntityAboutCard variant=\"gridItem\" /&gt;\n  &lt;/Grid&gt;\n\n  &lt;EntitySwitch&gt;\n    &lt;EntitySwitch.Case if={isKubernetesAvailable}&gt;\n      &lt;EntityFluxHelmReleasesCard /&gt;\n    &lt;/EntitySwitch.Case&gt;\n  &lt;/EntitySwitch&gt;\n);\n</code></pre> <p>When you view components with the correct annotation:</p> <pre><code>apiVersion: backstage.io/v1alpha1\nkind: Component\nmetadata:\nname: catalogue-service\ndescription: A microservices-demo service that provides catalogue/product information\nannotations:\nbackstage.io/kubernetes-id: podinfo\n</code></pre> <p>This will query across your configured clusters for <code>HelmReleases</code> that have the correct label:</p> <pre><code>apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: podinfo\nnamespace: podinfo\n# The label here is matched to the Backstage Entity annotation\nlabels:\nbackstage.io/kubernetes-id: podinfo\nspec:\ninterval: 5m\nchart:\nspec:\nchart: podinfo\nversion: '6.3.6'\nsourceRef:\nkind: HelmRepository\nname: podinfo\nnamespace: podinfo\n</code></pre> <p></p>"},{"location":"backstage/#building-a-custom-page-with-resources","title":"Building a Custom Page with Resources","text":"<p>Instead of displaying the state on the overview page, it's possible to compose a page displaying the state of resources.</p> <p>For example, to add a page <code>/kustomizations</code> to your Entity for components with the <code>backstage.io/kubernetes-id</code> entity annotation:</p> packages/app/src/components/catalog/EntityPage.tsx<pre><code>import {\n EntityFluxGitRepositoriesCard,\n EntityFluxKustomizationsCard,\n} from '@weaveworksoss/backstage-plugin-flux';\nimport { isKubernetesAvailable } from '@backstage/plugin-kubernetes';\n\nconst serviceEntityPage = (\n  // insert in the page where you need it\n\n  &lt;EntityLayout.Route path=\"/kustomizations\" title=\"Kustomizations\" if={isKubernetesAvailable}&gt;\n    &lt;Grid container spacing={3} alignItems=\"stretch\"&gt;\n      &lt;Grid item md={12}&gt;\n        &lt;EntityFluxKustomizationsCard /&gt;\n      &lt;/Grid&gt;\n      &lt;Grid item md={12}&gt;\n        &lt;EntityFluxGitRepositoriesCard /&gt;\n      &lt;/Grid&gt;\n    &lt;/Grid&gt;\n  &lt;/EntityLayout.Route&gt;\n);\n</code></pre> <p></p>"},{"location":"backstage/#connecting-to-weave-gitops","title":"Connecting to Weave GitOps","text":"<p>You can connect the plugin to your Weave GitOps installation through your config:</p> app-config.yaml<pre><code>app:\ntitle: Backstage Example App\nbaseUrl: http://localhost:3000\n...\ngitops:\n# Set this to be the root of your Weave GitOps application\nbaseUrl: https://example.com\n</code></pre> <p>NOTE: The plugin will generate URLs relative to this URL and link to them from the displayed resources.</p>"},{"location":"feedback-and-telemetry/","title":"Feedback and Telemetry","text":""},{"location":"feedback-and-telemetry/#feedback","title":"Feedback","text":"<p>We \u2764\ufe0f your comments and suggestions as we look to make successfully adopting a cloud-native approach, to application deployment on Kubernetes with GitOps, easier and easier. There are a number of ways you can reach out:</p> <ul> <li>Raise an issue</li> <li>Invite yourself to the Weave Users Slack.</li> <li>Chat to us on the #weave-gitops slack channel.</li> <li>Set up time with one of our team: James - Product Director (US - East Coast)</li> <li>Come along to one of our events</li> </ul>"},{"location":"feedback-and-telemetry/#anonymous-aggregate-user-behavior-analytics","title":"Anonymous Aggregate User Behavior Analytics","text":"<p>Weaveworks is utilizing Pendo, a product-analytics app,  to gather anonymous user behavior analytics for both Weave GitOps and Weave GitOps Enterprise. We use this data so we can understand what you love about Weave GitOps, and areas we can improve.</p> <p>Weave GitOps OSS users will be notified when you create the dashboard for the first time via gitops create dashboard or when you use gitops run for the first time and decide to install the dashboard via that functionality. Analytics will not be enabled until after this notification so that you can opt out before sending analytics data.</p> <p>For Weave GitOps Enterprise users, this functionality is turned on by default. Further below we go into more detail about how you can control this functionality.</p>"},{"location":"feedback-and-telemetry/#why-are-we-collecting-this-data","title":"Why are we collecting this data?","text":"<p>We want to ensure that we are designing the best features, addressing the most pressing bugs, and prioritizing our roadmap appropriately for our users. Collecting analytics on our users\u2019 behaviors gives us valuable insights and allows us to conduct analyses on user behavior within the product. This is important for us so we can make informed decisions- based on how, where and when our users use Weave GitOps - and prioritize what is most important to users like you.</p>"},{"location":"feedback-and-telemetry/#for-example","title":"For example","text":"<p>We\u2019d like to understand the usage of the graph and dependency tabs within the dashboard. If users are utilizing this feature, we would like to understand the value and how we can improve that feature. However, if users aren\u2019t using it, we can conduct research to understand why and either fix it, or come to the conclusion that it really doesn\u2019t serve any utility and focus our efforts on more valuable features.</p>"},{"location":"feedback-and-telemetry/#how-long-is-the-collected-data-stored","title":"How long is the collected data stored?","text":"<p>Weave GitOps\u2019s anonymous user and event data has a 24 month retention policy. The default value for data retention in Pendo is 7 years. For more information on Pendo\u2019s data storage policies, click here.</p>"},{"location":"feedback-and-telemetry/#what-are-we-collecting","title":"What are we collecting?","text":"<p>Weave GitOps gathers data on how the CLI and Web UI are used. There is no way for us or Pendo to connect our IDs to individual users or sites.</p> <p>For the CLI, we gather usage data  on:</p> <ul> <li>The specific sub command itself - e.g. <code>gitops get bcrypt-hash</code></li> <li>The name of the flags used, without the value (e.g. <code>--password</code>, but not the value)</li> <li>A random string used as an anonymous user ID, stored on your machine</li> <li> <ul> <li>Note: We have no way of tracking individual users. We can only distinguish between user counts and event counts</li> </ul> </li> <li>Whether the user has installed the Enterprise or open-source version of the CLI</li> <li>A value of <code>app=cli</code>, to know it\u2019s a CLI metric</li> </ul> <p>For the Web UI, we gather usage data  on:</p> <ul> <li>Your browser, version, and user agent</li> <li>The domain name of your server</li> <li>Every page interaction, and the time each page is left open</li> <li>All button interactions</li> <li>The complete URL of every page, including which resource you look at, and searches done</li> <li>We can push new content into your browser, to add questions, guides, or more data points</li> <li>We send a unique user hash, based on your user name</li> <li> <ul> <li>Note: We are not able to cross-reference unique users between here and anywhere else - not even your command line - but it gives us the ability to distinguish between user counts and event counts.</li> </ul> </li> <li>Finally, we include a persistent ID representing your cluster, based on a hash of your <code>kube-system</code> namespace uuid</li> <li> <ul> <li>Note: There is no way for us to track individual clusters using this, but it gives us the ability to distinguish between cluster counts and event counts.</li> </ul> </li> </ul>"},{"location":"feedback-and-telemetry/#when-is-the-data-collected-and-where-is-it-sent","title":"When is the data collected and where is it sent?","text":"<p>Weave GitOps CLI analytics are sent at startup. The dashboard analytics are sent through its execution. Both CLI and Dashboard analytics are sent to Pendo over HTTPS.</p>"},{"location":"feedback-and-telemetry/#how","title":"How?","text":"<p>The CLI code is viewable in pkg/analytics. It will ignore any errors, e.g. if you don\u2019t have any network connection.</p> <p>The dashboard setup code is viewable in ui/components/Pendo.tsx - this will fetch a 3rd party javascript from Pendo\u2019s servers.</p>"},{"location":"feedback-and-telemetry/#opting-out","title":"Opting out","text":"<p>All the data collected, analytics, and feedback are for the sole purpose of creating better product experience for you and your teams. We would really appreciate it if you left the analytics on as it helps us prioritize which features to build next and what features to improve. However, if you do want to opt out of Weave GitOps\u2019s analytics you can opt out of CLI and/or Dashboard analytics.</p>"},{"location":"feedback-and-telemetry/#cli","title":"CLI","text":"<p>We have created a command to make it easy to turn analytics on or off for the CLI.</p> <p>To disable analytics: gitops set config analytics false</p> <p>To enable analytics: gitops set config analytics true</p>"},{"location":"feedback-and-telemetry/#dashboard","title":"Dashboard","text":"<p>You need to update your helm release to remove <code>WEAVE_GITOPS_FEATURE_TELEMETRY</code> from the <code>envVars</code> value.</p>"},{"location":"help-and-support/","title":"Help and Support","text":""},{"location":"help-and-support/#community","title":"Community","text":"<p>\ud83d\udc4b Come talk to us and other users in the #weave-gitops channel on Weaveworks Community Slack.  </p> <p>Invite yourself if you haven't joined yet.</p>"},{"location":"help-and-support/#flux","title":"Flux","text":"<p>The Flux project has a fantastic community to help support your GitOps journey, find more details on how to reach out via their community page</p>"},{"location":"help-and-support/#commercial-support","title":"Commercial Support","text":"<p>Weaveworks provides Weave GitOps Enterprise, a continuous operations product that makes it easy to deploy and manage Kubernetes clusters and applications at scale in any environment. The single management console automates trusted application delivery and secure infrastructure operations on premise, in the cloud and at the edge.</p> <p>To discuss your support needs, please contact us at sales@weave.works.</p>"},{"location":"help-and-support/#recommended-resources","title":"Recommended resources","text":"<p>Got a suggestion for this list? Please open a pull request using the \"Edit this page\" link at the bottom.</p>"},{"location":"help-and-support/#weaveworks-materials","title":"Weaveworks materials","text":"<ul> <li>GitOps for absolute beginners - eBook from Weaveworks</li> <li>Guide to GitOps - from Weaveworks</li> <li>Awesome GitOps - inspired by https://github.com/sindresorhus/awesome</li> </ul>"},{"location":"help-and-support/#other","title":"Other","text":"<ul> <li>Flux docs - comprehensive documentation on Flux</li> <li>OpenGitOps - CNCF Sandbox project aiming to define a vendor-neutral, principle-led meaning of GitOps.</li> <li>gitops.tech - supported by Innoq</li> </ul>"},{"location":"intro-weave-gitops/","title":"Introducing Weave GitOps","text":"<p>\"GitOps is the best thing since configuration as code. Git changed how we collaborate, but declarative configuration is the key to dealing with infrastructure at scale, and sets the stage for the next generation of management tools\"</p> <p>- Kelsey Hightower, Staff Developer Advocate, Google.</p> <p>Weave GitOps improves developer experience\u2014simplifying the complexities and cognitive load of deploying and managing cloud native apps on Kubernetes so that teams can go faster. It\u2019s a powerful extension of Flux, a leading GitOps engine and Cloud Native Computing Foundation project. Weaveworks are the creators of Flux.</p> <p>Weave GitOps\u2019 intuitive user interface surfaces key information to help application operators easily discover and resolve issues\u2014simplifying and scaling adoption of GitOps and continuous delivery. The UI provides a guided experience that helps users to easily discover the relationships between Flux objects and build understanding while providing insights into application deployments.</p> <p>Today Weave GitOps defaults are Flux, Kustomize, Helm, SOPS, and Kubernetes Cluster API. If you use Flux already, then you can easily add Weave GitOps to create a platform management overlay.</p> <p>Tip</p> <p>Adopting GitOps can bring a number of key benefits\u2014including faster and more frequent deployments, easy recovery from failures, and improved security and auditabiity. Check out our GitOps for Absolute Beginners eBook and Guide to GitOps for more information.</p>"},{"location":"intro-weave-gitops/#getting-started","title":"Getting Started","text":"<p>This user guide provides content that will help you to install and get started with our free and paid offerings: - Weave GitOps Open Source: a simple, open source developer platform for people who don't have Kubernetes expertise but who want cloud native applications. It includes the UI and many other features that take your team beyond a simple CI/CD system. Experience how easy it is to enable GitOps and run your apps in a cluster. Go here to install. - Weave GitOps Enterprise: an enterprise version that adds automation and 100% verifiable trust to existing developer platforms, enabling faster and more frequent deployments with guardrails and golden paths for every app team. Note that Enterprise offers a more robust UI than what you'll find in our open source version. Go here to install.</p> <p>Tip</p> <p>Want to learn more about how Weave GitOps Enterprise can help your team? Get in touch with sales@weave.works to discuss your needs.</p> <p>Weave GitOps works on any Chromium-based browser (Chrome, Opera, Microsoft Edge), Safari, and Firefox. We only support the latest and prior two versions of these browsers.</p> <p>To give Weave GitOps a test drive, we recommend checking out the Open Source version and its UI, then deploying an application. Let's take a closer look at the features it offers you, all for free.</p>"},{"location":"intro-weave-gitops/#weave-gitops-open-source-features","title":"Weave GitOps Open Source Features","text":"<p>Like our Enterprise version, Weave GitOps Open Source fully integrates with Flux as the GitOps engine to provide:</p> <ul> <li> Continuous Delivery through GitOps for apps and infrastructure.</li> <li> Support for GitHub, GitLab, and Bitbucket; S3-compatible buckets as a source; all major container registries; and all CI workflow providers.</li> <li> A secure, pull-based mechanism, operating with least amount of privileges, and adhering to Kubernetes security policies.</li> <li> Compatibility with any conformant Kubernetes version and common ecosystem technologies such as Helm, Kustomize, RBAC, Prometheus, OPA, Kyverno, etc.</li> <li> Multitenancy, multiple Git repositories, multiple clusters.</li> <li> Alerts and notifications.</li> </ul> <p>Some of the things you can do with it:</p> <ul> <li> Application Operations\u2014manage and automate deployment pipelines for apps and more.</li> <li> Easily have your own custom PaaS on cloud or on premise.</li> <li> Coordinate Kubernetes rollouts with virtual machines, databases, and cloud services.</li> <li> Drill down into more detailed information on any given Flux resource.</li> <li> Uncover relationships between resources and quickly navigate between them.</li> <li> Understand how workloads are reconciled through a directional graph.</li> <li> View Kubernetes events relating to a given object to understand issues and changes.</li> <li> Secure access to the dashboard through the ability to integrate with an OIDC provider (such as Dex).</li> </ul> <p>OK, time to install!</p>"},{"location":"monitoring/","title":"Monitoring ENTERPRISE","text":"<p>Weave GitOps Enterprise provides monitoring telemetry and tooling for metrics and profiling. WGE generates Prometheus metrics for monitoring both performance and business operations.</p>"},{"location":"monitoring/#setup","title":"Setup","text":"<p>The following configuration options are available for you to configure <code>monitoring</code>:</p> <pre><code>---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: weave-gitops-enterprise\nnamespace: flux-system\nspec:\nvalues:\nmonitoring:\nenabled: true # enable it if you want to expose a monitoring server\nservice:\nname: monitoring\nport: 8080 # port to expose the monitoring server\nmetrics:\nenabled: true # enable it to expose a prometheus metrics endpoint in `/metrics`\nprofiling:\nenabled: false # enable it to expose a pprof debug endpoint  `/debug/pprof`\n</code></pre> <p>Warning</p> <p>The monitoring server holds private services, so you probably won't need to expose anything beyond your cluster. If you must, ensure that it is properly secured.</p>"},{"location":"monitoring/#get-started-with-monitoring","title":"Get Started with Monitoring","text":"<p>This setup follows the same monitoring approach as Flux and is based on Prometheus Operator. Adapt it to your context as needed.</p> <ol> <li>Enable the monitoring server with the metrics endpoint.</li> <li>Install Kube Prometheus Stack.</li> </ol> Expand to see manifest contents <pre><code>apiVersion: source.toolkit.fluxcd.io/v1\nkind: GitRepository\nmetadata:\nname: weave-gitops-quickstart\nnamespace: flux-system\nspec:\ninterval: 10m0s\nref:\nbranch: main\nurl: https://github.com/weaveworks/weave-gitops-quickstart\n---\napiVersion: v1\nkind: Namespace\nmetadata:\nname: monitoring\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\nname: kube-prometheus-stack\nnamespace: flux-system\nspec:\ninterval: 10m0s\nsourceRef:\nkind: GitRepository\nname: weave-gitops-quickstart\npath: ./monitoring/kube-prometheus-stack\nprune: true\ntargetNamespace: monitoring\nwait: true\n</code></pre> <ol> <li>Deploy Weave GitOps Monitoring Config</li> </ol> Expand to see manifest contents <pre><code>apiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\nname: monitoring-config\nnamespace: flux-system\nspec:\ninterval: 10m0s\nsourceRef:\nkind: GitRepository\nname: weave-gitops-quickstart\npath: ./monitoring/weave-gitops\ndependsOn:\n- name: kube-prometheus-stack\nprune: true\ntargetNamespace: monitoring\n</code></pre> <ol> <li>See the dashboards in Grafana. You can filter by tags <code>flux</code> or <code>weave-gitops</code>.</li> </ol> <p></p>"},{"location":"monitoring/#dashboards","title":"Dashboards","text":"<p>Weave GitOps Overview</p> <p>Monitor Weave GitOps golden signals for API server and controllers:</p> <p></p> <p>Weave GitOps Runtime</p> <p>Monitor Weave GitOps Go runtime metrics like memory usage, memory heap, and Goroutines, among others.</p> <p></p> <p>Explorer</p> <p>You can also monitor Explorer golden signals.</p>"},{"location":"monitoring/#profiling","title":"Profiling","text":"<p>During operations, profiling is useful for gaining a deeper understanding of how Weave GitOps runtime behaves. Given that Weave GitOps is written in Go, profiling happens through pprof. It is exposed as a web endpoint by pprof http.</p>"},{"location":"monitoring/#get-started-with-profiling","title":"Get Started with Profiling","text":"<ol> <li>Enable the monitoring server with the profiling endpoint.</li> <li>Navigate to your monitoring server URL to the <code>/debug/pprof</code> path where the pprof web interface is exposed.</li> </ol> <p>Go here for more info on using <code>pprof</code>.</p>"},{"location":"security/","title":"Weave Gitops Security","text":"<p>This document defines security reporting, handling, disclosure, and audit information for Weave Gitops.</p>"},{"location":"security/#security-process","title":"Security Process","text":""},{"location":"security/#report-a-vulnerability","title":"Report a Vulnerability","text":"<ul> <li>To make a report please email the private security list at security@weave.works with the details.   We ask that reporters act in good faith by not disclosing the issue to others.</li> <li>Reported vulnerabilities are triaged by Weaveworks Security team.</li> <li>Weaveworks Security team would acknowledge to the reporter for any valid request.   You will be able to choose if you want public acknowledgement of your effort and how you would like to be credited.</li> </ul>"},{"location":"security/#handling","title":"Handling","text":"<ul> <li>All reports are thoroughly investigated by the Security Team.</li> <li>Any vulnerability information shared with the Security Team will not be shared with others unless it is necessary to fix the issue.   Information is shared only on a need to know basis.</li> <li>As the security issue moves through the identification and resolution process, the reporter will be notified.</li> <li>Additional questions about the vulnerability may also be asked of the reporter.</li> </ul>"},{"location":"security/#disclosures","title":"Disclosures","text":"<p>Vulnerability disclosures announced publicly. Disclosures will contain an overview, details about the vulnerability, a fix that will typically be an update, and optionally a workaround if one is available.</p> <p>We will coordinate publishing disclosures and security releases in a way that is realistic and necessary for end users. We prefer to fully disclose the vulnerability as soon as possible once a user mitigation is available. Disclosures will always be published in a timely manner after a release is published that fixes the vulnerability.</p>"},{"location":"security/#advisories","title":"Advisories","text":"<p>Here is an overview of all our published security advisories.</p>"},{"location":"security/#weave-gitops-oss","title":"Weave Gitops OSS","text":"Date CVE Security Advisory Severity Affected version(s) 2022-06-23 CVE-2022-31098 Weave GitOps leaked cluster credentials into logs on connection errors Critical &lt;= 0.8.1-rc.5"},{"location":"security/#weave-gitops-enterprise","title":"Weave Gitops Enterprise","text":"Date CVE Security Advisory Severity Affected version(s) 2022-08-27 CVE-2022-38790 Malicious links can be crafted by users and shown in the UI Critical &lt; v0.9.0-rc.5"},{"location":"cluster-management/","title":"Cluster Management Introduction ENTERPRISE","text":"<p>In line with the mantra \u201ccattle, not pets,\u201d Weave GitOps Enterprise (WGE) simplifies managing cluster lifecycle at scale\u2014even massive scale. Through pull requests, which make every action recorded and auditable, WGE makes it possible for teams to create, update, and delete clusters across entire fleets. Breaking things is harder, and recovery is easier. WGE further simplifies the cluster lifecycle management process by providing both a user interface (UI) and a command line interface (CLI) to interact with and manage clusters on-prem, across clouds, and in hybrid environments. You can even use our UI to delete clusters\u2014all it takes is the press of a button that spins up a pull request.</p> <p>WGE fully supports a range of options, including: - Crossplane integration - Terraform integration, with a Terraform Controller that follows the patterns established by Flux - Cluster API</p>"},{"location":"cluster-management/#helm-charts-and-kustomizations-made-easy-with-our-ui","title":"Helm Charts and Kustomizations Made Easy with Our UI","text":"<p>The Weave GitOps Enterprise UI enables you to install software packages to your bootstrapped cluster via the Applications view of our user interface, using a Helm chart (via a HelmRelease) or Kustomization. First, find the \"Add an Application\" button:</p> <p></p> <p>A form will appear, asking you to select the target cluster where you want to add your Application.</p> <p></p> <p>Select the source type of either your Git repository or your Helm repository from the selected cluster:</p> <p></p> <p>If you select Git repository as the source type, you will be able to add the Application from Kustomization:</p> <p></p> <p>If you select Helm repository as the source type, you will be able to add Application from HelmRelease. </p> <p>And if you choose the profiles Helm chart repository URL, you can select a profile from our Profiles list.</p> <p></p> <p>Finally, you can create a pull request to your target cluster and see it on your GitOps repository.</p>"},{"location":"cluster-management/#follow-our-user-guide","title":"Follow Our User Guide","text":"<p>Our user guide provides two pathways to deployment:</p> <ul> <li>One path that shows you how to manage clusters without adding Cluster API. Join a cluster by hooking WGE to it, then install an application on that cluster.</li> <li>An optional path that shows you how to create, provision, and delete your first API cluster with EKS/CAPA.</li> </ul> <p>Just click the option you want to get started with, and let's go.</p>"},{"location":"cluster-management/cluster-management-troubleshooting/","title":"Cluster Management Troubleshooting ENTERPRISE","text":"<p>We'll use this page to help you move past common troublesome situations. </p>"},{"location":"cluster-management/cluster-management-troubleshooting/#git-repositories-and-resources","title":"Git Repositories and Resources","text":"<p>To authenticate using Git during the pull request creation, you will need to select the Git repository where you'll create the pull request.  </p> <p>Depending on the action performed on the resource (creation/deletion/editing), the default Git repository selected in the UI is determined in the following order:</p> <ol> <li> <p>the repository used to initially create the resource found in the <code>templates.weave.works/create-request</code> annotation (in the case of editing or deleting of resources)   <pre><code>metadata:\nannotations:\ntemplates.weave.works/create-request: \"{...\\\"parameter_values\\\":{...\\\"url\\\":\\\"https://github.com/weave-example-org/weave-demo\\\"}\"\n</code></pre></p> </li> <li> <p>the first repository found with a <code>weave.works/repo-role: default</code> annotation   <pre><code>metadata:\nannotations:\nweave.works/repo-role: default\n</code></pre></p> </li> <li> <p>the flux-system repository    <pre><code>metadata:\nname: flux-system\nnamespace: flux-system\n</code></pre></p> </li> <li> <p>the first repository in the list of Git repositories that the user has access to.</p> </li> </ol> <p>In the case of deletion and editing, if the resource repository is found amongst the Git repositories that the user has access to, it will be preselected and the selection will be disabled. If it is not found, you can choose a new repository.</p> <p>In the case of tenants, we recommend adding the <code>weave.works/repo-role: default</code> to an appropriate Git repository.</p>"},{"location":"cluster-management/cluster-management-troubleshooting/#overriding-the-calculated-git-repository-https-url","title":"Overriding the Calculated Git Repository HTTPS URL","text":"<p>The system will try and automatically calculate the correct HTTPS API endpoint to create a pull request against. For example, if the Git repository URL is <code>ssh://git@github.com/org/repo.git</code>, the system will try and convert it to <code>https://github.com/org/repo.git</code>.</p> <p>However, it is not always possible to accurately derive this URL. An override can be specified to set the correct URL instead. For example, the SSH URL may be <code>ssh://git@interal-ssh-server:2222/org/repo.git</code> and the correct HTTPS URL may be <code>https://gitlab.example.com/org/repo.git</code>. </p> <p>In this case, we set the override via the <code>weave.works/repo-https-url</code> annotation on the <code>GitRepository</code> object:</p> <pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: GitRepository\nmetadata:\nname: repo\nnamespace: flux-system\nannotations:\n// highlight-start\nweave.works/repo-https-url: https://gitlab.example.com/org/repo.git\n// highlight-end\nspec:\ninterval: 1m\nurl: ssh://git@interal-ssh-server:2222/org/repo.git\n</code></pre> <p>The pull request will then be created against the correct HTTPS API.</p> <p>The above also applies to application creation.</p>"},{"location":"cluster-management/deploying-capa-eks/","title":"Deploying CAPA with EKS ENTERPRISE","text":"<p>Weave GitOps Enterprise can leverage Cluster API providers to enable leaf cluster creation. Cluster API provides declarative APIs, controllers, and tooling to manage the lifecycle of Kubernetes clusters across a large number of infrastructure providers. Cluster API custom resource definitions (CRDs) are platform-independent as each provider implementation handles the creation of virtual machines, VPCs, networks, and other required infrastructure parts\u2014enabling consistent and repeatable cluster deployments.</p> <p>As an AWS advanced technology partner, Weaveworks has been working tirelessly to ensure that deploying EKS anywhere is smooth and removes the barriers to application modernization.</p>"},{"location":"cluster-management/deploying-capa-eks/#prerequisites","title":"Prerequisites","text":"<p>You'll need to install the following software before continuing with these instructions:</p> <ul> <li><code>github cli</code> &gt;= 2.3.0 (source)</li> <li><code>kubectl</code> (source)</li> <li><code>eksctl</code> (source)</li> <li>the AWS Command Line Interface/<code>aws cli</code> (source)</li> <li><code>clusterctl</code> &gt;= v1.1.3 (source); follow these steps to initialise the cluster and enable feature gates</li> <li><code>clusterawsadm</code> &gt;= v1.1.0, following Cluster API's instructions</li> <li>Make sure you have a management cluster. If you followed the Weave GitOps Enterprise installation guide, you'll have done this already.</li> <li>Configure your <code>AWS_ACCESS_KEY_ID</code>and <code>AWS_SECRET_ACCESS_KEY</code> with either <code>aws configure</code> or by exporting it in the current shell.</li> <li>Set the <code>GITHUB_TOKEN</code> as an environment variable in the current shell. It should have permissions to create Pull Requests against the cluster config repo.</li> </ul>"},{"location":"cluster-management/deploying-capa-eks/#multitenancy","title":"Multitenancy","text":"<p>Some Cluster API providers allow you to choose the account or identity that the new cluster will be created with. This is often referred to as Multi-tenancy in the CAPI world. Weave GitOps currently supports:</p> <ul> <li>AWS multi-tenancy</li> <li>Azure multi-tenancy</li> <li>vSphere multi-tenancy</li> </ul>"},{"location":"cluster-management/deploying-capa-eks/#1-add-common-rbac-to-your-repository","title":"1. Add Common RBAC to Your Repository","text":"<p>When a cluster is provisioned, by default it will reconcile all the manifests in <code>./clusters/&lt;cluster-namespace&gt;/&lt;cluster-name&gt;</code> and <code>./clusters/bases</code>.</p> <p>To display Applications and Sources in the UI we need to give the logged in user permissions to inspect the new cluster.</p> <p>Adding common RBAC rules to <code>./clusters/bases/rbac</code> is an easy way to configure this!</p> <p>import WegoAdmin from \"!!raw-loader!./assets/rbac/wego-admin.yaml\";</p> <pre><code>curl -o clusters/bases/rbac/wego-admin.yaml https://docs.gitops.weave.works/assets/files/wego-admin-c80945c1acf9908fe6e61139ef65c62e.yaml\n</code></pre> Expand to see full template yaml clusters/bases/rbac/wego-admin.yaml<pre><code>\n</code></pre> <p>&lt;CodeBlock title=\"clusters/bases/rbac/wego-admin.yaml\" className=\"language-yaml\"</p> <p>{WegoAdmin} </p>"},{"location":"cluster-management/deploying-capa-eks/#2-build-a-kubernetes-platform-with-built-in-components-preconfigured-for-your-organization","title":"2. Build a Kubernetes Platform with Built-in Components Preconfigured for Your Organization","text":"<p>To do this, go to Weaveworks' Profiles Catalog.</p> <p>See CAPI Templates page for more details on this topic. Once we load a template we can use it in the UI to create clusters!</p> <p>import CapaTemplate from \"!!raw-loader!./assets/templates/capa-template.yaml\";</p> <p>Download the template below to your config repository path, then commit and push to your Git origin.</p> <pre><code>curl -o clusters/management/capi/templates/capa-template.yaml https://docs.gitops.weave.works/assets/files/capa-template-49001fbae51e2a9f365b80caebd6f341.yaml\n</code></pre> clusters/management/apps/capi/templates/capa-template.yaml<pre><code>\n</code></pre> <p>&lt;CodeBlock   title=\"clusters/management/apps/capi/templates/capa-template.yaml\"   className=\"language-yaml\"</p> <p>{CapaTemplate} </p>"},{"location":"cluster-management/deploying-capa-eks/#3-add-a-cluster-bootstrap-config","title":"3. Add a Cluster Bootstrap Config","text":"<p>This step ensures that Flux gets installed into your cluster.\u00a0Create a cluster bootstrap config as follows:</p> <pre><code> kubectl create secret generic my-pat --from-literal GITHUB_TOKEN=$GITHUB_TOKEN\n</code></pre> <p>import CapiGitopsCDC from \"!!raw-loader!./assets/bootstrap/capi-gitops-cluster-bootstrap-config.yaml\";</p> <p>Download the config with:</p> <pre><code>curl -o clusters/management/capi/bootstrap/capi-gitops-cluster-bootstrap-config.yaml https://docs.gitops.weave.works/assets/files/capi-gitops-cluster-bootstrap-config-d9934a1e6872a5b7ee5559d2d97a3d83.yaml\n</code></pre> <p>Then update the <code>GITOPS_REPO</code> variable to point to your cluster</p> Expand to see full yaml clusters/management/capi/boostrap/capi-gitops-cluster-bootstrap-config.yaml<pre><code>\n</code></pre> <p>&lt;CodeBlock title=\"clusters/management/capi/boostrap/capi-gitops-cluster-bootstrap-config.yaml\" className=\"language-yaml\"</p> <p>{CapiGitopsCDC} </p>"},{"location":"cluster-management/deploying-capa-eks/#4-delete-a-cluster-with-the-weave-gitops-enterprise-ui","title":"4. Delete a Cluster with the Weave GitOps Enterprise UI","text":"<p>Here are the steps:</p> <ul> <li>Select the clusters you want to delete</li> <li>Press the <code>Create a PR to delete clusters</code> button</li> <li>Either update the deletion PR values or leave the default values, depending on your situation</li> <li>Press the <code>Remove clusters</code> button</li> <li>Merge the PR for clusters deletion</li> </ul> <p>Note that you can't apply an empty repository to a cluster. If you have Cluster API clusters and other manifests committed to this repository, and then delete all of them so there are zero manifests left, then the apply will fail and the resources will not be removed from the cluster. A workaround is to add a dummy ConfigMap back to the Git repository after deleting everything else so that there is at least one manifest to apply.</p>"},{"location":"cluster-management/deploying-capa-eks/#5-disable-capi-support","title":"5. Disable CAPI Support","text":"<p>If you do not need CAPI-based cluster management support, you can disable CAPI via the Helm Chart values.</p> <p>Update your Weave GitOps Enterprise <code>HelmRelease</code> object with the <code>global.capiEnabled</code> value set to <code>false</code>:</p> clusters/management/weave-gitops-enterprise.yaml<pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: weave-gitops-enterprise-charts\nnamespace: flux-system\nspec:\ninterval: 60m\nsecretRef:\nname: weave-gitops-enterprise-credentials\nurl: https://charts.dev.wkp.weave.works/releases/charts-v3\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: weave-gitops-enterprise\nnamespace: flux-system\nspec:\nchart:\nspec:\ninterval: 65m\nchart: mccp\nsourceRef:\nkind: HelmRepository\nname: weave-gitops-enterprise-charts\nnamespace: flux-system\nversion: 0.12.0\ninstall:\ncrds: CreateReplace\nupgrade:\ncrds: CreateReplace\ninterval: 50m\nvalues:\nglobal:\ncapiEnabled: false\n</code></pre> <p>And that's it!</p>"},{"location":"cluster-management/managing-clusters-without-capi/","title":"Managing Clusters Without Cluster API","text":"<p>import CodeBlock from \"@theme/CodeBlock\"; import BrowserOnly from \"@docusaurus/BrowserOnly\";</p>"},{"location":"cluster-management/managing-clusters-without-capi/#managing-clusters-without-cluster-api-enterprise","title":"Managing Clusters Without Cluster API ENTERPRISE","text":"<p>You do not need Cluster API to add your Kubernetes cluster to Weave GitOps Enterprise. The only thing you need is a secret containing a valid <code>kubeconfig</code>.</p> Existing kubeconfigHow to create a kubeconfig for a ServiceAccount <p>Here's how to create a kubeconfig secret.</p> <ol> <li>Create a new service account on the remote cluster:</li> </ol> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: demo-01\nnamespace: default\n</code></pre> <ol> <li>Add RBAC permissions for the service account:</li> </ol> Expand to see role manifests <pre><code>    ---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: impersonate-user-groups\nsubjects:\n- kind: ServiceAccount\nname: wgesa\nnamespace: default\nroleRef:\nkind: ClusterRole\nname: user-groups-impersonator\napiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: user-groups-impersonator\nrules:\n- apiGroups: [\"\"]\nresources: [\"users\", \"groups\"]\nverbs: [\"impersonate\"]\n- apiGroups: [\"\"]\nresources: [\"namespaces\"]\nverbs: [\"get\", \"list\"]\n</code></pre> <p>This will allow WGE to introspect the cluster for available namespaces.</p> <p>Once we know what namespaces are available we can test whether the logged in user can access them via impersonation.</p> <ol> <li>Retrieve the token from the service account. First, run this command to get the list of secrets of the service accounts:</li> </ol> <pre><code>        kubectl get secrets --field-selector type=kubernetes.io/service-account-token\n        NAME                      TYPE                                  DATA   AGE\n        default-token-lsjz4       kubernetes.io/service-account-token   3      13d\n        demo-01-token-gqz7p       kubernetes.io/service-account-token   3      99m\n</code></pre> <p>(<code>demo-01-token-gqz7p</code> is the secret that holds the token for <code>demo-01</code> service account.)</p> <p>Then, run the following command to get the service account token:</p> <pre><code>TOKEN=$(kubectl get secret demo-01-token-gqz7p -o jsonpath={.data.token} | base64 -d)\n</code></pre> <ol> <li>Create a kubeconfig secret. We'll use a helper script to generate the kubeconfig, and then save it into <code>static-kubeconfig.sh</code>:</li> </ol> Expand to see script static-kubeconfig.sh<pre><code>    #!/bin/bash\nif [[ -z \"$CLUSTER_NAME\" ]]; then\necho \"Ensure CLUSTER_NAME has been set\"\nexit 1\nfi\nif [[ -z \"$CA_CERTIFICATE\" ]]; then\necho \"Ensure CA_CERTIFICATE has been set to the path of the CA certificate\"\nexit 1\nfi\nif [[ -z \"$ENDPOINT\" ]]; then\necho \"Ensure ENDPOINT has been set\"\nexit 1\nfi\nif [[ -z \"$TOKEN\" ]]; then\necho \"Ensure TOKEN has been set\"\nexit 1\nfi\nexport CLUSTER_CA_CERTIFICATE=$(cat \"$CA_CERTIFICATE\" | base64)\nenvsubst &lt;&lt;EOF\n    apiVersion: v1\n    kind: Config\n    clusters:\n    - name: $CLUSTER_NAME\n        cluster:\n            server: https://$ENDPOINT\n            certificate-authority-data: $CLUSTER_CA_CERTIFICATE\n    users:\n    - name: $CLUSTER_NAME\n        user:\n            token: $TOKEN\n    contexts:\n    - name: $CLUSTER_NAME\n        context:\n            cluster: $CLUSTER_NAME\n            user: $CLUSTER_NAME\n    current-context: $CLUSTER_NAME\n    EOF\n</code></pre> <ol> <li> <p>Obtain the cluster certificate (CA). How you do this depends on your cluster.</p> </li> <li> <p>AKS: Visit the Azure user docs for more information.</p> </li> <li>EKS: Visit the EKS docs for more information.</li> <li>GKE: You can view the CA on the GCP Console: Cluster-&gt;Details-&gt;Endpoint-&gt;\u201dShow cluster certificate\u201d.</li> </ol> <p>You'll need to copy the contents of the certificate into the <code>ca.crt</code> file used below.</p> <pre><code>CLUSTER_NAME=demo-01 \\\nCA_CERTIFICATE=ca.crt \\\nENDPOINT=&lt;control-plane-ip-address&gt; \\\nTOKEN=&lt;token&gt; ./static-kubeconfig.sh &gt; demo-01-kubeconfig\n</code></pre> <ol> <li> <p>Update the following fields:</p> </li> <li> <p>CLUSTER_NAME: insert the name of your cluster\u2014i.e., <code>demo-01</code></p> </li> <li>ENDPOINT: add the API server endpoint i.e. <code>34.218.72.31</code></li> <li>CA_CERTIFICATE: include the path to the CA certificate file of the cluster</li> <li> <p>TOKEN: add the token of the service account retrieved in the previous step</p> </li> <li> <p>Finally, create a secret for the generated kubeconfig in the WGE management cluster:</p> </li> </ol> <pre><code>kubectl create secret generic demo-01-kubeconfig \\\n--from-file=value=./demo-01-kubeconfig\n</code></pre>"},{"location":"cluster-management/managing-clusters-without-capi/#adding-kubeconfig-to-your-management-cluster","title":"Adding kubeconfig to Your Management Cluster","text":"<p>If you already have a <code>kubeconfig</code> stored in a secret in your management cluster, continue with the \"Create a <code>GitopsCluster</code>\" step below.</p> <p>If you have a kubeconfig, but it is not yet stored in your management cluster, load it into the cluster using this command:</p> <pre><code>kubectl create secret generic demo-01-kubeconfig \\\n--from-file=value=./demo-01-kubeconfig\n</code></pre>"},{"location":"cluster-management/managing-clusters-without-capi/#add-a-cluster-bootstrap-config","title":"Add a Cluster Bootstrap Config","text":"<p>This step ensures that Flux gets installed into your cluster.\u00a0Create a cluster bootstrap config as follows:</p> <pre><code> kubectl create secret generic my-pat --from-literal GITHUB_TOKEN=$GITHUB_TOKEN\n</code></pre> <p>import CapiGitopsCDC from \"!!raw-loader!./assets/bootstrap/capi-gitops-cluster-bootstrap-config.yaml\";</p> <p>Download the config with:</p> <p>   {() =&gt; (            curl -o       clusters/management/capi/bootstrap/capi-gitops-cluster-bootstrap-config.yaml{\" \"}       {window.location.protocol}       //{window.location.host}       {         require(\"./assets/bootstrap/capi-gitops-cluster-bootstrap-config.yaml\")           .default       }        )} </p> <p>Then update the <code>GITHUB_USER</code> variable to point to your repository</p> Expand to see full yaml <p>&lt;CodeBlock title=\"clusters/management/capi/boostrap/capi-gitops-cluster-bootstrap-config.yaml\" className=\"language-yaml\"</p> <p>{CapiGitopsCDC} </p>"},{"location":"cluster-management/managing-clusters-without-capi/#connect-a-cluster","title":"Connect a Cluster","text":"<p>To connect your cluster, you need to add some common RBAC rules into the <code>clusters/bases</code> folder. When a cluster is provisioned, by default it will reconcile all the manifests in <code>./clusters/&lt;cluster-namespace&gt;/&lt;cluster-name&gt;</code> and <code>./clusters/bases</code>.</p> <p>To display Applications and Sources in the UI, we need to give the logged-in user the permission to inspect the new cluster. Adding common RBAC rules to <code>./clusters/bases/rbac</code> is an easy way to configure this.</p> <p>import WegoAdmin from \"!!raw-loader!./assets/rbac/wego-admin.yaml\";</p> <p>   {() =&gt; (            curl -o clusters/bases/rbac/wego-admin.yaml {window.location.protocol}//       {window.location.host}       {require(\"./assets/rbac/wego-admin.yaml\").default}        )} </p> Expand to see full template yaml <p>&lt;CodeBlock title=\"clusters/bases/rbac/wego-admin.yaml\" className=\"language-yaml\"</p> <p>{WegoAdmin} </p>"},{"location":"cluster-management/managing-clusters-without-capi/#create-a-gitopscluster","title":"Create a <code>GitopsCluster</code>","text":"<p>When a <code>GitopsCluster</code> appears in the cluster, the Cluster Bootstrap Controller will install Flux on it and by default start reconciling the <code>./clusters/demo-01</code> path in your management cluster's Git repository:</p> ./clusters/management/clusters/demo-01.yaml<pre><code>apiVersion: gitops.weave.works/v1alpha1\nkind: GitopsCluster\nmetadata:\nname: demo-01\nnamespace: default\n# Signals that this cluster should be bootstrapped.\nlabels:\nweave.works/capi: bootstrap\nspec:\nsecretRef:\nname: demo-01-kubeconfig\n</code></pre> <p>To use the Weave GitOps Enterprise user interface (UI) to inspect the Applications and Sources running on the new cluster, you'll need permissions. We took care of this above when we stored your RBAC rules in <code>./clusters/bases</code>. In the following step, we'll create a kustomization to add these common resources onto our new cluster:</p> ./clusters/demo-01/clusters-bases-kustomization.yaml<pre><code>apiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\ncreationTimestamp: null\nname: clusters-bases-kustomization\nnamespace: flux-system\nspec:\ninterval: 10m0s\npath: clusters/bases\nprune: true\nsourceRef:\nkind: GitRepository\nname: flux-system\n</code></pre> <p>Save these two files in your Git repository, then commit and push.</p> <p>Once Flux has reconciled the cluster, you can inspect your Flux resources via the UI!</p>"},{"location":"cluster-management/managing-clusters-without-capi/#debugging-tip-checking-that-your-kubeconfig-secret-is-in-your-cluster","title":"Debugging Tip: Checking that Your kubeconfig Secret Is in Your Cluster","text":"<p>To test that your kubeconfig secret is correctly set up, apply the following manifest and check the logs after the job completes:</p> Expand to see manifest <pre><code>    ---\napiVersion: batch/v1\nkind: Job\nmetadata:\nname: kubectl\nspec:\nttlSecondsAfterFinished: 30\ntemplate:\nspec:\ncontainers:\n- name: kubectl\nimage: bitnami/kubectl\nargs:\n[\n\"get\",\n\"pods\",\n\"-n\",\n\"kube-system\",\n\"--kubeconfig\",\n\"/etc/kubeconfig/value\",\n]\nvolumeMounts:\n- name: kubeconfig\nmountPath: \"/etc/kubeconfig\"\nreadOnly: true\nrestartPolicy: Never\nvolumes:\n- name: kubeconfig\nsecret:\nsecretName: demo-01-kubeconfig\noptional: false\n</code></pre> <p>In the manifest above, <code>demo-01-kubeconfig</code> is the name of the secret that contains the kubeconfig for the remote cluster.</p>"},{"location":"cluster-management/managing-clusters-without-capi/#additional-resources","title":"Additional Resources","text":"<p>Other documentation that you might find useful:</p> <ul> <li>Authentication strategies</li> <li>X509 client certificates: can be used across different namespaces</li> <li>Service account tokens: limited to a single namespace</li> <li>Kubernetes authentication 101 (CNCF blog post)</li> <li>Kubernetes authentication (Magalix blog post)</li> </ul>"},{"location":"cluster-management/profiles/","title":"Profiles ENTERPRISE","text":"<p>BEFORE YOU START</p> <p>The following instructions require you to make minor changes to the content of your own hosted Helm repository.</p> <p>To put it simply, Profiles are Helm charts. To create a Profile, you need to add an annotation to a Helm chart.</p> <p>A very simple Helm chart marked up as a Profile looks like this: <pre><code>name: demo-profile\nversion: 0.0.1\nannotations:\nweave.works/profile: \"A Demo Profile\"\n</code></pre> The chart can use either subcharts or dependencies to include other charts. These other charts do not need the annotation, and they will not show up as Profiles.</p>"},{"location":"cluster-management/profiles/#mark-a-helmrepository-as-containing-profiles","title":"Mark a HelmRepository as Containing Profiles","text":"<p>Alternatively, you can annotate a Flux <code>HelmRepository</code> <pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: podinfo\nnamespace: default\nannotations:\nweave.works/profiles: \"true\" # this identifies all charts as profiles\nspec:\ninterval: 5m0s\nurl: https://stefanprodan.github.io/podinfo\n</code></pre></p> <p>This will ensure that all charts in the <code>HelmRepository</code> are identified as Profiles.</p>"},{"location":"cluster-management/profiles/#add-layers-to-define-dependencies-between-your-profiles","title":"Add Layers to Define Dependencies Between Your Profiles","text":"<p>Profile layers are a mechanism for loosely defining dependencies between Profiles.</p> <p>To add a layer to a Profile chart: <pre><code>name: demo-profile\nversion: 0.0.1\nannotations:\nweave.works/profile: \"A Demo Profile\"\nweave.works/layer: \"demo\"\n</code></pre></p> <p>When multiple Profiles are specified in an API call, with layers in the API request then the set of layers is sorted, reversed, and configured as dependencies using Flux's dependsOn mechanism. <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \u2502      \u2502         \u2502      \u2502         \u2502\n\u2502 layer-3 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u25ba layer-2 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u25ba layer-1 \u2502\n\u2502         \u2502      \u2502         \u2502      \u2502         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n dependsOn        dependsOn\n</code></pre></p> <p>The scope of the <code>dependsOn</code> calculation is limited to the set of Profiles in the API call.</p> <p>If only one chart is being installed, no <code>dependsOn</code> is configured.</p> <p>If several charts are installed in the same layer, then the preceeding layer charts will be configured to depend on all the charts in the succeeding layer. <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          \u2502     \u2502         \u2502      \u2502         \u2502\n\u2502 layer-3  \u251c\u2500\u2500\u2500\u2500\u2500\u25ba layer-2 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u25ba layer-1 \u2502\n\u2502          \u2502     \u2502         \u2502      \u2502         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n dependsOn \u2502      dependsOn         \u2502\n           \u2502                        \u2502\n           \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n           \u2502     \u2502         \u2502        \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u25ba layer-2 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502         \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  dependsOn\n</code></pre> If a chart with no layer specified is installed with a chart that has a layer specified, the service will configure the <code>dependsOn</code> for the chart without a layer to depend on the chart with layer.</p>"},{"location":"cluster-management/profiles/#optional-use-a-helm-chart-from-a-remote-publicprivate-repository","title":"(Optional) Use a Helm Chart from a Remote Public/Private Repository","text":"<p>You can add your Profiles to a remote repository that can be referenced using a HelmRepository resource. The repository can be either public or private. Using a private repo requires a few extra steps.</p> <p>In this example, a public repo and branch is referenced directly where the Helm releases are: HelmRepository.yaml<pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: HelmRepository\nmetadata:\nname: weaveworks-charts\nnamespace: flux-system\nspec:\ninterval: 1m\nurl: https://weaveworks.github.io/weave-gitops-profile-examples/\n</code></pre></p> <p>To use private repositories with restricted access, you can use a secret synced to the target leaf cluster. SecretSync references the secret as <code>spec.secretRef</code>. The labels of your target leaf cluster are added for the syncer to match clusters against those labels using <code>spec.clusterSelector.matchLabels</code>.</p> SecretSync.yaml<pre><code>apiVersion: capi.weave.works/v1alpha1\nkind: SecretSync\nmetadata:\nname: my-dev-secret-syncer\nnamespace: flux-system\nspec:\nclusterSelector:\nmatchLabels:\nweave.works/capi: bootstrap\nsecretRef:\nname: weave-gitops-enterprise-credentials\ntargetNamespace: flux-system\n</code></pre> <p>Once the SecretSync and Secret are available, the secret can be directly referenced in the HelmRepository object:</p> PrivateHelmRepository.yaml<pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: weaveworks-charts\nnamespace: flux-system\nspec:\ninterval: 60m\nsecretRef:\nname: weave-gitops-enterprise-credentials\nurl: https://charts.dev.wkp.weave.works/releases/charts-v3\n</code></pre> <p>Note: The <code>HelmRepoSecret</code>, <code>SecretSync</code>, and the <code>GitopsCluster</code> should all be in the same namespace.</p>"},{"location":"cluster-management/profiles/#select-the-profiles-you-want-installed-at-cluster-creation","title":"Select the Profiles You Want Installed at Cluster Creation","text":"<p>WGE inspects the namespace in the management cluster where it is deployed, and looks for a <code>HelmRepository</code> object named <code>weaveworks-charts</code>. This Kubernetes object should point to a Helm chart repository that includes the Profiles available for installation.</p> <p>When creating a cluster from the UI using a CAPI template, these Profiles are available for selection in the <code>Profiles</code> section of the template. For example:</p> <p></p> <p>As shown above, some Profiles are optional, while others are required. This is determined when the template is authored and allows for operations teams to control which Helm packages should be installed on new clusters by default.</p> <p>To enable editing of the yaml values for required Profiles, add the <code>editable</code> flag in the annotation and describe the required Profile in the template. For example: </p> <pre><code>apiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: connect-a-cluster-with-policies\nnamespace: default\nannotations:\ncapi.weave.works/profile-0: '{\"name\": \"weave-policy-agent\", \"editable\": true, \"version\": \"0.2.8\", \"values\": \"accountId: weaveworks\\nclusterId: ${CLUSTER_NAME}\" }'\n</code></pre>"},{"location":"cluster-management/advanced-cluster-management-topics/how-to-inject-credentials-into-template/","title":"How to Inject Credentials Into Your Template ENTERPRISE","text":"<p>Weave GitOps templates describe the properties of your cluster\u2014how many nodes, what version of Kubernetes, etc. The identity refers to which account will be used to create the cluster. When you render a template, you may want to set the credentials to be used for this cluster\u2014for example, if the cost is allocated to a specific team.</p> <p>The rendered resource can be automatically configured with the selected credentials.</p> <p>Credentials are injected into the following resources: * AWSCluster, AWSManagedControlPlane * AzureCluster, AzureManagedCluster * VSphereCluster</p> <p>If no credentials are selected, no changes will be applied, and the credentials used by your CAPI controller will be used as the default.</p> <p>In our cluster we have the template:</p> <pre><code>apiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: capa-cluster-template\nspec:\nresourcetemplates:\n- contents:\n- apiVersion: infrastructure.cluster.x-k8s.io/v1alpha4\nkind: AWSCluster\nmetadata:\nname: \"${CLUSTER_NAME}\"\nspec:\nregion: \"${AWS_REGION}\"\n</code></pre> <p>and the identity</p> <pre><code>apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3\nkind: AWSClusterStaticIdentity\nmetadata:\nname: \"test-account\"\nspec:\nsecretRef:\nname: test-account-creds\nnamespace: capa-system\nallowedNamespaces:\nselector:\nmatchLabels:\ncluster.x-k8s.io/ns: \"testlabel\"\n</code></pre> <p>We can select Weave GitOps to use the <code>test-account</code> when creating the cluster by using the Infrastructure provider credentials dropdown on the Create new cluster with template page:</p> <p></p> <p>The resulting definition will have the identity injected into the appropriate place in the template, for this example:</p> <pre><code>apiVersion: infrastructure.cluster.x-k8s.io/v1alpha4\nkind: AWSCluster\nmetadata:\nname: example-cluster\nspec:\nregion: eu-north-1\nidentityRef:\nkind: AWSClusterStaticIdentity\nname: test-account\n</code></pre>"},{"location":"cluster-management/advanced-cluster-management-topics/how-to-inject-credentials-into-template/#identityrefs","title":"<code>identityRef</code>s","text":"<p>The supported providers implement multi-tenancy by setting an <code>identityRef</code> on the the provider cluster object, e.g. <code>AWSCluster</code>, <code>AzureCluster</code> or <code>VSphereCluster</code>.</p> <p>Weave GitOps will search all namespaces in the cluster for potential identities that can be used to create a cluster. The following identity <code>kind</code>s are currently supported and their corresponding Cluster kinds:</p> <ul> <li><code>AWSClusterStaticIdentity</code>: <code>AWSCluster</code></li> <li><code>AWSClusterRoleIdentity</code>: <code>AWSCluster</code></li> <li><code>AzureClusterIdentity</code>: <code>AzureCluster</code></li> <li><code>VSphereClusterIdentity</code>: <code>VSphereCluster</code></li> </ul>"},{"location":"enterprise/","title":"Weave GitOps Enterprise ENTERPRISE","text":"<p>Ready for more GitOps?</p> <p>To purchase an entitlement to Weave GitOps Enterprise, please contact sales@weave.works.</p> <p>Weave GitOps Enterprise provides ops teams with an easy way to assess the health of multiple clusters in a single place. It shows cluster information such as Kubernetes version and number of nodes and provides details about the GitOps operations on those clusters, such as Git repositories and recent commits. Additionally, it aggregates Prometheus alerts to assist with troubleshooting.</p> <p>If you have already purchased your entitlement, head to the installation page.</p>"},{"location":"enterprise/#feature-breakdown","title":"Feature Breakdown","text":"<p>In addition to the features in the OSS edition, Weave GitOps Enterprise offers the following capabilities, taking your delivery from simple Continuous Delivery to Internal Developer Platform:</p>"},{"location":"enterprise/#cluster-fleet-management","title":"Cluster Fleet Management","text":"<p>Weave GitOps Enterprise (WGE) simplifies cluster lifecycle management at scale\u2014even massive scale. Through pull requests, which make every action recorded and auditable, WGE makes it possible for teams to create, update, and delete clusters across entire fleets. WGE further simplifies the process by providing both a user interface (UI) and a command line interface (CLI) for teams to interact with and manage clusters on-prem, across clouds, and in hybrid environments. WGE works with Terraform, Crossplane, and any Cluster API provider.</p> <p></p>"},{"location":"enterprise/#trusted-application-delivery","title":"Trusted Application Delivery","text":"<p>Add policy as code to GitOps pipelines and enforce security and compliance, application resilience and coding standards from source to production. Validate policy conformance at every step in the software delivery pipeline: commit, build, deploy and run time.</p>"},{"location":"enterprise/#progressive-delivery","title":"Progressive Delivery","text":"<p>Deploy into production environments safely using canary, blue/green deployment, and A/B strategies. Simple, single-file configuration defines success rollback. Measure Service Level Objectives (SLOs) using observability metrics from Prometheus, Datadog, New Relic, and others.</p>"},{"location":"enterprise/#cd-pipelines","title":"CD Pipelines","text":"<p>Rollout new software from development to production. Environment rollouts that work with your existing CI system.</p>"},{"location":"enterprise/#team-workspaces","title":"Team Workspaces","text":"<p>Allow DevOps teams to work seamlessly together with multi-tenancy, total RBAC control, and policy enforcement, with integration to enterprise IAM.</p>"},{"location":"enterprise/#self-service-templates-and-profiles","title":"Self-Service Templates and Profiles","text":"<p>Component profiles enable teams to deploy standard services quickly, consistently and reliably. Teams can curate the profiles that are available within their estate ensuring there is consistency everywhere. Using GitOps it's easy to guarantee the latest, secure versions of any component are deployed in all production systems.</p>"},{"location":"enterprise/#health-status-and-compliance-dashboards","title":"Health Status and Compliance Dashboards","text":"<p>Gain a single view of the health and state of the cluster and its workloads. Monitor deployments and alert on policy violations across apps and clusters.</p>"},{"location":"enterprise/#kubernetes-anywhere","title":"Kubernetes Anywhere","text":"<p>Reduce complexity with GitOps and install across all major target environments including support for on-premise, edge, hybrid, and multi-cloud Kubernetes clusters.</p>"},{"location":"enterprise/#critical-247-support","title":"Critical 24/7 Support","text":"<p>Your business and workloads operate around the clock, and so do we. Whenever you have a problem, our experts are there to help. We\u2019ve got your back!</p>"},{"location":"enterprise/install-enterprise-airgap/","title":"Install Enterprise in Air-gapped Environments ENTERPRISE","text":"<p>From wikipedia</p> <p>An air gap, air wall, air gapping or disconnected network is a network security measure employed on one or more computers to ensure that a secure computer network is physically isolated from unsecured networks, such as the public Internet or an unsecured local area network...</p> <p>This document guides on how to install Weave GitOps Enterprise (WGE) in a restricted environment.</p>"},{"location":"enterprise/install-enterprise-airgap/#before-you-start","title":"Before You Start","text":"<p>There are multiple restrictions that could happen within an air-gapped environment. This guide assumes that you have egress network restrictions. In order to install WGE, the required artifacts must be loaded from a private registry. This guide helps you with the task to identity the Helm charts and container images required to install WGE and to load them into your private registry.</p> <p>It also assumes that you could prepare the installation from a proxy host. A proxy host is defined here as a computer that is able to access to both the public and private network. It could take different shapes, for example, it could be a bastion host, a corp laptop, etc.</p> <p>Access to both public and private network is required during the airgap installation but not simultaneously. It is expected to have an online stage to gather the artifacts first, and an offline stage later, to load the artifacts in the private network.</p> <p>Finally, we aim to provide an end to end example to use it as a guidance more than a recipe. Feel free to adapt the details that do not fit within your context.</p>"},{"location":"enterprise/install-enterprise-airgap/#install-wge","title":"Install WGE","text":"<p>There are different variations of the following stages and conditions. We consider that installing  WGE in an air-gapped environment could follow the following stages.</p> <ol> <li>Set up a WGE install environment.</li> <li>Collect artifacts and publish to a private registry.</li> <li>Install WGE in the air-gapped environment.</li> </ol>"},{"location":"enterprise/install-enterprise-airgap/#set-up-a-wge-install-environment","title":"Set up a WGE install environment","text":"<p>The main goal of this stage is to recreate a local WGE within your context, to collect the container images and Helm charts, that will be required in your private registry for the offline installation.</p> <p>A three-step setup is followed.</p> <ol> <li>Setup a proxy host</li> <li>Setup a private registry</li> <li>Install WGE</li> </ol>"},{"location":"enterprise/install-enterprise-airgap/#setup-a-proxy-host","title":"Setup a proxy host","text":"<p>There are many possible configurations for this host. This guide will assume that the host has installed the following:</p> <ul> <li>docker as container runtime.</li> <li>kubectl and kind</li> <li>helm</li> <li>skopeo to manage container images</li> <li>flux to boostrap Flux in the environment.</li> <li>clusterctl to replicate the cluster management capabilities.</li> </ul>"},{"location":"enterprise/install-enterprise-airgap/#create-a-kind-cluster","title":"Create a Kind Cluster","text":"<p>Create a kind cluster with registry following this guide</p>"},{"location":"enterprise/install-enterprise-airgap/#install-flux","title":"Install Flux","text":"<p>You could just use <code>flux install</code> to install Flux into your kind cluster</p>"},{"location":"enterprise/install-enterprise-airgap/#set-up-a-helm-repo","title":"Set up a Helm repo","text":"<p>We are going to install ChartMuseum via Flux.</p> <p>Remember to also install helm plugin cm-push.</p> Expand to see installation yaml <pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: chartmuseum\nnamespace: flux-system\nspec:\ninterval: 10m\nurl: https://chartmuseum.github.io/charts\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: chartmuseum\nnamespace: flux-system\nspec:\nchart:\nspec:\nchart: chartmuseum\nsourceRef:\nkind: HelmRepository\nname: chartmuseum\nnamespace: flux-system\ninterval: 10m0s\ntimeout: 10m0s\nreleaseName: helm-repo\ninstall:\ncrds: CreateReplace\nremediation:\nretries: 3\nvalues:\nenv:\nopen:\nDISABLE_API: \"false\"\nAUTH_ANONYMOUS_GET: \"true\"\n</code></pre> <p>Set up access from your host.</p> <p><pre><code>#expose kubernetes svc\nkubectl -n flux-system port-forward svc/helm-repo-chartmuseum 8080:8080 &amp;\n\n#add hostname\nsudo -- sh -c \"echo 127.0.0.1 helm-repo-chartmuseum &gt;&gt; /etc/hosts\"\n</code></pre> Test that you could reach it. <pre><code>#add repo to helm\nhelm repo add private http://helm-repo-chartmuseum:8080\n\n#test that works\nhelm repo update private\n</code></pre></p> <p>At this stage you have already a private registry for container images and helm charts.</p>"},{"location":"enterprise/install-enterprise-airgap/#install-wge_1","title":"Install WGE","text":"<p>This step is to gather the artifacts and images in your local environment to push to the private registry.</p>"},{"location":"enterprise/install-enterprise-airgap/#cluster-api","title":"Cluster API","text":"<p>This would vary depending on the provider, given that we target a offline environment, most likely we are in a private cloud environment, so we will be using liquidmetal.</p> <p>Export these environment variables to configure your CAPI experience. Adjust them to your context.</p> <pre><code>export CAPI_BASE_PATH=/tmp/capi\nexport CERT_MANAGER_VERSION=v1.9.1\nexport CAPI_VERSION=v1.3.0\nexport CAPMVM_VERSION=v0.7.0\nexport EXP_CLUSTER_RESOURCE_SET=true\nexport CONTROL_PLANE_MACHINE_COUNT=1\nexport WORKER_MACHINE_COUNT=1\nexport CONTROL_PLANE_VIP=\"192.168.100.9\"\nexport HOST_ENDPOINT=\"192.168.1.130:9090\"\n</code></pre> <p>Execute the following script to generate <code>clusterctl</code> config file.</p> <p><pre><code>cat &lt;&lt; EOF &gt; clusterctl.yaml\ncert-manager:\n  url: \"$CAPI_BASE_PATH/cert-manager/$CERT_MANAGER_VERSION/cert-manager.yaml\"\n\nproviders:\n  - name: \"microvm\"\n    url: \"$CAPI_BASE_PATH/infrastructure-microvm/$CAPMVM_VERSION/infrastructure-components.yaml\"\n    type: \"InfrastructureProvider\"\n  - name: \"cluster-api\"\n    url: \"$CAPI_BASE_PATH/cluster-api/$CAPI_VERSION/core-components.yaml\"\n    type: \"CoreProvider\"\n  - name: \"kubeadm\"\n    url: \"$CAPI_BASE_PATH/bootstrap-kubeadm/$CAPI_VERSION/bootstrap-components.yaml\"\n    type: \"BootstrapProvider\"\n  - name: \"kubeadm\"\n    url: \"$CAPI_BASE_PATH/control-plane-kubeadm/$CAPI_VERSION/control-plane-components.yaml\"\n    type: \"ControlPlaneProvider\"\nEOF\n</code></pre> Execute <code>make</code> using the following makefile to intialise CAPI in your cluster:</p> Expand to see Makefile contents <pre><code>.PHONY := capi\n\ncapi: capi-init capi-cluster\n\ncapi-init: cert-manager cluster-api bootstrap-kubeadm control-plane-kubeadm microvm clusterctl-init\n\ncert-manager:\nmkdir -p  $(CAPI_BASE_PATH)/cert-manager/$(CERT_MANAGER_VERSION)\ncurl -L https://github.com/cert-manager/cert-manager/releases/download/$(CERT_MANAGER_VERSION)/cert-manager.yaml --output $(CAPI_BASE_PATH)/cert-manager/$(CERT_MANAGER_VERSION)/cert-manager.yaml\n\ncluster-api:\nmkdir -p  $(CAPI_BASE_PATH)/cluster-api/$(CAPI_VERSION)\ncurl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CAPI_VERSION)/core-components.yaml --output $(CAPI_BASE_PATH)/cluster-api/$(CAPI_VERSION)/core-components.yaml\n    curl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CAPI_VERSION)/metadata.yaml --output $(CAPI_BASE_PATH)/cluster-api/$(CAPI_VERSION)/metadata.yaml\n\nbootstrap-kubeadm:\nmkdir -p  $(CAPI_BASE_PATH)/bootstrap-kubeadm/$(CAPI_VERSION)\ncurl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CAPI_VERSION)/bootstrap-components.yaml --output $(CAPI_BASE_PATH)/bootstrap-kubeadm/$(CAPI_VERSION)/bootstrap-components.yaml\n    curl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CAPI_VERSION)/metadata.yaml --output $(CAPI_BASE_PATH)/bootstrap-kubeadm/$(CAPI_VERSION)/metadata.yaml\n\ncontrol-plane-kubeadm:\nmkdir -p  $(CAPI_BASE_PATH)/control-plane-kubeadm/$(CAPI_VERSION)\ncurl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CAPI_VERSION)/control-plane-components.yaml --output $(CAPI_BASE_PATH)/control-plane-kubeadm/$(CAPI_VERSION)/control-plane-components.yaml\n    curl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CAPI_VERSION)/metadata.yaml --output $(CAPI_BASE_PATH)/control-plane-kubeadm/$(CAPI_VERSION)/metadata.yaml\n\nmicrovm:\nmkdir -p  $(CAPI_BASE_PATH)/infrastructure-microvm/$(CAPMVM_VERSION)\ncurl -L https://github.com/weaveworks-liquidmetal/cluster-api-provider-microvm/releases/download/$(CAPMVM_VERSION)/infrastructure-components.yaml --output $(CAPI_BASE_PATH)/infrastructure-microvm/$(CAPMVM_VERSION)/infrastructure-components.yaml\n    curl -L https://github.com/weaveworks-liquidmetal/cluster-api-provider-microvm/releases/download/$(CAPMVM_VERSION)/cluster-template-cilium.yaml --output $(CAPI_BASE_PATH)/infrastructure-microvm/$(CAPMVM_VERSION)/cluster-template-cilium.yaml\n    curl -L https://github.com/weaveworks-liquidmetal/cluster-api-provider-microvm/releases/download/$(CAPMVM_VERSION)/metadata.yaml --output $(CAPI_BASE_PATH)/infrastructure-microvm/$(CAPMVM_VERSION)/metadata.yaml\n\nclusterctl-init:\nclusterctl init --wait-providers -v 4 --config clusterctl.yaml --infrastructure microvm\n\ncapi-cluster:\nclusterctl generate cluster --config clusterctl.yaml -i microvm:$(CAPMVM_VERSION) -f cilium lm-demo | kubectl apply -f -\n</code></pre>"},{"location":"enterprise/install-enterprise-airgap/#deploying-the-terraform-controller","title":"Deploying the Terraform Controller","text":"<p>Apply the following example manifest to deploy the Terraform Controller:</p> Expand to see file contents <pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: tf-controller\nnamespace: flux-system\nspec:\ninterval: 10m\nurl: https://weaveworks.github.io/tf-controller/\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: tf-controller\nnamespace: flux-system\nspec:\nchart:\nspec:\nchart: tf-controller\nversion: \"0.9.2\"\nsourceRef:\nkind: HelmRepository\nname: tf-controller\nnamespace: flux-system\ninterval: 10m0s\ninstall:\ncrds: CreateReplace\nremediation:\nretries: 3\nupgrade:\ncrds: CreateReplace\n</code></pre>"},{"location":"enterprise/install-enterprise-airgap/#wge","title":"WGE","text":"<p>Update the following manifest to your context.</p> Expand to see file contents <pre><code>---\napiVersion: v1\ndata:\ndeploy-key: &lt;changeme&gt;\nentitlement: &lt;changeme&gt;\npassword: &lt;changeme&gt;\nusername: &lt;changeme&gt;\nkind: Secret\nmetadata:\nlabels:\nkustomize.toolkit.fluxcd.io/name: shared-secrets\nkustomize.toolkit.fluxcd.io/namespace: flux-system\nname: weave-gitops-enterprise-credentials\nnamespace: flux-system\ntype: Opaque\n---\napiVersion: v1\ndata:\npassword: &lt;changeme&gt;\nusername: &lt;changeme&gt;\nkind: Secret\nmetadata:\nlabels:\nkustomize.toolkit.fluxcd.io/name: enterprise\nkustomize.toolkit.fluxcd.io/namespace: flux-system\nname: cluster-user-auth\nnamespace: flux-system\ntype: Opaque\n---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: weave-gitops-enterprise-charts\nnamespace: flux-system\nspec:\ninterval: 10m\nsecretRef:\nname: weave-gitops-enterprise-credentials\nurl: https://charts.dev.wkp.weave.works/releases/charts-v3\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: weave-gitops-enterprise\nnamespace: flux-system\nspec:\nchart:\nspec:\nchart: mccp\nversion: \"0.10.2\"\nsourceRef:\nkind: HelmRepository\nname: weave-gitops-enterprise-charts\nnamespace: flux-system\ninterval: 10m0s\ninstall:\ncrds: CreateReplace\nremediation:\nretries: 3\nupgrade:\ncrds: CreateReplace\nvalues:\nglobal:\ncapiEnabled: true\nenablePipelines: true\nenableTerraformUI: true\nclusterBootstrapController:\nenabled: true\ncluster-controller:\ncontrollerManager:\nkubeRbacProxy:\nimage:\nrepository: gcr.io/kubebuilder/kube-rbac-proxy\ntag: v0.8.0\nmanager:\nimage:\nrepository: docker.io/weaveworks/cluster-controller\ntag: v1.4.1\npolicy-agent:\nenabled: true\nimage: weaveworks/policy-agent\npipeline-controller:\ncontroller:\nmanager:\nimage:\nrepository: ghcr.io/weaveworks/pipeline-controller\nimages:\nclustersService: docker.io/weaveworks/weave-gitops-enterprise-clusters-service:v0.10.2\nuiServer: docker.io/weaveworks/weave-gitops-enterprise-ui-server:v0.10.2\nclusterBootstrapController: weaveworks/cluster-bootstrap-controller:v0.4.0\n</code></pre> <p>At this stage you should have a local management cluster with Weave GitOps Enterprise installed.</p> <pre><code>\u279c kubectl get pods -A\nNAMESPACE                           NAME                                                              READY   STATUS    RESTARTS      AGE\n...\nflux-system                         weave-gitops-enterprise-cluster-controller-6f8c69dc8-tq994        2/2     Running   5 (12h ago)   13h\nflux-system                         weave-gitops-enterprise-mccp-cluster-bootstrap-controller-cxd9c   2/2     Running   0             13h\nflux-system                         weave-gitops-enterprise-mccp-cluster-service-8485f5f956-pdtxw     1/1     Running   0             12h\nflux-system                         weave-gitops-enterprise-pipeline-controller-85b76d95bd-2sw7v      1/1     Running   0             13h\n...\n</code></pre> <p>You can observe the installed Helm Charts with <code>kubectl</code>:</p> <pre><code>kubectl get helmcharts.source.toolkit.fluxcd.io\nNAME                                  CHART           VERSION   SOURCE KIND      SOURCE NAME                      AGE   READY   STATUS\nflux-system-cert-manager              cert-manager    0.0.7     HelmRepository   weaveworks-charts                13h   True    pulled 'cert-manager' chart with version '0.0.7'\nflux-system-tf-controller             tf-controller   0.9.2     HelmRepository   tf-controller                    13h   True    pulled 'tf-controller' chart with version '0.9.2'\nflux-system-weave-gitops-enterprise   mccp            v0.10.2   HelmRepository   weave-gitops-enterprise-charts   13h   True    pulled 'mccp' chart with version '0.10.2'\n</code></pre> <p>As well as the container images:</p> <pre><code>kubectl get pods --all-namespaces -o jsonpath=\"{.items[*].spec['containers','initContainers'][*].image}\" |tr -s '[[:space:]]' '\\n' \\\n| sort | uniq | grep -vE 'kindest|etcd|coredns'\n\ndocker.io/prom/prometheus:v2.34.0\ndocker.io/weaveworks/cluster-controller:v1.4.1\ndocker.io/weaveworks/weave-gitops-enterprise-clusters-service:v0.10.2\ndocker.io/weaveworks/weave-gitops-enterprise-ui-server:v0.10.2\nghcr.io/fluxcd/flagger-loadtester:0.22.0\nghcr.io/fluxcd/flagger:1.21.0\nghcr.io/fluxcd/helm-controller:v0.23.1\nghcr.io/fluxcd/kustomize-controller:v0.27.1\nghcr.io/fluxcd/notification-controller:v0.25.2\n...\n</code></pre>"},{"location":"enterprise/install-enterprise-airgap/#collect-and-publish-artifacts","title":"Collect and Publish Artifacts","text":"<p>This section guides you to push installed artifacts to your private registry. Here's a Makefile to help you with each stage:</p> Expand to see Makefile contents <pre><code>    .PHONY := all\n\n    #set these variable with your custom configuration\nPRIVATE_HELM_REPO_NAME=private\n    REGISTRY=localhost:5001\n    WGE_VERSION=0.10.2\n\n    WGE=mccp-$(WGE_VERSION)\nWGE_CHART=$(WGE).tgz\n\n    all: images charts\n\n    charts: pull-charts push-charts\n\n    images:\n        kubectl get pods --all-namespaces -o jsonpath=\"{.items[*].spec['containers','initContainers'][*].image}\" \\\n|tr -s '[[:space:]]' '\\n' | sort | uniq | grep -vE 'kindest|kube-(.*)|etcd|coredns' | xargs -L 1 -I {} ./image-sync.sh {} $(REGISTRY)\nkubectl get microvmmachinetemplates --all-namespaces -o jsonpath=\"{.items[*].spec.template.spec.kernel.image}\"|tr -s '[[:space:]]' '\\n' \\\n| sort | uniq | xargs -L 1 -I {} ./image-sync.sh {} $(REGISTRY)\n\npull-charts:\n        curl -L https://s3.us-east-1.amazonaws.com/weaveworks-wkp/releases/charts-v3/$(WGE_CHART) --output  $(WGE_CHART)\n\npush-charts:\n        helm cm-push -f $(WGE_CHART) $(PRIVATE_HELM_REPO_NAME)\n</code></pre> <p>The <code>image-sync.sh</code> referenced in the <code>images</code> target of the the above Makefile is similar to:</p> <pre><code>skopeo copy docker://$1 docker://$2/$1 --preserve-digests --multi-arch=all\n</code></pre> <p>Skopeo allows you to configure a range a security features to meet your requirements. For example, configuring trust policies before pulling or signing containers before making them available in your private network. Feel free to adapt the previous script to meet your security needs.</p> <ol> <li>Configure the environment variables to your context.</li> <li>Execute <code>make</code> to automatically sync Helm charts and container images.</li> </ol> <pre><code>\u279c  resources git:(docs-airgap-install) \u2717 make\nkubectl get microvmmachinetemplates --all-namespaces -o jsonpath=\"{.items[*].spec.template.spec.kernel.image}\"|tr -s '[[:space:]]' '\\n' \\\n| sort | uniq | xargs -L 1 -I {} ./image-pull-push.sh {} docker-registry:5000\n\n5.10.77: Pulling from weaveworks-liquidmetal/flintlock-kernel\nDigest: sha256:5ef5f3f5b42a75fdb69cdd8d65f5929430f086621e61f00694f53fe351b5d466\nStatus: Image is up to date for ghcr.io/weaveworks-liquidmetal/flintlock-kernel:5.10.77\nghcr.io/weaveworks-liquidmetal/flintlock-kernel:5.10.77\n...5.10.77: digest: sha256:5ef5f3f5b42a75fdb69cdd8d65f5929430f086621e61f00694f53fe351b5d466 size: 739\n</code></pre>"},{"location":"enterprise/install-enterprise-airgap/#airgap-install","title":"Airgap Install","text":""},{"location":"enterprise/install-enterprise-airgap/#weave-gitops-enterprise","title":"Weave GitOps Enterprise","text":"<p>At this stage you have in your private registry both the Helm charts and container images required to install Weave GitOps Enterprise. Now you are ready to install WGE from your private registry.</p> <p>Follow the instructions to install WGE with the following considerations:</p> <ol> <li>Adjust Helm Releases <code>spec.chart.spec.sourceRef</code> to tell Flux to pull Helm charts from your Helm repo.</li> <li>Adjust Helm Releases <code>spec.values</code> to use the container images from your private registry.</li> </ol> <p>An example of how it would look for Weave GitOps Enterprise is shown below.</p> Expand to view example WGE manifest weave-gitops-enterprise.yaml<pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: weave-gitops-enterprise-charts\nnamespace: flux-system\nspec:\ninterval: 1m\nurl: http://helm-repo-chartmuseum:8080\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: weave-gitops-enterprise\nnamespace: flux-system\nspec:\nchart:\nspec:\nchart: mccp\nversion: \"0.10.2\"\nsourceRef:\nkind: HelmRepository\nname: weave-gitops-enterprise-charts\nnamespace: flux-system\ninterval: 1m0s\ninstall:\ncrds: CreateReplace\nremediation:\nretries: 3\nupgrade:\ncrds: CreateReplace\nvalues:\nglobal:\ncapiEnabled: true\nenablePipelines: true\nenableTerraformUI: true\nclusterBootstrapController:\nenabled: true\n#images changed\ncluster-controller:\ncontrollerManager:\nkubeRbacProxy:\nimage:\nrepository: localhost:5001/gcr.io/kubebuilder/kube-rbac-proxy\ntag: v0.8.0\nmanager:\nimage:\nrepository: localhost:5001/docker.io/weaveworks/cluster-controller\ntag: v1.4.1\npolicy-agent:\nenabled: true\nimage: localhost:5001/weaveworks/policy-agent\npipeline-controller:\ncontroller:\nmanager:\nimage:\nrepository: localhost:5001/ghcr.io/weaveworks/pipeline-controller\nimages:\nclustersService: localhost:5001/docker.io/weaveworks/weave-gitops-enterprise-clusters-service:v0.10.2\nuiServer: localhost:5001/docker.io/weaveworks/weave-gitops-enterprise-ui-server:v0.10.2\nclusterBootstrapController: localhost:5001/weaveworks/cluster-bootstrap-controller:v0.4.0\n</code></pre>"},{"location":"enterprise/install-enterprise-airgap/#cluster-api_1","title":"Cluster API","text":"<p>Indicate in the Cluster API configuration file <code>clusterctl.yaml</code> that you want to use images from the private repo by leveraging image overrides.</p> <p><pre><code>images:\nall:\nrepository: localhost:5001/registry.k8s.io/cluster-api\ninfrastructure-microvm:\nrepository: localhost:5001/ghcr.io/weaveworks-liquidmetal\n</code></pre> Then execute <code>make clusterctl-init</code> to init capi using your private registry.</p>"},{"location":"enterprise/install-enterprise-azure/","title":"Azure and Weave GitOps Enterprise Installation ENTERPRISE","text":"<p>Once you successfully create your Kubernetes cluster in Azure Marketplace, follow these steps to Install Weave GitOps Enterprise. These instructions apply to both Azure AKS and Azure ARC clusters\u2014they'll behave in the same way.</p> <p>Tip</p> <p>If you have already installed Flux, then Azure Flux will refuse to install.</p>"},{"location":"enterprise/install-enterprise-azure/#1-choose-the-gitops-option-in-the-marketplace","title":"1. Choose the \u201cGitOps\u201d Option in the Marketplace","text":"<p>Search for Weave GitOps Enterprise in the \"Extensions + Applications\" of the Azure Marketplace. Click the \"GitOps\" option. This will take you to a screen that presents a first-class item called <code>Type: Flux v2</code>.</p> <p>Click GitOps =&gt; Create.</p> <p>Add the config name, namespace (default), scope: cluster, type (Flux v2), and continuous reconciliation option. Your entries should look like this:</p> <ul> <li>Configuration: flux-system</li> <li>Namespace: flux-system</li> <li>Scope: Cluster</li> </ul> <p>All of the displayed properties for the Flux objects screen are the same as what you'd supply to Flux bootstrap.</p>"},{"location":"enterprise/install-enterprise-azure/#optional-install-capz-the-capi-provider","title":"Optional: Install CAPZ, the CAPI Provider","text":"<p>If you are planning to manage or connect CAPI clusters to the WE service make sure you first install the CAPI provider. Then during the WE installation process be sure to select the \"Enable CAPI support\" checkbox.</p>"},{"location":"enterprise/install-enterprise-azure/#2-apply-the-entitlements-secret","title":"2. Apply the Entitlements Secret","text":"<p>Contact sales@weave.works for a valid entitlements secret. This will come in the form of a file \u201centitlements.yaml\u201d. Apply it to the cluster:</p> <pre><code>kubectl apply -f entitlements.yaml\n</code></pre>"},{"location":"enterprise/install-enterprise-azure/#3-configure-access-for-writing-to-git-from-the-ui","title":"3. Configure Access for Writing to Git from the UI","text":"<p>(This section is the same as what you'll find in the main WGE install documentation.)</p> <p>Here we provide guidance for GitHub, GitLab, BitBucket Server, and Azure DevOps.</p> <p>  GitHub requires no additional configuration for OAuth Git access  </p> <p>Create a GitLab OAuth application that will request <code>api</code> permissions to create pull requests on your behalf.</p> <p>Follow the GitLab docs.</p> <p>The application should have at least these scopes:</p> <ul> <li><code>api</code></li> <li><code>openid</code></li> <li><code>email</code></li> <li><code>profile</code></li> </ul> <p>Add callback URLs to the application for each address the UI will be exposed on, e.g.:</p> <ul> <li><code>https://localhost:8000/oauth/gitlab</code> for port-forwarding and testing</li> <li><code>https://git.example.com/oauth/gitlab</code> for production use</li> </ul> <p>Save your application, taking note of the Client ID and Client Secret. Save them into the <code>git-provider-credentials</code> secret, along with:</p> <ul> <li><code>GIT_HOST_TYPES</code> to tell WGE that the host is gitlab</li> <li><code>GITLAB_HOSTNAME</code> where the OAuth app is hosted</li> </ul> <p>Replace values in this snippet and run:</p> <pre><code>kubectl create secret generic git-provider-credentials --namespace=flux-system \\\n--from-literal=\"GITLAB_CLIENT_ID=13457\" \\\n--from-literal=\"GITLAB_CLIENT_SECRET=24680\" \\\n--from-literal=\"GITLAB_HOSTNAME=git.example.com\" \\\n--from-literal=\"GIT_HOST_TYPES=git.example.com=gitlab\"\n</code></pre> <p> </p> <p>Create a new incoming application link from the BitBucket administration dashboard. You will be asked to enter a unique name and the redirect URL for the external application. The redirect URL should be set to <code>&lt;WGE dashboard URL&gt;/oauth/bitbucketserver</code>. You will also need to select permissions for the application. The minimum set of permissions needed for WGE to create pull requests on behalf of users is <code>Repositories - Write</code>. An example of configuring these settings is shown below.</p> <p> </p> Configuring a new incoming application link <p>Save your application and take note of the Client ID and Client Secret. Save them into the <code>git-provider-credentials</code> secret, along with:</p> <ul> <li><code>GIT_HOST_TYPES</code> to tell WGE that the host is bitbucket-server</li> <li><code>BITBUCKET_SERVER_HOSTNAME</code> where the OAuth app is hosted</li> </ul> <p>Replace values in this snippet and run:</p> <pre><code>kubectl create secret generic git-provider-credentials --namespace=flux-system \\\n--from-literal=\"BITBUCKET_SERVER_CLIENT_ID=13457\" \\\n--from-literal=\"BITBUCKET_SERVER_CLIENT_SECRET=24680\" \\\n--from-literal=\"BITBUCKET_SERVER_HOSTNAME=git.example.com\" \\\n--from-literal=\"GIT_HOST_TYPES=git.example.com=bitbucket-server\"\n</code></pre> <p>If the secret is already present, use the following command to update it using your default editor:</p> <pre><code>kubectl edit secret generic git-provider-credentials --namespace=flux-system\n</code></pre> <p>Info</p> <p>If BitBucket Server is running on the default port (7990), make sure you include the port number in the values of the secret. For example: <code>GIT_HOST_TYPES=git.example.com:7990=bitbucket-server</code></p> <p></p> <p></p> <p>Navigate to VisualStudio and register a new application, as explained in the docs. Set the authorization callback URL and select which scopes to grant. Set the callback URL to <code>&lt;WGE dashboard URL&gt;/oauth/azuredevops</code>.</p> <p>Select the <code>Code (read and write)</code> scope from the list. This is necessary so that WGE can create pull requests on behalf of users. An example of configuring these settings is shown below.</p> <p> </p> Creating a new application <p>After creating your application, you will be presented with the application settings. Take note of the <code>App ID</code> and <code>Client Secret</code> values\u2014you will use them to configure WGE.</p> <p> </p> Application settings <p>In your cluster, create a secret named <code>git-provider-credentials</code> that contains the <code>App ID</code> and <code>Client Secret</code> values from the newly created application.</p> <p>Replace values in this snippet and run:</p> <pre><code>kubectl create secret generic git-provider-credentials --namespace=flux-system \\\n--from-literal=\"AZURE_DEVOPS_CLIENT_ID=&lt;App ID value&gt;\" \\\n--from-literal=\"AZURE_DEVOPS_CLIENT_SECRET=&lt;Client Secret value&gt;\"\n</code></pre> <p>WGE is now configured to ask users for authorization the next time a pull request must be created as part of using a template. Note that each user can view and manage which applications they have authorized by navigating to https://app.vsaex.visualstudio.com/me.</p> <p> </p>"},{"location":"enterprise/install-enterprise-azure/#4-configure-your-password","title":"4. Configure Your Password","text":"<p>First, install the Weave GitOps Enterprise CLI tool. To do this, you can use either brew or curl.</p> <p> </p> <pre><code>brew install weaveworks/tap/gitops-ee\n</code></pre> <p></p> <p></p> <pre><code>curl --silent --location \"https://artifacts.wge.dev.weave.works/releases/bin/0.27.0/gitops-$(uname)-$(uname -m).tar.gz\" | tar xz -C /tmp\nsudo mv /tmp/gitops /usr/local/bin\ngitops version\n</code></pre> <p> </p> <p>Now, to login to the WGE UI, generate a bcrypt hash for your chosen password and store it as a secret in the Kubernetes cluster. There are several different ways to generate a bcrypt hash. Here, we'll use <code>gitops get bcrypt-hash</code> from our GitOps CLI.</p> <pre><code>PASSWORD=\"&lt;Make up and insert a brand-new password here&gt;\"\necho -n $PASSWORD | gitops get bcrypt-hash | kubectl create secret generic cluster-user-auth -n flux-system --from-literal=username=wego-admin --from-file=password=/dev/stdin\n</code></pre> <p>A validation to know it\u2019s working:</p> <pre><code>kubectl get secret -n flux-system cluster-user-auth\n</code></pre>"},{"location":"enterprise/install-enterprise-azure/#5-install-weave-gitops-enterprise-to-your-cluster","title":"5. Install Weave GitOps Enterprise to Your Cluster","text":"<p>First, you'll get taken to the Weaveworks portal on the Azure platform, which provides your subscription details.</p> <p>Search for Weave GitOps. Pick \"View private products\" and choose WGE. Fill out the forms, selecting your cluster, then choose \"Review and Create\".</p>"},{"location":"enterprise/install-enterprise-azure/#6-apply-extra-configuration","title":"6. Apply Extra Configuration","text":"<p>Additional configuration is done through an optional ConfigMap:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: cluster-service-extra-config\n  namespace: flux-system\ndata:\n  # disable TLS\nNO_TLS: \"true\"\n</code></pre> <p>Apply the configuration with:</p> <pre><code>kubectl apply -f cluster-service-extra-config.yaml\n\n# restart the clusters-service for changes to take effect\nkubectl -n flux-system rollout restart deploy/weave-gitops-enterprise-mccp-cluster-service\n</code></pre>"},{"location":"enterprise/install-enterprise-azure/#available-configuration-options","title":"Available Configuration Options","text":"value default description <code>NO_TLS</code> <code>\"false\"</code> disable TLS <code>CLUSTER_NAME</code> <code>\"management\"</code> name of the management cluster <code>AUTH_METHODS</code> <code>\"token-passthrough,user-account\"</code> Which auth methods to use, valid values are 'oidc', 'token-pass-through' and 'user-account' <code>OIDC_ISSUER_URL</code> <code>\"token-passthrough,user-account\"</code> The URL of the OpenID Connect issuer <code>OIDC_CLIENT_ID</code> <code>\"token-passthrough,user-account\"</code> The client ID for the OpenID Connect client <code>OIDC_CLIENT_SECRET</code> <code>\"token-passthrough,user-account\"</code> The client secret to use with OpenID Connect issuer <code>OIDC_REDIRECT_URL</code> <code>\"token-passthrough,user-account\"</code> The OAuth2 redirect URL <code>OIDC_TOKEN_DURATION</code> <code>\"1h\"</code> The duration of the ID token. It should be set in the format: number + time unit (s,m,h) e.g., 20m <code>OIDC_CLAIM_USERNAME</code> <code>\"email\"</code> JWT claim to use as the user name. By default email, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as sub or name, depending on their provider <code>OIDC_CLAIM_GROUPS</code> <code>\"groups\"</code> JWT claim to use as the user's group. If the claim is present it must be an array of strings <code>CUSTOM_OIDC_SCOPES</code> <code>\"groups, openid, email, profile\"</code> Customise the requested scopes for then OIDC authentication flow - openid will always be requested"},{"location":"enterprise/install-enterprise-azure/#7-check-that-it-works","title":"7. Check That It Works","text":"<p>Go to the \"services and ingresses\" tab in the Azure portal and look for signs that the UI installed.</p>"},{"location":"enterprise/install-enterprise-azure/#troubleshooting","title":"Troubleshooting","text":"<p>WGE will try and automatically install Flux on a new cluster. If this fails for some reason, or if you need a custom Flux installation, you can manually install it before installing WGE.</p> <p>Click \"Next\" and add:</p> <ul> <li>Source Kind: Git repository</li> <li>Repository URL: [your repository URL here]</li> <li>Reference Type: Branch</li> <li>Repository Type: Private</li> </ul> <p>And under the \"Authentication\" section:</p> <ul> <li>Authentication Source: Provide Authentication here</li> <li>SSH Key Authentication: Let the operator generate SSH Keys</li> <li>HTTPS User: YOUR_GITHUB_USERNAME</li> <li>HTTPS Key: YOUR_GITHUB_USER_PAT (Get one at this link. It's not the most secure method, but the easiest to get going.)</li> </ul> <p>Click \"Next\". You'll see an option to create a Kustomisation, which is optional. To create one:</p> <ul> <li>Click Create</li> <li>Instance name: flux-system</li> <li>Path: clusters/default/demo3-azure-flux</li> <li>Prune: Ticked</li> </ul> <p>Click \"Save\". Then clicking \"Next\", which will give you a summary so you can review your input. Then click \"Create\". It will take about five minutes to deploy.</p> <p>You'll get to a new screen, which at the top-right shows \"Notifications\" and will display creation of the Flux configuration. When your deployment succeeds, go to the resource and pin to your dashboard. Then go to your terminal to see if it works in kubectl. In the terminal you'll get the GitRepository and Kustomizations. You should then get a green \"succeeded\" checkmark.</p> <p>The Kustomisations screen does not provide an option to inspect the path/target namespace\u2014you have to supply the target Namespace in the Kustomization object.</p>"},{"location":"enterprise/install-enterprise-azure/#next-steps","title":"Next Steps","text":"<p>From this point, you can follow our generalized WGE installation instructions to configure TLS and log into the UI. Installing the Azure Marketplace product installs the Helm chart.</p>"},{"location":"enterprise/install-enterprise-cli/","title":"Install Weave GitOps Enterprise via CLI","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>You could install Weave GitOps Enterprise via <code>gitops-ee bootstrap</code> CLI command which is suitable for two main scenarios:</p> <ol> <li>Day 0: you want to get started quickly for discovery with the less knowledge possible.</li> <li>Day 1: you have done discovery and want to set it up in your organisation.</li> </ol> <p>Each scenario is supported by an operation modes:</p> <ol> <li>Interactive: guides you step-by-step through the process until Weave GitOps Enterprise is up and running.</li> <li>Non-interactive: for your automated workflows where you are already familiar with install process and have the configuration.</li> </ol> <p>For those seeking other scenarios or fine-grain customisation Weave GitOps Enterprise manual install would be the recommended.</p>"},{"location":"enterprise/install-enterprise-cli/#getting-started","title":"Getting Started","text":""},{"location":"enterprise/install-enterprise-cli/#prerequisites","title":"Prerequisites","text":"<p>Before you start make sure the following requirements are met:</p> <ul> <li> Management Cluster: a Kubernetes cluster with a Kubeconfig that has Admin permissions to be able to create resources.</li> <li> Git Repository with SSH access: this is the configuration repo that WeaveGitOps will use to sync configuration manifests from.</li> <li> Flux CLI: is installed locally. It will be used for reconciling Flux resources.</li> <li> Flux Bootstrapped in your Management cluster via ssh. See Flux Bootstrap for more info.</li> <li> Weave GitOps Enterprise Entitlements are installed in the management cluster. Contact Sales for help on getting them.</li> </ul>"},{"location":"enterprise/install-enterprise-cli/#install-gitops-ee-cli-v035","title":"Install <code>gitops-ee</code> CLI (&gt; v0.35)","text":"<p>Weave GitOps Enterprise Bootstrap functionality is available on Weave GitOps Enterprise CLI starting from version v0.35. If you haven't already, please install the latest <code>gitops-ee</code> CLI using this command.</p> <pre><code>brew install weaveworks/tap/gitops-ee\n</code></pre>"},{"location":"enterprise/install-enterprise-cli/#bootstrap-weave-gitops-enterprise","title":"Bootstrap Weave GitOps Enterprise","text":"<p>Please use the following command to start the installation wizard of Weave GitOps Enterprise.</p> Interactive <pre><code>gitops bootstrap\n</code></pre> <p>The bootstrap wizard will take you step-by-step into configuring Weave GitOps Enterprise. To understand more about the CLI configurations experience, check the below sections here.</p> Non-Interactive <p>You could run the bootstrap command in non-interactive mode by providing the required configurations as flags. The following gives you an example to get started that you could adapt to your own context</p> <pre><code> gitops bootstrap \\\n--kubeconfig=$HOME/.kube/config \\\n--private-key=$HOME/.ssh/id_rsa --private-key-password=\"\" \\\n--version=\"0.35.0\" \\\n--domain-type=\"localhost\" \\\n--password=\"admin123\"\n</code></pre> <p>For more information about the CLI configurations, check the below sections here</p>"},{"location":"enterprise/install-enterprise-cli/#appendix","title":"Appendix","text":""},{"location":"enterprise/install-enterprise-cli/#understanding-gitops-ee-bootstrap","title":"Understanding <code>gitops-ee bootstrap</code>","text":"<p><code>gitops-ee bootstrap</code> is a workflow that will take you through the following stages:</p> <ol> <li>Verify Flux: verify Flux installation on the Management cluster.</li> <li>Verify Entitlement: verify the Entitlements secret content (username, password, entitlement).</li> <li>Configure Git Access: configure the access to your configuration repo.</li> <li>Select WGE version: from the latest 3 available releases.</li> <li>Create Cluster User: create a Secret with the username and password for the emergency cluster user.</li> <li>Configure Dashboard Access: choose between 2 methods to access the dashboard either local or external.</li> <li>Access the dashboard: via the link from the installation success message.</li> <li>(Optional) Configure OIDC: to enable login to dashboard via OIDC providers.</li> </ol>"},{"location":"enterprise/install-enterprise-cli/#verify-flux","title":"Verify Flux","text":"<p>Weave GitOps Enterprise runs on top of flux, the bootstrap CLI will check if flux is installed on the management cluster, and it will verify that it has the right version with valid git repository setup, and it is able to reconcile flux components properly. If flux is installed, but doesn't have a valid installation, the bootstrap CLI will terminate pending the fix or uninstall of current flux installation.</p>"},{"location":"enterprise/install-enterprise-cli/#verify-entitlement","title":"Verify Entitlement","text":"<p>Weave GitOps Enterprise Entitlement is your obtained license to use our product. The Entitlements file is a Kubernetes secret that contains your licence. <code>Bootstrapping</code> checks that the secret exists on the management cluster, and that it is valid will check if it has valid content and the entitlement is not expired. To get the entitlement secret please contact sales@weave.works, then apply it on your management cluster with the name <code>weave-gitops-enterprise-credentials</code> under <code>flux-system</code> namespace.</p>"},{"location":"enterprise/install-enterprise-cli/#configure-git-access","title":"Configure Git Access","text":"<p>In order for <code>gitops-ee bootstrap</code> to push WGE resources to the management cluster's git repository, you will be prompted to provide the private key used to access your repo via ssh. If the private key is encrypted, you will also be asked to provide the private key password.</p> <p>Info</p> <p>Disclaimer: The bootstrap CLI will ONLY use the private key to push WGE resources to your repo, and won't use it in any other way that can comprimise your repo or clusters security.</p>"},{"location":"enterprise/install-enterprise-cli/#select-wge-version","title":"Select WGE version","text":"<p>The bootstrap CLI will prompt you to choose from the latest 3 versions of Weave GitOps Enterprise.</p>"},{"location":"enterprise/install-enterprise-cli/#create-cluster-user","title":"Create Cluster User","text":"<p>You will be prompt to provide admin username and password, which will be used to access the dashboard. This will create admin secret with the credentials. If you already have previous admin credentials on your cluster, the installation will prompt you if you want to continue with the old credentials or exit and revoke them and re-run the installation.</p>"},{"location":"enterprise/install-enterprise-cli/#configure-dashboard-access","title":"Configure Dashboard Access","text":"<p>To access Weave GitOps Enterprise dashboard, you have the two following options available:</p> <ol> <li>Service: this option is called <code>localhost</code> in the cli and the dashboard will be available through a ClusterIP Service.</li> <li>Ingress: this option is called <code>externaldns</code> the dashboard will be available through an Ingress with the following considerations:<ul> <li>An Ingress controller needs to exist.</li> <li>A host-based ingress will be created of the ingress class <code>public-nginx</code>.</li> <li>An ExternalDNS annotation will be added with the value of the provided domain.</li> </ul> </li> </ol>"},{"location":"enterprise/install-enterprise-cli/#access-the-dashboard","title":"Access the dashboard","text":"<p>After installation is successful. The CLI will print out the URL where you can access the dashboard.</p>"},{"location":"enterprise/install-enterprise-cli/#optional-configure-oidc","title":"(Optional) Configure OIDC","text":"<p>OIDC configuration will enable you to login with OIDC provider beside, or instead of the admin credentials. Afte the installation is complete, you will be prompt if you want to configure OIDC access. If you don't want to set it up right away, you can do it later by running <code>gitops-ee bootstrap auth --type=oidc</code> command.</p> <p>To configure OIDC access, you will be asked to provide the following values: <code>DiscoveryUrl</code> this will verify that OIDC is accessible and get the issuerUrl from the OIDC settings. <code>clientID</code> &amp; <code>clientSecret</code> that you have configured on your OIDC static-clients.</p> <p>Note</p> <p>Please don't forget to add a new static-client on your OIDC provider settings with the redirectURI <code>your-domain/oauth2/callback</code> for example <code>http://localhost:3000/oauth2/callback</code></p>"},{"location":"enterprise/install-enterprise-cli/#cli-configurations","title":"CLI configurations","text":"<ul> <li><code>--kube-config</code>:                  allows to choose the Kubeconfig for your cluster, default would be ~/.kube/config</li> <li><code>-d</code>, <code>--domain externaldns</code>:     indicate the domain to use in case of using externaldns</li> <li><code>-t</code>, <code>--domain-type</code>:            dashboard domain type: could be 'localhost' or 'externaldns'</li> <li><code>-h</code>, <code>--help</code>:                   help for bootstrap</li> <li><code>-p</code>, <code>--password</code>:               Dashboard admin password</li> <li><code>-k</code>, <code>--private-key</code>:            Private key path. This key will be used to push the Weave GitOps Enterprise's resources to the default cluster repository</li> <li><code>-c</code>, <code>--private-key-password</code>:   Private key password. If the private key is encrypted using password</li> <li><code>-u</code>, <code>--username</code>:               Dashboard admin username</li> <li><code>-v</code>, <code>--version</code>:                Weave GitOps Enterprise version to install</li> </ul>"},{"location":"enterprise/install-enterprise/","title":"Install Weave GitOps Enterprise ENTERPRISE","text":"<p>Info</p> <p>To purchase an entitlement to Weave GitOps Enterprise, please contact sales@weave.works. There is no need to install the open source version of Weave GitOps before installing Weave GitOps Enterprise.</p>"},{"location":"enterprise/install-enterprise/#prerequisites","title":"Prerequisites","text":"<p>To get up and running with Weave GitOps Enterprise: - create a Kubernetes cluster - add your cluster to kubeconfig\u2014which you'll get from Kubernetes\u2014so that the kubeconfig correctly points to the management cluster - create a Git repository; in the instructions below, we refer to a <code>fleet-infra</code> repository - configure your Git client properly (if using GitHub, for example, then review their docs on setting your username and your email address) - obtain a valid entitlement secret from Weaveworks and apply it to your cluster - install a compatible version of Flux onto your cluster; see below for how-to guidance</p>"},{"location":"enterprise/install-enterprise/#install-the-weave-gitops-enterprise-cli-tool","title":"Install the Weave GitOps Enterprise CLI Tool","text":"<p>To do this, you can use either brew or curl.</p> Homebrew <pre><code>brew install weaveworks/tap/gitops-ee\n</code></pre> <p></p> <p>=== \"Curl\"&gt;</p> <pre><code>```bash\nexport VERSION=&lt;VERSION&gt;\ncurl --silent --location \"https://artifacts.wge.dev.weave.works/releases/bin/${VERSION}/gitops-$(uname)-$(uname -m).tar.gz\" | tar xz -C /tmp\nsudo mv /tmp/gitops /usr/local/bin\ngitops version\n```\n</code></pre>"},{"location":"enterprise/install-enterprise/#install-flux-onto-your-cluster-with-the-flux-bootstrap-command","title":"Install Flux Onto Your Cluster with the <code>flux bootstrap</code> Command","text":"<p>The <code>flux bootstrap</code> command enables you to deploy Flux on a cluster the GitOps way. Go here for more information about the command.</p> GitHubGitLab <pre><code>flux bootstrap github \\\n--owner=&lt;github username&gt; \\\n--repository=fleet-infra \\\n--branch=main \\\n--path=./clusters/management \\\n--personal \\\n--components-extra image-reflector-controller,image-automation-controller\n</code></pre> <pre><code>flux bootstrap gitlab \\\n--owner=&lt;gitlab username&gt; \\\n--repository=fleet-infra \\\n--branch=main \\\n--path=./clusters/management \\\n--personal \\\n--components-extra image-reflector-controller,image-automation-controller\n</code></pre> <p>Your private Git repo should have a clusters/management folder that includes the manifests Flux needs to operate, and that also generates a key value pair for Flux to access the repo.</p> <ul> <li>owner: The username (or organization) of the Git repository</li> <li>repository: Git repository name</li> <li>branch: Git branch (default \"main\")</li> <li>path: Path relative to the repository root; when specified, the cluster sync will be scoped to this path</li> <li>personal: If set, the owner is assumed to be a repo user</li> <li>components-extra: Additional controllers to install</li> </ul> <p>At this point your Flux management cluster should be running. Take a look at the repository you created earlier.</p>"},{"location":"enterprise/install-enterprise/#apply-your-entitlements-secret-to-your-cluster","title":"Apply Your Entitlements Secret to Your Cluster","text":"<p>As noted above, you receive your entitlements secret by contacting sales@weave.works. Use this command to apply it to the cluster:</p> <pre><code>kubectl apply -f entitlements.yaml\n</code></pre>"},{"location":"enterprise/install-enterprise/#set-up-authentication-and-rbac","title":"Set up Authentication and RBAC","text":""},{"location":"enterprise/install-enterprise/#securing-access-to-the-dashboard","title":"Securing Access to the Dashboard","text":"<p>There are two supported methods for logging in to the dashboard, that work with standard Kubernetes RBAC: - Login via an OIDC provider: recommended, as this will allow you to control permissions for existing users and groups that have already been configured to use OIDC. OIDC decouples the need to manage user lists from the application, allowing it to be managed via a central system designed for that purpose (i.e. the OIDC provider). OIDC also enables the creation of groups\u2014either via your provider's own systems or by using a connector like Dex. - Login via a cluster user account: which is insecure, and which we only recommend for local and development environments or if you need to activate emergency access to a damaged cluster. However, it is an option if an OIDC provider is not available.</p> <p>You may decide to give your engineering teams access to the WGE dashboard so they can view and manage their workloads. In this case, you will want to secure dashboard access and restrict who can interact with it. Weave GitOps Enterprise integrates with your OIDC provider and uses standard Kubernetes RBAC to give you fine-grained control of the dashboard users' permissions.</p> <p>OIDC extends the OAuth2 authorization protocol by including an additional field (ID Token) that contains information (claims) about a user's identity. After a user successfully authenticates with the OIDC provider, Weave GitOps Enterprise uses this information to impersonate the user in any calls to the Kubernetes API. This allows cluster administrators to use RBAC rules to control access to the cluster and the dashboard.</p> Login via an OIDC providerConfiguring OIDC with Dex and GitHubLogin via a cluster user account <p>To login via your OIDC provider, create a Kubernetes secret to store the OIDC configuration. This configuration consists of the following parameters:</p> Parameter Description Default <code>issuerURL</code> The URL of the issuer; typically, the discovery URL without a path <code>clientID</code> The client ID set up for Weave GitOps in the issuer <code>clientSecret</code> The client secret set up for Weave GitOps in the issuer <code>redirectURL</code> The redirect URL set up for Weave GitOps in the issuer\u2014typically the dashboard URL, followed by <code>/oauth2/callback</code> <code>tokenDuration</code> The time duration that the ID Token will remain valid after successful authentication \"1h0m0s\" <code>tokenDuration</code> The time duration that the ID Token will remain valid after successful authentication \"1h0m0s\" <code>oidcUsernamePrefix</code> The prefix added to users when impersonating API calls to the Kubernetes API, equivalent to --oidc-username-prefix <code>oidcGroupsPrefix</code> The prefix added to groups when impersonating API calls to the Kubernetes API, equivalent to --oidc-groups-prefix <p>Ensure that your OIDC provider has been set up with a client ID/secret and the dashboard's redirect URL.</p> <p>Create a secret named <code>oidc-auth</code> in the <code>flux-system</code> namespace with these parameters set:</p> <pre><code>kubectl create secret generic oidc-auth \\\n--namespace flux-system \\\n--from-literal=issuerURL=&lt;oidc-issuer-url&gt; \\\n--from-literal=clientID=&lt;client-id&gt; \\\n--from-literal=clientSecret=&lt;client-secret&gt; \\\n--from-literal=redirectURL=&lt;redirect-url&gt; \\\n--from-literal=tokenDuration=&lt;token-duration&gt;\n</code></pre> <p>Once the HTTP server starts, unauthenticated users will have to click 'Login With OIDC Provider' to log in or use the cluster account (if configured). Upon successful authentication, the users' identities will be impersonated in any calls made to the Kubernetes API, as part of any action they take in the dashboard. By default the Helm chart will configure RBAC correctly, but we recommend reading the service account and user permissions pages to understand which actions are needed for Weave GitOps to function correctly.</p> <p>Important</p> <p>This is an insecure method of securing your dashboard which we only recommend for local and development environments, or if you need to activate emergency access to a damaged cluster.</p> <p>Note also that this mechanism only exists for a single user. You will not be able to create multiple users. Weave GitOps does not provide its own authentication mechanism. For secure and fully-featured authentication we strongly recommend using an OIDC provider, as described in the other tab.</p>"},{"location":"enterprise/install-enterprise/#customization","title":"Customization","text":"<p>For some OIDC configurations, you may need to customise the requested scopes or claims.</p> <p>The <code>oidcUsernamePrefix</code> and <code>oidcGroupsPrefix</code> work in the same way as the Kubernetes kube-apiserver command-line options, if you need them for Kubernetes, you will likely need them here.</p>"},{"location":"enterprise/install-enterprise/#scopes","title":"Scopes","text":"<p>By default, the following scopes are requested: \"openid\",\"offline_access\",\"email\",\"groups\".</p> <p>The \"openid\" scope is mandatory for OpenID auth and will be added if not provided. The \"email\" and \"groups\" scopes are commonly used as unique identifiers in organisations.</p> <p>\"offline_access\" allows us to refresh OIDC tokens to keep login sessions alive for as long as a refresh token is valid. You can, however, change the defaults. <pre><code>kubectl create secret generic oidc-auth \\\n--namespace flux-system \\\n--from-literal=issuerURL=&lt;oidc-issuer-url&gt; \\\n--from-literal=clientID=&lt;client-id&gt; \\\n--from-literal=clientSecret=&lt;client-secret&gt; \\\n--from-literal=redirectURL=&lt;redirect-url&gt; \\\n--from-literal=tokenDuration=&lt;token-duration&gt; \\\n--from-literal=customScopes=custom,scopes\n</code></pre> The format for the <code>customScopes</code> key is a comma-separated list of scopes to request. In this case, \"custom\", \"scopes\", and \"openid\" would be requested.</p>"},{"location":"enterprise/install-enterprise/#claims","title":"Claims","text":"<p>By default, the following claims are parsed from the OpenID ID Token \"email\" and \"groups\". These are presented as the <code>user</code> and <code>groups</code> when WGE communicates with your Kubernetes API server.</p> <p>This is equivalent to configuring your <code>kube-apiserver</code> with <code>--oidc-username-claim=email --oidc-groups-claim=groups</code>.</p> <p>Again, you can configure these from the <code>oidc-auth</code> <code>Secret</code>.</p> <p><pre><code>kubectl create secret generic oidc-auth \\\n--namespace flux-system \\\n--from-literal=issuerURL=&lt;oidc-issuer-url&gt; \\\n--from-literal=clientID=&lt;client-id&gt; \\\n--from-literal=clientSecret=&lt;client-secret&gt; \\\n--from-literal=redirectURL=&lt;redirect-url&gt; \\\n--from-literal=tokenDuration=&lt;token-duration&gt; \\\n--from-literal=claimUsername=sub \\\n--from-literal=claimGroups=groups\n</code></pre> There are two separate configuration keys. You can override them separately. They should match your <code>kube-apiserver</code> configuration.</p>"},{"location":"enterprise/install-enterprise/#configuring-oidc-with-dex-and-github","title":"Configuring OIDC with Dex and GitHub","text":"<p>This example uses Dex and its GitHub connector to show you how to log in to the Weave GitOps dashboard by authenticating with your GitHub account. It assumes you have already installed Weave GitOps on a Kubernetes cluster, per the instructions above, and have also enabled TLS.</p> <p>Dex is an identity service that uses OpenID Connect to drive authentication for other apps. There are other solutions for identity and access management, such as Keycloak.</p> <p>Create a namespace where you will install Dex:</p> <pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\nname: dex\n</code></pre> <p>Get a GitHub ClientID and Client secret by creating a new OAuth application.</p> <p></p> <pre><code>kubectl create secret generic github-client \\\n--namespace=dex \\\n--from-literal=client-id=${GITHUB_CLIENT_ID} \\\n--from-literal=client-secret=${GITHUB_CLIENT_SECRET}\n</code></pre>"},{"location":"enterprise/install-enterprise/#deploy-dex","title":"Deploy Dex","text":"<p>Use <code>HelmRepository</code> and <code>HelmRelease</code> objects to let Flux deploy everything.</p> Expand to see resource manifests <pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: HelmRepository\nmetadata:\nname: dex\nnamespace: dex\nspec:\ninterval: 1m\nurl: https://charts.dexidp.io\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: dex\nnamespace: dex\nspec:\ninterval: 5m\nchart:\nspec:\nchart: dex\nversion: 0.15.3\nsourceRef:\nkind: HelmRepository\nname: dex\nnamespace: dex\ninterval: 1m\nvalues:\nenvVars:\n- name: GITHUB_CLIENT_ID\nvalueFrom:\nsecretKeyRef:\nname: github-client\nkey: client-id\n- name: GITHUB_CLIENT_SECRET\nvalueFrom:\nsecretKeyRef:\nname: github-client\nkey: client-secret\nconfig:\n# Set it to a valid URL\nissuer: https://dex.dev.example.tld\n\n# See https://dexidp.io/docs/storage/ for more options\nstorage:\ntype: memory\n\nstaticClients:\n- name: 'Weave GitOps'\nid: weave-gitops\nsecret: AiAImuXKhoI5ApvKWF988txjZ+6rG3S7o6X5En\nredirectURIs:\n- 'https://localhost:9001/oauth2/callback'\n- 'https://0.0.0.0:9001/oauth2/callback'\n- 'http://0.0.0.0:9001/oauth2/callback'\n- 'http://localhost:4567/oauth2/callback'\n- 'https://localhost:4567/oauth2/callback'\n- 'http://localhost:3000/oauth2/callback'\n\nconnectors:\n- type: github\nid: github\nname: GitHub\nconfig:\nclientID: $GITHUB_CLIENT_ID\nclientSecret: $GITHUB_CLIENT_SECRET\nredirectURI: https://dex.dev.example.tld/callback\norgs:\n- name: weaveworks\nteams:\n- team-a\n- team-b\n- QA\n- name: ww-test-org\ningress:\nenabled: true\nclassName: nginx\nannotations:\ncert-manager.io/cluster-issuer: letsencrypt-prod\nhosts:\n- host: dex.dev.example.tld\npaths:\n- path: /\npathType: ImplementationSpecific\ntls:\n- hosts:\n- dex.dev.example.tld\nsecretName: dex-dev-example-tld\n</code></pre> <p>An important part of the configuration is the <code>orgs</code> field on the GitHub connector, which allows you to define groups within a GitHub organisation: </p> <pre><code>orgs:\n- name: weaveworks\nteams:\n- team-a\n- team-b\n- QA\n</code></pre> <p>In this example, the GitHub organisation is <code>weaveworks</code> and all members of the <code>team-a</code>, <code>team-b</code>, and <code>QA</code> teams can authenticate. Group membership is added to the user.</p> <p>Based on these groups, we can bind roles to groups:</p> Expand to see group role bindings <pre><code>---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: wego-test-user-read-resources\nnamespace: flux-system\nsubjects:\n- kind: Group\nname: weaveworks:QA\nnamespace: flux-system\nroleRef:\nkind: Role\nname: wego-admin-role\napiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: wego-admin-role\nnamespace: flux-system\nrules:\n- apiGroups: [\"\"]\nresources: [\"secrets\", \"pods\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"apps\"]\nresources: [ \"deployments\", \"replicasets\"]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"kustomize.toolkit.fluxcd.io\"]\nresources: [ \"kustomizations\" ]\nverbs: [ \"get\", \"list\", \"patch\" ]\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\", \"patch\" ]\n- apiGroups: [\"source.toolkit.fluxcd.io\"]\nresources: [\"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\"]\nverbs: [\"get\", \"list\", \"patch\"]\n- apiGroups: [\"\"]\nresources: [\"events\"]\nverbs: [\"get\", \"watch\", \"list\"]\n</code></pre> <p>In the same way, we can bind cluster roles to a group:</p> Expand to see group cluster role bindings <pre><code>---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: weaveworks:team-a\nsubjects:\n- kind: Group\nname: weaveworks:team-a\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: ClusterRole\nname: cluster-admin\napiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"enterprise/install-enterprise/#set-up-a-static-user","title":"Set up a Static User","text":"<p>For a static user, add <code>staticPasswords</code> to the <code>config</code>:</p> <pre><code>spec:\nvalues:\nconfig:\nstaticPasswords:\n- email: \"admin@example.tld\"\nhash: \"$2a$10$2b2cU8CPhOTaGrs1HRQuAueS7JTT5ZHsHSzYiFPm1leZck7Mc8T4W\"\nusername: \"admin\"\nuserID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\n</code></pre> <p>Generate a static user password via the <code>gitops</code> CLI:</p> <pre><code>PASSWORD=\"&lt;your password&gt;\"\necho -n $PASSWORD | gitops get bcrypt-hash\n$2a$10$OS5NJmPNEb13UgTOSKnMxOWlmS7mlxX77hv4yAiISvZ71Dc7IuN3q\n</code></pre>"},{"location":"enterprise/install-enterprise/#oidc-login","title":"OIDC Login","text":"<p>Using the \"Login with OIDC Provider\" button:</p> <p></p> <p>We have to authorize the GitHub OAuth application:</p> <p></p> <p>After that, grant access to Dex:</p> <p></p> <p>Now we are logged in with our GitHub user and can see all of the resources we have access to:</p> <p></p>"},{"location":"enterprise/install-enterprise/#configuring-the-emergency-user","title":"Configuring the Emergency User","text":"<p>Before you log in via the emergency user account, you need to generate a bcrypt hash for your chosen password and store it as a secret in Kubernetes. There are several different ways to generate a bcrypt hash. This guide uses <code>gitops get bcrypt-hash</code> from our CLI.</p> <p>Generate the password by running:</p> <pre><code>PASSWORD=\"&lt;your password&gt;\"\necho -n $PASSWORD | gitops get bcrypt-hash\n$2a$10$OS5NJmPNEb13UgTOSKnMxOWlmS7mlxX77hv4yAiISvZ71Dc7IuN3q\n</code></pre> <p>Now create a Kubernetes secret to store your chosen username and the password hash:</p> <pre><code>kubectl create secret generic cluster-user-auth \\\n--namespace flux-system \\\n--from-literal=username=wego-admin \\\n--from-literal=password='$2a$10$OS5NJmPNEb13UTOSKngMxOWlmS7mlxX77hv4yAiISvZ71Dc7IuN3q'\n</code></pre> <p>You should now be able to login via the cluster user account using your chosen username and password.</p>"},{"location":"enterprise/install-enterprise/#updating-the-emergency-user","title":"Updating the Emergency User","text":"<p>To change either the username or the password, recreate the <code>cluster-user-auth</code> with the new details.</p> <p>Only one emergency user can be created this way. To add more users, enable an OIDC provider.</p>"},{"location":"enterprise/install-enterprise/#user-permissions","title":"User Permissions","text":"<p>By default, both a ClusterRole and Role are generated for the emergency user. Both have the same permissions, with the former being optional and the latter being bound to the <code>flux-system</code> namespace (where Flux stores its resources by default). The default set of rules are configured like this:</p> <pre><code>rules:\n# Flux Resources\n- apiGroups: [\"source.toolkit.fluxcd.io\"]\nresources: [ \"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [\"kustomize.toolkit.fluxcd.io\"]\nresources: [ \"kustomizations\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [ \"notification.toolkit.fluxcd.io\" ]\nresources: [ \"providers\", \"alerts\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [\"infra.contrib.fluxcd.io\"]\nresources: [\"terraforms\"]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n# Read access for all other Kubernetes objects\n- apiGroups: [\"*\"]\nresources: [\"*\"]\nverbs: [ \"get\", \"list\", \"watch\" ]\n</code></pre> <p>These permissions give the emergency user Administrator-level powers. We do not advise leaving it active on production systems.</p> <p>If required, the permissions can be expanded with the <code>rbac.additionalRules</code> field in the Helm Chart. Follow the instructions in the next section in order to configure RBAC correctly.</p> Note <p>To remove the emergency user as a login method, set the following values in the Helm Chart:</p> <pre><code>#\nadminUser:\ncreate: false\n#\nadditionalArgs:\n- --auth-methods=oidc\n#\n</code></pre> <p>If you are disabling an already existing emergency user, you will need to manually delete the Kubernetes Secret and any User Roles that were created on the cluster.</p>"},{"location":"enterprise/install-enterprise/#gitops-dashboard-service-account-permissions","title":"GitOps Dashboard Service Account Permissions","text":"<p>This section covers the service account permissions for the Weave GitOps application, which the WGE UI requires to work. The default permissions will generate a cluster role that includes the permissions:</p> <pre><code>rules:\n- apiGroups: [\"\"]\nresources:  [\"users\", \"groups\"] verbs: [ \"impersonate\" ]\n- apiGroups: [\"\"]\nresources: [ \"secrets\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [ \"\" ]\nresources: [ \"namespaces\" ]\nverbs: [ \"get\", \"list\" ]\n</code></pre> <p>These allow the pod to do three things: - Impersonate the user and operate in the cluster as them - Read the available namespaces; this is required to understand users' permissions - Read the <code>cluster-user-auth</code> and <code>oidc-auth</code> secrets, the default secrets   to store the emergency cluster user account and OIDC configuration (see   securing access to the dashboard)</p>"},{"location":"enterprise/install-enterprise/#impersonation","title":"Impersonation","text":"<p>The primary way Weave GitOps queries the Kube API is via <code>impersonation</code>. The permissions granted to users and groups that Weave GitOps can impersonate will determine the scope of actions that WGE can take within your cluster. </p> <p>The application, not the cluster, authenticates the user, either via the emergency cluster user credentials or OIDC. Then it makes Kube API calls on the user's behalf. This is equivalent to making a kubectl call like:</p> <pre><code>$ kubectl get deployments --as aisha@example.com\n</code></pre> <p>Assuming the user <code>aisha@example.com</code> has permissions to get deployments within the cluster, this will return those deployments. The same occurs  within the application, so properly configuring application permissions is very important. Without proper restrictions the application can impersonate very powerful <code>users</code> or <code>groups</code>. For example, the <code>system:masters</code> is a group generally bound to the <code>cluster-admin</code> role, which can do anything.</p>"},{"location":"enterprise/install-enterprise/#get-namespaces","title":"Get Namespaces","text":"<p>The application itself uses get namespace permissions to pre-cache the list of available namespaces. As the user accesses resources their permissions within various namespaces is also cached to speed up future operations.</p>"},{"location":"enterprise/install-enterprise/#reading-the-cluster-user-auth-and-oidc-auth-secrets","title":"Reading the <code>cluster-user-auth</code> and <code>oidc-auth</code> Secrets","text":"<p>The <code>cluster-user-auth</code> and <code>oidc-auth</code> secrets provide information for authenticating to the application. The former holds the username and bcrypt-hashed password for the emergency user, and the latter holds OIDC configuration.</p> <p>The application needs to be able to access these secrets in order to authenticate users.</p>"},{"location":"enterprise/install-enterprise/#user-permissions_1","title":"User Permissions","text":"<p>This section discusses the Kubernetes permissions needed by Weave GitOps application users and groups. At a minimum, a User should be bound to a Role in the <code>flux-system</code> namespace\u2014which is where Flux stores its resources by default\u2014with the following permissions:</p> <pre><code>rules:\n# Flux Resources\n- apiGroups: [\"source.toolkit.fluxcd.io\"]\nresources: [ \"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [\"kustomize.toolkit.fluxcd.io\"]\nresources: [ \"kustomizations\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [ \"notification.toolkit.fluxcd.io\" ]\nresources: [ \"providers\", \"alerts\" ]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n- apiGroups: [\"infra.contrib.fluxcd.io\"]\nresources: [\"terraforms\"]\nverbs: [ \"get\", \"list\", \"watch\", \"patch\" ]\n\n# Read access for all other Kubernetes objects\n- apiGroups: [\"*\"]\nresources: [\"*\"]\nverbs: [ \"get\", \"list\", \"watch\" ]\n</code></pre> <p>For a wider scope, the User can be bound to a ClusterRole with the same set.</p> <p>On top of this you can add other permissions to view WGE resources like <code>GitOpsSets</code> and <code>Templates</code>.</p>"},{"location":"enterprise/install-enterprise/#flux-resources","title":"Flux Resources","text":"<p>The following table lists resources that Flux works with directly.</p> API Group Resources Permissions kustomize.toolkit.fluxcd.io kustomizations get, list, patch helm.toolkit.fluxcd.io Helm Releases get, list, patch source.toolkit.fluxcd.io buckets, Helm charts, Git repositories, Helm repositories, OCI repositories get, list, patch notification.toolkit.fluxcd.io providers, alerts get, list infra.contrib.fluxcd.io Terraform get, list, patch <p>Weave GitOps needs to be able to query the CRDs that Flux uses before it can accurately display Flux state. The <code>get</code> and <code>list</code> permissions facilitate this.</p> <p>The <code>patch</code> permissions are used for two features: to suspend and resume reconciliation of a resource by modifying the 'spec' of a resource, and to force reconciliation of a resource by modifying resource annotations. These features work in the same way that <code>flux suspend</code>, <code>flux resume</code>, and <code>flux reconcile</code> does on the CLI.</p>"},{"location":"enterprise/install-enterprise/#resources-managed-via-flux","title":"Resources Managed via Flux","text":"API Group Resources Permissions \"\" configmaps, secrets, pods, services, persistent volumes, persistent volume claims get, list, watch apps deployments, replica sets, stateful sets get, list, watch batch jobs, cron jobs get, list, watch autoscaling horizontal pod autoscalers get, list, watch rbac.authorization.k8s.io roles, cluster roles, rolebindings, cluster role bindings get, list, watch networking.k8s.io ingresses get, list, watch <p>Weave GitOps reads basic resources so that it can monitor the effect that Flux has on what's running.</p> <p>Reading <code>secrets</code> enables Weave GitOps to monitor the state of Helm releases as that's where it stores the state by default. For clarity this these are the Helm release objects not the Flux HelmRelease resource (which are dealt with by the earlier section).</p>"},{"location":"enterprise/install-enterprise/#feedback-from-flux","title":"Feedback from Flux","text":"<p>Flux communicates the status of itself primarily via events. These events will show when reconciliations start and stop, whether they're successful, and information as to why they're not.</p>"},{"location":"enterprise/install-enterprise/#login-ui","title":"Login UI","text":"<p>The label of the OIDC button on the login screen is configurable via a feature flag environment variable. This can give your users a more familiar experience when logging in.</p> <p>Adjust the configuration in the Helm <code>values.yaml</code> file or the <code>spec.values</code> section of the Weave GitOps <code>HelmRelease</code> resource:</p> <pre><code>extraEnvVars:\n- name: WEAVE_GITOPS_FEATURE_OIDC_BUTTON_LABEL\nvalue: \"Login with ACME\"\n</code></pre>"},{"location":"enterprise/install-enterprise/#recommended-rbac-configuration","title":"Recommended RBAC Configuration","text":"<p>This section is purposefully vague as we intend to give a broad idea of how to implement such a system. The specifics will dependent on your circumstances and goals.</p> <p>Our general recommendation is to use OIDC and a small number of groups that Weave GitOps can impersonate.</p> <p>Configuring Weave GitOps to impersonate Kubernetes groups rather than users has the following benefits: - A user's permissions for impersonation by Weave GitOps can be separate from   any other permissions that they may or may not have within the cluster. - Users do not have to be individually managed within the cluster and can have   their permissions managed together.</p>"},{"location":"enterprise/install-enterprise/#example-setup","title":"Example Setup","text":"<p>Assume that your company has the following people in OIDC: - Aisha, a cluster admin, who should have full admin access to Weave GitOps - Brian, lead of Team-A, who should have admin permissions to their team's   namespace in Weave GitOps and read-only otherwise - June and Jo, developers in Team-A who should have read-only access to Weave GitOps</p> <p>You can then create three groups:</p> <ul> <li><code>wego-admin</code></li> <li>Bound to the <code>ClusterRole</code>, created by Helm, <code>wego-admin-cluster-role</code></li> <li>Aisha is the only member</li> <li><code>wego-team-a-admin</code></li> <li>Bound to a <code>Role</code>, using the same permissions as <code>wego-admin-role</code>, created     in Team-A's namespace</li> <li>Brian and Aisha are members</li> <li><code>wego-readonly</code></li> <li>Bound to a <code>ClusterRole</code> that matches <code>wego-admin-cluster-role</code> but with     no <code>patch</code> permissions.</li> <li>Aisha, Brian, June and Jo are all members</li> </ul> <p>Using OIDC for cluster and Weave GitOps Authentication</p> <p>If the same OIDC provider is used to authenticate a user with the cluster itself (e.g. for use with <code>kubectl</code>) and to Weave GitOps then, depending on OIDC configuration, they may end up with the super-set of their permissions from Weave GitOps and any other permissions granted to them.</p> <p>This can lead to unintended consequences, like viewing <code>secrets</code>. To avoid this, OIDC providers will often let you configure which groups are returned to which clients. The Weave GitOps groups should not be returned to the cluster client (and vice versa).</p>"},{"location":"enterprise/install-enterprise/#code","title":"Code","text":"<p>The yaml to configure these permissions would look roughly like:</p> Expand to see example RBAC <pre><code>    # Admin cluster role\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: wego-admin-cluster-role\nrules:\n- apiGroups: [\"\"]\nresources: [\"secrets\", \"pods\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"apps\"]\nresources: [ \"deployments\", \"replicasets\"]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"kustomize.toolkit.fluxcd.io\"]\nresources: [ \"kustomizations\" ]\nverbs: [ \"get\", \"list\", \"patch\" ]\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\", \"patch\" ]\n- apiGroups: [\"source.toolkit.fluxcd.io\"]\nresources: [ \"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\" ]\nverbs: [ \"get\", \"list\", \"patch\" ]\n- apiGroups: [\"\"]\nresources: [\"events\"]\nverbs: [\"get\", \"watch\", \"list\"]\n---\n# Read-only cluster role\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: wego-readonly-role\nrules:\n# All the 'patch' permissions have been removed\n- apiGroups: [\"\"]\nresources: [\"secrets\", \"pods\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"apps\"]\nresources: [ \"deployments\", \"replicasets\"]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"kustomize.toolkit.fluxcd.io\"]\nresources: [ \"kustomizations\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"source.toolkit.fluxcd.io\"]\nresources: [ \"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [\"\"]\nresources: [\"events\"]\nverbs: [\"get\", \"watch\", \"list\"]\n---\n# Bind the cluster admin role to the wego-admin group\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: wego-cluster-admin\nsubjects:\n- kind: Group\nname: wego-admin # only Aisha is a member\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: ClusterRole\nname: wego-admin-cluster-role\napiGroup: rbac.authorization.k8s.io\n---\n# Bind the admin role in the team-a namespace for the wego-team-a-admin group\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: wego-team-a-admin-role\nnamespace: team-a\nsubjects:\n- kind: Group\nname: wego-team-a-admin # Aisha &amp; Brian are members\napiGroup: rbac.authorization.k8s.io\nroleRef:\n# Use the cluster role to set rules, just bind them in the team-a namespace\nkind: ClusterRole\nname: wego-admin-role\napiGroup: rbac.authorization.k8s.io\n---\n# Bind the read-only role to the read-only group\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: wego-readonly-role\nsubjects:\n- kind: Group\nname: wego-readonly # Everyone is a member\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: ClusterRole\nname: wego-readonly-role\napiGroup: rbac.authorization.k8s.io\n---\n</code></pre>"},{"location":"enterprise/install-enterprise/#configure-access-for-writing-to-git-from-the-weave-gitops-enterprise-ui","title":"Configure Access for Writing to Git from the Weave GitOps Enterprise UI","text":"<p>Here we provide guidance for GitHub, GitLab, BitBucket Server, and Azure DevOps.</p> GitHubBitBucket ServerAzure DevOps <p>GitHub requires no additional configuration for OAuth git access  </p> <p>Create a GitLab OAuth application that will request <code>api</code> permissions to create pull requests on your behalf.</p> <p>Follow the GitLab docs.</p> <p>The application should have at least these scopes:</p> <ul> <li><code>api</code></li> <li><code>openid</code></li> <li><code>email</code></li> <li><code>profile</code></li> </ul> <p>Add callback URLs to the application for each address the UI will be exposed on, e.g.:</p> <ul> <li><code>https://localhost:8000/oauth/gitlab</code> for port-forwarding and testing</li> <li><code>https://git.example.com/oauth/gitlab</code> for production use</li> </ul> <p>Save your application, taking note of the Client ID and Client Secret. Save them into the <code>git-provider-credentials</code> secret, along with:</p> <ul> <li><code>GIT_HOST_TYPES</code> to tell WGE that the host is gitlab</li> <li><code>GITLAB_HOSTNAME</code> where the OAuth app is hosted</li> </ul> <p>Replace values in this snippet and run:</p> <pre><code>kubectl create secret generic git-provider-credentials --namespace=flux-system \\\n--from-literal=\"GITLAB_CLIENT_ID=13457\" \\\n--from-literal=\"GITLAB_CLIENT_SECRET=24680\" \\\n--from-literal=\"GITLAB_HOSTNAME=git.example.com\" \\\n--from-literal=\"GIT_HOST_TYPES=git.example.com=gitlab\"\n</code></pre> <p>Create a new incoming application link from the BitBucket administration dashboard. You will be asked to enter a unique name and the redirect URL for the external application. The redirect URL should be set to <code>&lt;WGE dashboard URL&gt;/oauth/bitbucketserver</code>. You will also need to select permissions for the application. The minimum set of permissions needed for WGE to create pull requests on behalf of users is <code>Repositories - Write</code>. An example of configuring these settings is shown below.</p> <p> Configuring a new incoming application link </p> <p>Save your application and take note of the Client ID and Client Secret. Save them into the <code>git-provider-credentials</code> secret, along with:</p> <ul> <li><code>GIT_HOST_TYPES</code> to tell WGE that the host is bitbucket-server</li> <li><code>BITBUCKET_SERVER_HOSTNAME</code> where the OAuth app is hosted</li> </ul> <p>Replace values in this snippet and run:</p> <pre><code>kubectl create secret generic git-provider-credentials --namespace=flux-system \\\n--from-literal=\"BITBUCKET_SERVER_CLIENT_ID=13457\" \\\n--from-literal=\"BITBUCKET_SERVER_CLIENT_SECRET=24680\" \\\n--from-literal=\"BITBUCKET_SERVER_HOSTNAME=git.example.com\" \\\n--from-literal=\"GIT_HOST_TYPES=git.example.com=bitbucket-server\"\n</code></pre> <p>If the secret is already present, use the following command to update it using your default editor:</p> <pre><code>kubectl edit secret generic git-provider-credentials --namespace=flux-system\n</code></pre> <p>Info</p> <p>If BitBucket Server is running on the default port (7990), make sure you include the port number in the values of the secret. For example: <code>GIT_HOST_TYPES=git.example.com:7990=bitbucket-server</code></p> <p>Navigate to VisualStudio and register a new application, as explained in the docs. Set the authorization callback URL and select which scopes to grant. Set the callback URL to <code>&lt;WGE dashboard URL&gt;/oauth/azuredevops</code>. </p> <p>Select the <code>Code (read and write)</code> scope from the list. This is necessary so that WGE can create pull requests on behalf of users. An example of configuring these settings is shown below.</p> <p> Creating a new application </p> <p>After creating your application, you will be presented with the application settings. Take note of the <code>App ID</code> and <code>Client Secret</code> values\u2014you will use them to configure WGE.</p> <p> Application settings </p> <p>In your cluster, create a secret named <code>git-provider-credentials</code> that contains the <code>App ID</code> and <code>Client Secret</code> values from the newly created application.</p> <p>Replace values in this snippet and run:</p> <pre><code>kubectl create secret generic git-provider-credentials --namespace=flux-system \\\n--from-literal=\"AZURE_DEVOPS_CLIENT_ID=&lt;App ID value&gt;\" \\\n--from-literal=\"AZURE_DEVOPS_CLIENT_SECRET=&lt;Client Secret value&gt;\"\n</code></pre> <p>WGE is now configured to ask users for authorization the next time a pull request must be created as part of using a template. Note that each user can view and manage which applications they have authorized by navigating to https://app.vsaex.visualstudio.com/me.</p>"},{"location":"enterprise/install-enterprise/#tls-configuration","title":"TLS Configuration","text":"<p>By default, the WGE UI pod will listen on port <code>8000</code> with TLS enabled. WGE will generate and use a self-signed certificate for this purpose.</p> <p>It can then be accessed via port-forwarding:</p> <p><code>kubectl port-forward --namespace flux-system svc/clusters-service 8000:8000</code></p> <p>If you're using an ingress controller to terminate TLS you can disable it in the Helm release:</p> <pre><code>  values:\ntls:\nenabled: false\n</code></pre> <p>Other ingress conguration changes can be made via the ingress configuration</p> <pre><code>  values:\ningress:\nenabled: true\n... other parameters specific to the ingress type ...\n</code></pre>"},{"location":"enterprise/install-enterprise/#configure-helm-chart-and-commit","title":"Configure Helm Chart and Commit","text":"<p>We deploy WGE via a Helm chart. We'll save and adapt the below template before committing it in Git to a Flux-reconciled path.</p> <p>Clone the newly created repo locally. We're gonna add some things!</p> <pre><code>git clone git@&lt;provider&gt;:&lt;username&gt;/fleet-infra\ncd fleet-infra\n</code></pre> <p>Download the helm-release to <code>clusters/management/weave-gitops-enterprise.yaml</code>.</p> <p>import ExampleWGE from \"../assets/example-enterprise-helm.yaml\"; import ExampleWGEContent from \"!!raw-loader!../assets/example-enterprise-helm.yaml\";</p> Expand to see file contents <p></p> <p>Once you have copied the above file, open and adjust the following configuration options:</p>"},{"location":"enterprise/install-enterprise/#valuesconfigcapirepositoryurl","title":"<code>values.config.capi.repositoryURL</code>","text":"<p>Ensure this has been set to your repository URL.</p>"},{"location":"enterprise/install-enterprise/#valuesconfigcapirepositorypath","title":"<code>values.config.capi.repositoryPath</code>","text":"<p>By default, WGE will create new clusters in the <code>clusters/management/clusters</code> path. You can configure it with <code>values.config.capi.repositoryPath</code>. You might what to change it to <code>clusters/my-cluster/cluster</code> if you configured Flux to reconcile <code>./clusters/my-cluster</code> instead.</p>"},{"location":"enterprise/install-enterprise/#valuesconfigcapirepositoryclusterspath","title":"<code>values.config.capi.repositoryClustersPath</code>","text":"<p>The other important path to configure is where you'll store applications and workloads run on the new cluster. By default this is <code>./clusters</code>. When a new cluster is specified, any selected profiles will be written to <code>./clusters/{.namespace}/{.clusterName}/profiles.yaml</code>. When the new cluster is bootstrapped, Flux will sync the <code>./clusters/{.namespace}/{.clusterName}</code> path.</p>"},{"location":"enterprise/install-enterprise/#configure-your-password","title":"Configure Your Password","text":"<p>To login to the WGE UI, generate a bcrypt hash for your chosen password and store it as a secret in the Kubernetes cluster. There are several different ways to generate a bcrypt hash. Here, we'll use <code>gitops get bcrypt-hash</code> from our CLI.</p> <pre><code>PASSWORD=\"&lt;Make up and insert a brand-new password here&gt;\"\necho -n $PASSWORD | gitops get bcrypt-hash | kubectl create secret generic cluster-user-auth -n flux-system --from-literal=username=wego-admin --from-file=password=/dev/stdin\n</code></pre> <p>A validation to know it\u2019s working:</p> <pre><code>kubectl get secret -n flux-system cluster-user-auth\n</code></pre>"},{"location":"enterprise/install-enterprise/#optional-install-policy-agent","title":"(Optional) Install Policy Agent","text":"<p>Policy agent comes packaged with the WGE chart. To install it, set the following values:</p> <ul> <li><code>values.policy-agent.enabled</code>: set to true to install the agent with WGE</li> <li><code>values.policy-agent.config.accountId</code>: organization name, used as identifier</li> <li><code>values.policy-agent.config.clusterId</code>: unique identifier for the cluster</li> </ul> <p>Commit and push all the files</p> <pre><code>git add clusters/management/weave-gitops-enterprise.yaml\ngit commit -m \"Deploy Weave GitOps Enterprise\"\ngit push\n</code></pre> <p>Flux will reconcile the helm-release and WGE will be deployed into the cluster. You can check the <code>flux-system</code> namespace to verify all pods are running.</p>"},{"location":"enterprise/install-enterprise/#next-steps","title":"Next Steps","text":"<p>Here are a couple of options for you to take your next steps with WGE. Explore one option or all of them, in no particular order.</p> <ul> <li>Cluster Management: We'll show you how to join WGE to a cluster and install an application on that cluster without using Cluster API. But if you prefer using Cluster API, our docs cover that too.</li> <li>Install the Terraform Controller to reconcile your Terraform resources in a GitOps way. With Flux and the TF Controller, WGE makes it easy to add Terraform templates to your clusters and continuously reconcile any changes made to the Terraform source manifest.</li> <li>Install Policy agent, which comes packaged with the WGE chart.</li> </ul>"},{"location":"enterprise/join-cluster-azure-flux/","title":"Joining a Cluster with Azure Flux ENTERPRISE","text":""},{"location":"enterprise/join-cluster-azure-flux/#prerequisites","title":"Prerequisites","text":"<p>See also our guide to installing Weave GitOps Enterprise on Azure: - An Azure cluster deployed with either the Azure Portal or Azure CLI tools. - Azure Flux add-on deployed by adding a GitOps configuration, either via the Azure Portal or the CLI tool.</p> <p>Note that this documentation applies to both Azure AKS and Azure ARC clusters.</p>"},{"location":"enterprise/join-cluster-azure-flux/#initial-status","title":"Initial Status","text":"<p>The Azure cluster already has the Azure Flux add-on installed. This differs from CNCF Flux in that there are two additional controllers: - fluxconfig-agent - fluxconfig-controller</p> <p>These controllers have CRDs that define the version of Flux and any Flux Kustomizations that are managed via the Azure CLI.</p> <p>The CRDs are all apiVersion: clusterconfig.azure.com/v1beta1. </p> <p>The Kinds are: - FluxConfig - FluxConfigSyncStatus</p> <p>The FluxConfig Kind configures Flux itself and creates any Kustomizations that refer to a single-source GitRepository. This guide assumes that this process is already completed and that a top-level Kustomization has been configured for the fleet repo cluster directory already set up at <code>clusters/default/CLUSTER_NAME/manifests</code>.</p> <p>The CRDs that this FluxConfig generates are Flux CRDs, as follows: - GitRepositories - Kustomizations</p> <p>These generated resources are viewable through Weave GitOps Enterprise.</p> <p>Weave GitOps itself is deployed by Flux using a HelmRelease that pulls the Helm Chart. It doesn\u2019t need to install Flux, as it is assumed that Flux is already deployed. Therefore it can use the Azure Flux add-on, which poses no conflicts with WGE itself.</p> <p>Incompatibilities exist between the Azure Flux add-on and CNCF Flux. They should not be run at the same time, on the same cluster, due to conflicts in the CRD management. If the Flux bootstrapping process IS run on a cluster with Azure Flux add-on, it will override the Azure Flux add-on with the Flux version used in the bootstrap. Also, it would add Flux manifests to the source Git repository. This would be undesirable.</p> <p>Azure Flux add-on-enabled clusters keep the Azure Flux add-on in place.</p>"},{"location":"enterprise/join-cluster-azure-flux/#joining-a-cluster-to-wge","title":"Joining a Cluster to WGE","text":""},{"location":"enterprise/join-cluster-azure-flux/#setting-up-a-service-account","title":"Setting up a Service Account","text":"<p>To join a cluster, you'll set up a service account with permissions and create a kubeconfig for the service account. This service account does not need cluster admin permissions unless you are bootstrapping Flux into the cluster. The bootstrapping process will either be A) carried out before joining the cluster to WGE; or B) configured specifically for Flux to be bootstrapped into the cluster from WGE.</p> <p>If you already have Flux running, you can create the service account in your fleet repo:</p> <ol> <li>Create a service account file:</li> </ol> Expand to see role manifests <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: wgesa\nnamespace: default\n---\napiVersion: v1\nkind: Secret\ntype: kubernetes.io/service-account-token\nmetadata:\nname: wgesa-secret\nnamespace: default\nannotations:\nkubernetes.io/service-account.name: \"wgesa\"\n</code></pre> <ol> <li>Create a roles file:</li> </ol> Expand to see role manifests <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: impersonate-user-groups\nsubjects:\n- kind: ServiceAccount\nname: wgesa\nnamespace: default\nroleRef:\nkind: ClusterRole\nname: user-groups-impersonator\napiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: user-groups-impersonator\nrules:\n- apiGroups: [\"\"]\nresources: [\"users\", \"groups\"]\nverbs: [\"impersonate\"]\n- apiGroups: [\"\"]\nresources: [\"namespaces\"]\nverbs: [\"get\", \"list\"]\n</code></pre> <ol> <li> <p>Commit to your fleet repo to sync.</p> </li> <li> <p>Create a secret to store the kubeconfig, and a GitopsCluster object in the WGE management cluster that points to the kubeconfig secret. This allows you to connect to the target cluster and read various Kubernetes objects\u2014including the Flux objects, such as:</p> </li> <li>GitRepositories</li> <li>HelmReleases</li> <li>Kustomizations</li> <li>Providers</li> <li>Alerts</li> <li>Receivers</li> </ol> <p>Kubernetes 1.24+ will not create secrets for Service Accounts for you, so you have to add it yourself.</p> <ol> <li> <p>Add a new secret for the service account by adding to the service account yaml file in step 1.</p> </li> <li> <p>Create a kubeconfig secret. We'll use a helper script to generate the kubeconfig, and then save it into <code>static-kubeconfig.sh</code>:</p> Expand to see script static-kubeconfig.sh<pre><code>#!/bin/bash\n\nif [[ -z \"$CLUSTER_NAME\" ]]; then\necho \"Ensure CLUSTER_NAME has been set\"\nexit 1\nfi\n\nif [[ -z \"$CA_CERTIFICATE\" ]]; then\necho \"Ensure CA_CERTIFICATE has been set to the path of the CA certificate\"\nexit 1\nfi\n\nif [[ -z \"$ENDPOINT\" ]]; then\necho \"Ensure ENDPOINT has been set\"\nexit 1\nfi\n\nif [[ -z \"$TOKEN\" ]]; then\necho \"Ensure TOKEN has been set\"\nexit 1\nfi\n\nexport CLUSTER_CA_CERTIFICATE=$(cat \"$CA_CERTIFICATE\" | base64)\n\nenvsubst &lt;&lt;EOF\napiVersion: v1\nkind: Config\nclusters:\n- name: $CLUSTER_NAME\n    cluster:\n        server: https://$ENDPOINT\n        certificate-authority-data: $CLUSTER_CA_CERTIFICATE\nusers:\n- name: $CLUSTER_NAME\n    user:\n        token: $TOKEN\ncontexts:\n- name: $CLUSTER_NAME\n    context:\n        cluster: $CLUSTER_NAME\n        user: $CLUSTER_NAME\ncurrent-context: $CLUSTER_NAME\n\nEOF\n</code></pre> </li> <li> <p>Create a secret for the generated kubeconfig in the WGE management cluster:</p> <pre><code>kubectl create secret generic demo-01-kubeconfig \\\n--from-file=value=./demo-01-kubeconfig\n</code></pre> </li> </ol> <p>You can also take care of this step in WGE's Secrets UI, setting up a a secret in SOPS or ESO.</p> <p>Flux CRDs are compatible with the Azure Flux Configuration CRDs. This means that there are no compatibility issues between WGE and Azure Flux.</p> <ol> <li> <p>Create a GitopsCluster object. It must NOT be bootstrapped. Remove the annotation for bootstrap so it will not deploy Flux.</p> </li> <li> <p>Commit to your fleet repo and sync.</p> </li> <li> <p>Log in to your WGE management cluster to see if the cluster has appeared.</p> </li> </ol>"},{"location":"enterprise/join-cluster-azure-flux/#using-wge-to-deploy-clusters","title":"Using WGE to Deploy Clusters","text":""},{"location":"enterprise/join-cluster-azure-flux/#with-cluster-api","title":"With Cluster API","text":"<p>MSFT maintains CAPZ, the Azure CAPI provider. Currently there is no support for Azure Flux. A CAPI-based cluster will continue to run the Flux bootstrap process on cluster creation when managed by WGE, because there is no Azure Flux option.</p>"},{"location":"enterprise/join-cluster-azure-flux/#with-terraform-provider","title":"With Terraform Provider","text":"<p>WGE uses TF-controller to deploy Terraform resources. For WGE to use the cluster as a target requires A) a resource created in the management cluster and B) a kubeconfig that maps to a service account in the target cluster. The Terraform cluster build typically creates this service account and then outputs to a secret store or local secret so that WGE can use it as a cluster. The Flux bootstrap process can be initiated directly with the Flux Terraform module, which deploys CNCF Flux to the target cluster.</p> <p>Alternatively, you can apply an Azure Policy to provide the Azure Flux add-on. This is an example of how you can use the policy controls. This means you could come across clusters that are deployed with Terraform with the Azure Flux add-on already installed and would not run the Flux bootstrap process.</p> <p>Either way, it is typical that Terraform-deployed clusters do not run the Flux bootstrap process at all, because it is usually already installed.</p>"},{"location":"enterprise/join-cluster-azure-flux/#with-crossplane","title":"With Crossplane","text":"<p>The Azure Flux add-on is supported under Crossplane-deployed Azure clusters. Any clusters deployed with Crossplane that have the Azure Flux add-on enabled would also be added to WGE without running the bootstrap process.</p>"},{"location":"enterprise/releases-enterprise/","title":"Releases ENTERPRISE","text":"<p>Info</p> <p>This page details the changes for Weave GitOps Enterprise and its associated components. For Weave GitOps OSS, please see the release notes on GitHub.</p>"},{"location":"enterprise/releases-enterprise/#v0310","title":"v0.31.0","text":"<p>2023-08-31</p>"},{"location":"enterprise/releases-enterprise/#highlights","title":"Highlights","text":"<ul> <li>ConnectCluster Functionality: Adding the foundation functionality to support connecting leaf clusters via CLI <code>gitops connect cluster</code>.</li> <li>Explorer extends source rendering to include OCIRepository resources to be rendered as regular flux sources. </li> <li>[UI Enhancement] Improved Top-Right Applied Status and Time Text for Applications and Terraform Details pages. </li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions","title":"Dependency versions","text":"<ul> <li>flux &gt;v2.0.0</li> <li>weave-gitops v0.31.2</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.1</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.15.3</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0300","title":"v0.30.0","text":"<p>2023-08-17</p>"},{"location":"enterprise/releases-enterprise/#highlights_1","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#ui","title":"UI","text":"<ul> <li>UI token refreshing! OIDC token refreshing is now handled by the UI, this avoids unintentionally making multiple token requests to the OIDC provider. This old behaviour sometimes triggered rate limiting in OIDC providers, causing errors.</li> <li>UI polish including removing duplicate error messages and more consistency in headers and font sizes.</li> </ul>"},{"location":"enterprise/releases-enterprise/#policy","title":"Policy","text":"<ul> <li>View Policy Audit violations in policies page as a tab</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitopssets","title":"GitOpsSets","text":"<ul> <li>ClusterGenerator - return labels as generic maps, allows for easily using them in params.</li> <li>Handle empty artifacts in directory processing, if a <code>GitRepository</code> or <code>OCIRepository</code> has no artifact, stop generating with an error.</li> <li>Update the ImagePolicy generator to add the image. </li> <li>Ignore empty generators in the Matrix generator, fixing a panic if a generator produced an empty list.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_1","title":"Dependency versions","text":"<ul> <li>flux &gt;v2.0.0</li> <li>weave-gitops v0.30.0</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.1</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.15.3</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0291","title":"v0.29.1","text":"<p>2023-08-04</p> <p>Warning</p> <p>This release builds upon Weave GitOps v0.29.0 that has breaking changes from Flux v2.0.0. Please make sure that you read these release notes.</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_2","title":"Dependency versions","text":"<ul> <li>flux &gt;v2.0.0</li> <li>weave-gitops v0.29.0</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.3.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.14.1</li> </ul>"},{"location":"enterprise/releases-enterprise/#enhancements","title":"\ud83d\ude80 Enhancements","text":"<ul> <li>PR: #3126 - Uses weave-gitops v0.29.0 that as major changes include:</li> <li>Support for Flux v2.0.0</li> <li>Suspend/resume/reconcile Image Repositories</li> <li>Add Verified sources to Applications and Sources UI</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0290","title":"v0.29.0","text":"<p>2023-08-03</p> <p>Danger</p>"},{"location":"enterprise/releases-enterprise/#breaking-changes","title":"\u26a0\ufe0f Breaking changes","text":"<p>We introduced a breaking change in this release by upgrading to Flux v2 APIs, notably <code>GitRepository</code> v1, <code>Kustomization</code> v1, and <code>Receiver</code> v1. This means that this version of Weave GitOps Enterprise is not compatible with previous versions of Flux v2, such as v0.41.x and earlier.</p>"},{"location":"enterprise/releases-enterprise/#action-required","title":"\u270d\ufe0f Action required","text":"<p>Follow Flux or Weave GitOps to upgrade to Flux v2 GA before upgrading Weave GitOps Enterprise.</p>"},{"location":"enterprise/releases-enterprise/#highlights_2","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#flux","title":"Flux","text":"<ul> <li>Using Flux v2.0.0 APIs. Managing <code>GitRepository</code> v1, <code>Kustomization</code> v1, and <code>Receiver</code> v1 resources. See Breaking Changes.</li> </ul>"},{"location":"enterprise/releases-enterprise/#explorer","title":"Explorer","text":"<ul> <li>Generates metrics for indexer write operations</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_3","title":"Dependency versions","text":"<ul> <li>flux &gt;v2.0.0</li> <li>weave-gitops v0.29.0-rc.1</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.3.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.14.1</li> </ul>"},{"location":"enterprise/releases-enterprise/#enhancements_1","title":"\ud83d\ude80 Enhancements","text":"<ul> <li>PR: #3137 - Upgrade to Weave GitOps OSS v0.29.0-rc.1 and Flux v2.0.0 APIs</li> <li>PR: #3119 - Bump GitOpsSets to v0.14.0</li> <li>PR: #3134 - add RED metrics for indexer writes</li> <li>PR: #3098 - [UI] Cleanup forms across sections to ensure consistency</li> <li>PR: #3145 - Wge 3144 - create sops secrets uses v1 kustomizations api</li> <li>PR: #3146 - generate v1 kustomizations when adding apps</li> <li>PR: #3164 - Bump gitopssets-controller to v0.14.1</li> </ul>"},{"location":"enterprise/releases-enterprise/#ui_1","title":"\ud83d\udd25 UI","text":"<ul> <li>PR: #3120 - Add large info display of Applied Revision and Last Updated on Terraform detail page</li> <li>PR: #3138 - Fix checkboxes on terraform data table</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0280","title":"v0.28.0","text":"<p>2023-07-20</p>"},{"location":"enterprise/releases-enterprise/#highlights_3","title":"Highlights","text":"<ul> <li>This release drops the requirement to install cert-manager</li> <li>Extends external secrets creation form to allow selecting multiple properties or all properties</li> </ul>"},{"location":"enterprise/releases-enterprise/#ui_2","title":"UI","text":"<ul> <li>Better support for organising your clusters and templates in the UI via namespaces</li> <li>Better support for Azure and Bitbucket Repositories in the UI, you can now click through to Open Pull Requests from these providers</li> <li>Dark Mode support for Policy Config</li> </ul>"},{"location":"enterprise/releases-enterprise/#explorer_1","title":"Explorer","text":"<ul> <li>Adds support for Kubernetes Events </li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>This version of Weave Gitops Enterprise drops support for <code>v1alpha1</code> of the <code>CAPITemplate</code> and <code>GitopsTemplate</code> CRDs. Please migrate to <code>v1alpha2</code> of these CRDs. See the migration guide</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_4","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.28.0</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.3.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.13.4</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0270","title":"v0.27.0","text":"<p>2023-07-07</p>"},{"location":"enterprise/releases-enterprise/#highlights_4","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#explorer_2","title":"Explorer","text":"<ul> <li>Retries to make sure we're showing you the freshest data</li> <li>Exports more metrics to enhance observability</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitopssets_1","title":"GitOpsSets","text":"<ul> <li>Config generator enabled by default! Include values from ConfigMaps and Secrets in your GitOpsSets</li> </ul>"},{"location":"enterprise/releases-enterprise/#ui_3","title":"UI","text":"<ul> <li>Dark mode enhancements</li> <li>Consistent form styling</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_5","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.26.0</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.2.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.13.4</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0260","title":"v0.26.0","text":"<p>2023-06-22</p>"},{"location":"enterprise/releases-enterprise/#highlights_5","title":"Highlights","text":"<ul> <li>Dark Mode is now available in WGE.</li> <li>Added Prometheus metrics for all API endpoints.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_6","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.26.0</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.2.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.5.0</li> <li>(optional) gitopssets-controller v0.13.2</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0250","title":"v0.25.0","text":"<p>2023-06-08</p> <p>Bug fixes</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_7","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.25.1-rc.1</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.2.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.4.0</li> <li>(optional) gitopssets-controller v0.12.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0240","title":"v0.24.0","text":"<p>2023-05-25</p>"},{"location":"enterprise/releases-enterprise/#highlights_6","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#gitopssets_2","title":"GitOpsSets","text":"<ul> <li>GitOpsSets can now generate from Flux Image Automation's <code>ImagePolicy</code>. This allows you to include the latest version of an image in your templates, for example to keep a <code>Deployment</code> up to date.</li> <li>Cross namespace support lands, create resources in multiple namespaces, they'll also be cleaned up properly via finalizers.</li> <li>The Sync button in the UI now works correctly</li> </ul>"},{"location":"enterprise/releases-enterprise/#profiles-and-charts","title":"Profiles and Charts","text":"<ul> <li>You can now filter out the versions that will be shown from a HelmRepository when installing a chart via annotations:</li> <li><code>\"weave.works/helm-version-filter\": \"&gt; 0.0.0\"</code> to filter out rc releases</li> <li><code>\"weave.works/helm-version-filter\": \"&gt; 1.0.0\"</code> to filter any pre 1.0 releases</li> <li><code>\"weave.works/helm-version-filter\": \"&gt; 3.0.0-0\"</code> to filter any pre 3.0 releases but include rc releases</li> </ul>"},{"location":"enterprise/releases-enterprise/#explorer_3","title":"Explorer","text":"<ul> <li>You could now navigate by filters and enabled full-text search.</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_2","title":"Breaking Changes","text":"<p>(none)</p>"},{"location":"enterprise/releases-enterprise/#known-issues","title":"Known issues","text":""},{"location":"enterprise/releases-enterprise/#explorer_4","title":"Explorer","text":"<ul> <li>Full-text search with terms including special characters like dashes (-) returns more results than expected by exact match term. For example, searching by term \"flux-system\" is treated as two terms: \"flux\" &amp; \"system\" so returns the results for the joint of them.  A fix for this will be part of the following releases.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_8","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.24.0</li> <li>cluster-controller v1.5.2</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.2.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.12.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0230","title":"v0.23.0","text":"<p>2023-05-12</p>"},{"location":"enterprise/releases-enterprise/#highlights_7","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#application-details","title":"Application Details","text":"<ul> <li>Health status is now displayed for Kubernetes built-in resources.</li> </ul>"},{"location":"enterprise/releases-enterprise/#explorer_5","title":"Explorer","text":"<ul> <li>You could configure the service account to use for collecting resources.</li> </ul>"},{"location":"enterprise/releases-enterprise/#templates","title":"Templates","text":"<ul> <li>You can now provide a Markdown description of a template. This will be rendered at the top of the Template page allowing template authors to provide clear instructions to their users on how to best fill in the values and complete any other required tests and checks.</li> <li>Raw templates are more flexible and allow you to render resources which don't have an explicit <code>metadata.name</code> field.</li> </ul>"},{"location":"enterprise/releases-enterprise/#cluster-details","title":"Cluster details","text":"<ul> <li>The cluster details page now shows a Cluster's Connectivity status, along with more details for both GitopsClusters and CAPIClusters, including:</li> <li>Conditions</li> <li>Labels</li> <li>Annotations</li> </ul>"},{"location":"enterprise/releases-enterprise/#explorer_6","title":"Explorer","text":"<ul> <li>When enabled useQueryServiceBackend navigation from Clusters UI to Applications UI is not possible as Explorer does not yet support filtering.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_9","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.23.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.2.0</li> <li>(optional) pipeline-controller v0.21.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.11.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0220","title":"v0.22.0","text":"<p>2023-04-27</p>"},{"location":"enterprise/releases-enterprise/#highlights_8","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#explorer_7","title":"Explorer","text":"<ul> <li>Explorer supports now Flux sources.</li> <li>Applications UI and Sources UI could be configured to use Explorer backend to improve UI experience.</li> <li>Explorer collector uses impersonation. Ensure you configure collector for your leaf clusters.</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitopssets_3","title":"GitopsSets","text":"<ul> <li>Now supports correctly templating numbers and object chunks</li> </ul>"},{"location":"enterprise/releases-enterprise/#cluster-bootstrapping","title":"Cluster Bootstrapping","text":"<ul> <li>Don't wait for ControlPlane readiness to sync secrets, this allows secrets to be sync'd related to CNI or other early stage processes</li> </ul>"},{"location":"enterprise/releases-enterprise/#upgrade-notes-from-the-previous-release","title":"Upgrade Notes (from the previous release)","text":"<ul> <li>Explorer: you should configure collector service account in your leaf clusters.</li> </ul>"},{"location":"enterprise/releases-enterprise/#known-issues_1","title":"Known issues","text":"<ul> <li>Clusters page horizontally scrolls too much and status becomes unreadable for some fields</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_10","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.22.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.6.0</li> <li>templates-controller v0.2.0</li> <li>(optional) pipeline-controller v0.20.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.9.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0212","title":"v0.21.2","text":"<p>2023-04-13</p>"},{"location":"enterprise/releases-enterprise/#highlights_9","title":"Highlights","text":"<ul> <li>See your gitopssets on leaf clusters in the UI</li> <li>Fixed bug where gitopssets would not update ConfigMaps</li> <li>View Open Pull requests button in the UI now allows you to select any GitRepository</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_11","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.21.2</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.5.0</li> <li>templates-controller v0.1.4</li> <li>(optional) pipeline-controller v0.20.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.8.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0200","title":"v0.20.0","text":"<p>2023-03-30</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_12","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.20.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.5.0</li> <li>templates-controller v0.1.4</li> <li>(optional) pipeline-controller v0.20.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.7.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0190","title":"v0.19.0","text":"<p>2023-03-16</p>"},{"location":"enterprise/releases-enterprise/#highlights_10","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#ui_4","title":"UI","text":"<ul> <li>Gitopsssets come to the UI!</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_13","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.19.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>templates-controller v0.1.4</li> <li>(optional) pipeline-controller v0.20.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.6.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0180","title":"v0.18.0","text":"<p>2023-03-02</p>"},{"location":"enterprise/releases-enterprise/#highlights_11","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#ui_5","title":"UI","text":"<ul> <li>See the logged in user's OIDC groups in the UI via the new User Profile page</li> <li>Image Automation pages now show cluster information</li> <li>See details about the configured promotion strategy for a pipeline</li> <li>Log filtering by source and level for GitOps Run</li> <li>See all Policy Configs listed in the UI</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitopssets_4","title":"GitopsSets","text":"<ul> <li>New <code>cluster</code> generator allows you to interact with the Weave GitOps Cluster inventory. GitOps Clusters that are added and removed to the inventory are reflected by the generator. That can be used to target for example to manage applications across a fleet of clusters.</li> <li>Enhanced <code>gitRepository</code> generator can now scan directories and paths with the new <code>directory</code> option, which enables you to create for example dynamically Flux Kustomizations , based on your repository.</li> <li>New <code>apiClient</code> generator allows you to query and endpoint, and provide data for your template.</li> <li>Reconciliation metrics are now reported to the <code>/metrics</code> endpoint ready to be collected</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_14","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.18.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>templates-controller v0.1.3</li> <li>(optional) pipeline-controller v0.20.0</li> <li>(optional) policy-agent v2.3.0</li> <li>(optional) gitopssets-controller v0.5.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0170","title":"v0.17.0","text":"<p>2023-02-16</p>"},{"location":"enterprise/releases-enterprise/#highlights_12","title":"Highlights","text":"<p>This release contains dependency upgrades and bug fixes. For a larger list of updates, check out the Weave GitOps v0.17.0 release.</p>"},{"location":"enterprise/releases-enterprise/#v0160","title":"v0.16.0","text":"<p>2023-02-02</p>"},{"location":"enterprise/releases-enterprise/#highlights_13","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#create-external-secrets-via-wge-ui","title":"Create External Secrets via WGE UI","text":"<ul> <li>It's becoming easier to create new a external secret CR through the UI instead of writing the whole CR yaml.</li> <li>The creation form will help users choose which cluster to deploy the External Secret to and which secret store to sync the secrets from.</li> <li>It's all done in the GitOps way.</li> </ul>"},{"location":"enterprise/releases-enterprise/#plan-button-in-terraform","title":"Plan Button in Terraform","text":"<ul> <li>Adding Add Plan button in the terraform plan page to enable users to re-plan changes made.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_15","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.16.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>templates-controller v0.1.2</li> <li>(optional) pipeline-controller v0.14.0</li> <li>(optional) policy-agent v2.2.0</li> <li>(optional) gitopssets-controller v0.2.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_3","title":"Breaking changes","text":"<p>No breaking changes</p>"},{"location":"enterprise/releases-enterprise/#v0151","title":"v0.15.1","text":"<p>2023-01-19</p>"},{"location":"enterprise/releases-enterprise/#highlights_14","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#multi-repository-support-weave-gitops-enterprise-adapts-and-scales-to-your-repository-structure","title":"Multi Repository support. Weave GitOps Enterprise adapts and scales to your repository structure","text":"<ul> <li>Weave GitOps Enterprise, is now supporting via the WGE GUI the selection of the Git Repository. Enabling to scale and match the desired Git Repository structure.</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitops-templates","title":"GitOps Templates","text":"<ul> <li>Supporting path for Profiles, enabling to set the path for profiles in the template to configure where in the directory the HelmRelease gets created.</li> <li>Enhanced Enterprise CLI support for GitOps Templates.</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitops-templates-cli-enhancements","title":"GitOps Templates CLI enhancements","text":"<ul> <li>Support for profiles in templates via CLI</li> <li><code>gitops create template</code> supporting <code>--config</code> allows you to read command line flags from a config file and <code>--output-dir</code> allows you to write files out to a directory instead of just stdout</li> </ul>"},{"location":"enterprise/releases-enterprise/#gitopssets-in-preview","title":"GitOpsSets in preview","text":"<ul> <li>GitOpsSets enable Platform Operators to have a single definition for an application for multiple environments and a fleet of clusters. A single definition can be used to generate the environment and cluster-specific configuration.</li> <li>GitOpsSets has been released as a feature in preview of WGE. The Preview phase helps us to actively collect feedback and use cases, iterating and improving the feature to reach a level of maturity before we call it stable. Please contact us via email or slack if you want to get access to the preview.</li> </ul>"},{"location":"enterprise/releases-enterprise/#minor-fixes","title":"Minor fixes","text":""},{"location":"enterprise/releases-enterprise/#oidc","title":"OIDC","text":"<ul> <li>Allows customising the requested scopes via config.oidc.customScopes: \"email,groups,something_else\"</li> <li>Token refreshing is now supported</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_16","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.15.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) pipeline-controller v0.9.0</li> <li>(optional) policy-agent v2.2.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_4","title":"Breaking changes","text":"<p>No breaking changes</p>"},{"location":"enterprise/releases-enterprise/#v0141","title":"v0.14.1","text":"<p>2023-01-05</p>"},{"location":"enterprise/releases-enterprise/#highlights_15","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#secrets-management","title":"Secrets management","text":"<ul> <li>We are introducing new functionality into Weave GitOps Enterprise to help observe and manage secrets through external secrets operator (ESO). The new secrets UI will enable customers using ESO to observe and manage external secrets, as well as help them troubleshoot issues during their secrets creation and sync operations. In this release, we are including the ability to list all ExternalSecrets custom resources across multi-cluster environments. Users also will have the ability to navigate to each ExternalSecret and know the details of the secret, its sync status, and the last time this secret has been updated, as well as the latest events associated with the secret.</li> </ul>"},{"location":"enterprise/releases-enterprise/#pipelines","title":"Pipelines","text":"<ul> <li>Retry promotion on failure. Now if a promotion fails there is an automatic retry functionalty, you can configure the threshold and delay via the CLI.</li> <li>Promotion webhook rate limiting. We enable now the configuration of the rate limit for the promotion webhooks.</li> </ul>"},{"location":"enterprise/releases-enterprise/#minor-fixes_1","title":"Minor fixes","text":""},{"location":"enterprise/releases-enterprise/#workspaces","title":"Workspaces","text":"<p> [UI] \"Tenant\"  is renamed to \"Workspace\" on details page.</p> <p> [UI] Use time.RFC3339  format for all timestamps of the workspaces tabs.</p>"},{"location":"enterprise/releases-enterprise/#other","title":"Other","text":"<p> [UI] Error notification boundary  does not allow user to navigate away from the page.</p> <p> [Gitops run] GitOps Run  doesn't ask to install dashboard twice</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_17","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.14.1</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) pipeline-controller v0.9.0</li> <li>(optional) policy-agent v2.2.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_5","title":"Breaking changes","text":"<p>No breaking changes</p>"},{"location":"enterprise/releases-enterprise/#v0130","title":"v0.13.0","text":"<p>2022-12-22</p>"},{"location":"enterprise/releases-enterprise/#highlights_16","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#gitops-templates-path-feature","title":"GitOps Templates Path feature","text":"<ul> <li>GitOps templates now provide the capability to write resources to multiple     paths in the Git repository. This feature allows complex scenarios, like for     example creating a self-service for an application that requires an RDS     database. We\u2019ve provided     documentation which has a example.</li> </ul> <pre><code>spec:\nresourcetemplates:\n- path: ./clusters/${CLUSTER_NAME}/definition/cluster.yaml\ncontent:\n- apiVersion: cluster.x-k8s.io/v1alpha4\nkind: Cluster\nmetadata:\nname: ${CLUSTER_NAME}\n...\n- apiVersion: infrastructure.cluster.x-k8s.io/v1alpha4\nkind: AWSCluster\nmetadata:\nname: ${CLUSTER_NAME}\n...\n- path: ./clusters/${CLUSTER_NAME}/workloads/helmreleases.yaml\ncontent:\n- apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: ${CLUSTER_NAME}-nginx\n...\n- apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: ${CLUSTER_NAME}-cert-manager\n...\n</code></pre>"},{"location":"enterprise/releases-enterprise/#workspace-ui","title":"Workspace UI","text":"<ul> <li>Weave GitOps now provides a GUI for Workspaces.</li> </ul>"},{"location":"enterprise/releases-enterprise/#enhanced-terraform-table-in-ui","title":"Enhanced Terraform Table in UI","text":"<ul> <li>Weave GitOps now provides more details on the Terraform inventory GUI page. Adding the type and identifier fields to the inventory table, plus filtering and a 'no data' message.</li> </ul>"},{"location":"enterprise/releases-enterprise/#keyboard-shortcuts-for-port-forwards-on-gitops-run","title":"Keyboard shortcuts for \"port forwards\" on GitOps Run","text":"<ul> <li>Weave GitOps now building and printing a list of set up port forwards.</li> <li>Weave GitOps now opening the selected port forward URL on key press. Listening for keypress is performed with the <code>github.com/mattn/go-tty</code> package (other options required pressing Enter after a keypress, this catches just a single numeric keypress) and opening URLs with the <code>github.com/pkg/browser</code> package.</li> </ul>"},{"location":"enterprise/releases-enterprise/#minor-fixes_2","title":"Minor fixes","text":"<p>[UI] Notifications Fixed provider page showing a 404.</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_18","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.13.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) pipeline-controller v0.8.0</li> <li>(optional) policy-agent v2.2.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_6","title":"Breaking changes","text":"<p>No breaking changes</p>"},{"location":"enterprise/releases-enterprise/#v0120","title":"v0.12.0","text":"<p>2022-12-09</p>"},{"location":"enterprise/releases-enterprise/#highlights_17","title":"Highlights","text":"<p>We highly recommend users of v0.11.0 upgrade to this version as it includes fixes for a number of UI issues.</p>"},{"location":"enterprise/releases-enterprise/#gitops-templates_1","title":"GitOps Templates","text":"<ul> <li>Support to specify Helm charts inside the CRD, instead of annotations. We\u2019ve     provided documentation which has a example.</li> </ul> <pre><code>spec:\ncharts:\nitems:\n- chart: cert-manager\nversion: v1.5.3\neditable: false\nrequired: true\nvalues:\ninstallCRDs: ${CERT_MANAGER_INSTALL_CRDS}\ntargetNamespace: cert-manager\nlayer: layer-1\ntemplate:\ncontent:\nmetadata:\nlabels:\napp.kubernetes.io/name: cert-manager\nspec:\nretries: ${CERT_MANAGER_RETRY_COUNT}\n</code></pre> <ul> <li>Ability to edit all fields now, including name/namespace</li> </ul>"},{"location":"enterprise/releases-enterprise/#authentication-with-oidc-support","title":"Authentication with OIDC support","text":"<p>Supporting custom OIDC groups claims for azure/okta integration Support for OIDC custom username and group claims:</p> <pre><code>config\noidc:\nclaimUsername: \"\"\nclaimGroups: \"\"\n</code></pre>"},{"location":"enterprise/releases-enterprise/#policy-commit-time-agent","title":"Policy commit-time agent","text":"<ul> <li>Support Azure DevOps and auto-remediation in commit-time enforcement.</li> </ul>"},{"location":"enterprise/releases-enterprise/#admin-user-simpler-rbac","title":"Admin User- simpler RBAC","text":"<ul> <li>Weave GitOps default admin user can now \u201cread\u201d all objects. Why is this important? As users are trying out Weave GitOps they will most likely try it out with some of their favorite Cloud Native tools such as Crossplane, Tekton, Istio, etc. This enables them to see all of those resources and explore the full power of Weave GitOps. We still do not recommend this user for \u201cproduction-use\u201d cases, and customers should always be pushed towards implementing OIDC with scoped roles.</li> </ul>"},{"location":"enterprise/releases-enterprise/#pipelines-adding-pipelines-through-templates","title":"Pipelines - adding Pipelines through Templates","text":"<ul> <li>From the Pipelines view you can add new Pipelines in a way which leverages GitOpsTemplates, additionally - to help users configure these, we\u2019ve provided documentation which has some samples.</li> </ul>"},{"location":"enterprise/releases-enterprise/#support-for-multiple-flux-instances-on-a-single-cluster","title":"Support for multiple Flux instances on a single cluster","text":"<ul> <li>Support for running multiple flux instances in different namespaces on a single cluster for resource isolation.</li> </ul>"},{"location":"enterprise/releases-enterprise/#minor-fixes_3","title":"Minor fixes","text":"<p>Terraform CRD Error Users of the Terraform Controller will be pleased to know we\u2019ve addressed the issue where an error would be displayed if it had not been installed on all connected clusters.</p> <p>Management cluster renaming If the name of the cluster where Weave GitOps Enterprise is installed, was changed from the default of management through the config.cluster.name parameter, certain workflows could fail such as fetching profiles, this has now been resolved.</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_19","title":"Dependency versions\u200b","text":"<p>weave-gitops v0.12.0 cluster-controller v1.4.1 cluster-bootstrap-controller v0.3.0 (optional) pipeline-controller v0.0.11 (optional) policy-agent 2.1.1</p>"},{"location":"enterprise/releases-enterprise/#known-issues_2","title":"Known issues","text":"<ul> <li>[UI] Notifications provider page shows a 404.</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0110","title":"v0.11.0","text":"<p>2022-11-25</p>"},{"location":"enterprise/releases-enterprise/#highlights_18","title":"Highlights","text":""},{"location":"enterprise/releases-enterprise/#gitopstemplates","title":"GitOpsTemplates","text":"<ul> <li>We are working towards unifying CAPI and GitOps Templates under a single umbrella. For those already using CAPITemplates, we will ensure a smooth transition is possible by making use of a conversion hooks. There are some breaking changes for GitOpsTemplates as part of this transitionary period, so be sure to check the guidance under Breaking Changes.</li> <li>We now retain the ordering of parameters in the template instead of sorting them alphabetically. Providing to the author control in what sequence the parameters are rendered in the form and thus present a more logically grouped set of parameters to the end consumer.</li> <li>You can control what     delimiters you     want to use in a template. This provides flexibility for if you want to use     the syntax for dynamic functions like the helper functions we support.</li> </ul>"},{"location":"enterprise/releases-enterprise/#pipelines_1","title":"Pipelines","text":"<ul> <li>This feature is now enabled by default when you install the Weave GitOps Enterprise Helm Chart. You can toggle this with the <code>enablePipelines</code> flag.</li> <li>GitOpsTemplates are a highly flexible way to create new resources - including Pipelines. We now provide a shortcut on the Pipelines table view to navigate you to Templates with the <code>weave.works/template-type=pipeline</code> label.</li> </ul>"},{"location":"enterprise/releases-enterprise/#telemetry","title":"Telemetry","text":"<p>This release incorporates anonymous aggregate user behavior analytics to help us continuously improve the product. As an Enterprise customer, this is enabled by default. You can learn more about this here.</p>"},{"location":"enterprise/releases-enterprise/#dependency-versions_20","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.11.0</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) pipeline-controller v0.0.11</li> <li>(optional) policy-agent 2.1.1</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes_7","title":"Breaking changes","text":""},{"location":"enterprise/releases-enterprise/#gitopstemplates-and-capitemplates","title":"GitOpsTemplates and CAPITemplates","text":"<p>We are making these changes to provide a unified and intuitive self-service experience within Weave GitOps Enterprise, removing misleading and potentially confusing terminology born from when only Clusters were backed by Templates.</p> <p>New API Group for the GitOpsTemplate CRD - old: <code>clustertemplates.weave.works</code> - new: <code>templates.weave.works</code></p> <p>After upgrading Weave GitOps Enterprise which includes the updated CRD: 1. Update all your GitOpsTemplates in Git changing all occurrences of <code>apiVersion: clustertemplates.weave.works/v1alpha1</code> to <code>apiVersion: templates.weave.works/v1alpha1</code>. 2. Commit, push and reconcile. They should now be viewable in the Templates view again. 3. Clean up the old CRD. As it stands:    - <code>kubectl get gitopstemplate -A</code> will be empty as it is pointing to the old <code>clustertemplates.weave.works</code> CRD.    - <code>kubectl get gitopstemplate.templates.weave.works -A</code> will work To fix the former of the commands, remove the old CRD (helm does not do this automatically for safety reasons):    - <code>kubectl delete crd gitopstemplates.clustertemplates.weave.works</code>    - You may have to wait up to 5 minutes for your local kubectl CRD cache to invalidate, then <code>kubectl get gitopstemplate -A</code> should be working as usual</p> <p>Template Profiles / Applications / Credentials sections are hidden by default</p> <p>For both <code>CAPITemplates</code> and <code>GitopsTemplates</code> the default visibility for all sections in a template has been set to <code>\"false\"</code>. To re-enable profiles or applications on a template you can tweak the annotations</p> <pre><code>annotations:\ntemplates.weave.works/profiles-enabled: \"true\" # enable profiles\ntemplates.weave.works/kustomizations-enabled: \"true\" # enable applications\ntemplates.weave.works/credentials-enabled: \"true\" # enable CAPI credentials\n</code></pre> <p>The default values for a profile are not fetched and included in a pull-request</p> <p>Prior to this release WGE would fetch the default values.yaml for every profile installed and include them in the <code>HelmReleases</code> in the Pull Request when rendering out the profiles of a template.</p> <p>This was an expensive operation and occasionally led to timeouts.</p> <p>The new behaviour is to omit the values and fall back to the defaults included in the helm-chart. This sacrifices some UX (being able to see all the defaults in the PR and tweak them) to improve performance. There should not be any final behaviour changes to the installed charts.</p> <p>You can still view and tweak the <code>values.yaml</code> when selecting profiles to include on the \"Create resource (cluster)\" page. If changes are made here the updated values.yaml will be included.</p>"},{"location":"enterprise/releases-enterprise/#v0102","title":"v0.10.2","text":"<p>2022-11-15</p>"},{"location":"enterprise/releases-enterprise/#highlights_19","title":"Highlights","text":"<ul> <li>Retain template parameter ordering.</li> <li>Allow configuration of the delimiters in templates.</li> <li>Add create a pipeline button.</li> <li>add missing support for policy version v2beta2 to tenancy cmd.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_21","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.10.2</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) policy-agent 2.1.1</li> </ul>"},{"location":"enterprise/releases-enterprise/#v0101","title":"v0.10.1","text":"<p>2022-11-10</p>"},{"location":"enterprise/releases-enterprise/#highlights_20","title":"Highlights","text":"<ul> <li>Create non-cluster resources / Add Edit option to resources with create-request annotation</li> <li>bump pipeline-controller</li> <li>Parse annotations from template</li> <li>Add cost estimate message if available</li> <li> <p>Adds support for showing policy modes and policy configs in the UI</p> </li> <li> <p>Show suspended status on pipelines detail</p> </li> <li>YAML view for Pipelines</li> <li> <p>Align and link logo</p> </li> <li> <p>Actually remove the watcher from the helm-watcher-cache</p> </li> <li> <p>UI 1817 disable create target name space if name space is flux system</p> </li> <li> <p>Adding edit capi cluster resource acceptance test</p> </li> <li>Add preview acceptance test</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_22","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.10.1</li> <li>cluster-controller v1.4.1</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) policy-agent 2.0.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#v096","title":"v0.9.6","text":"<p>2022-10-17</p>"},{"location":"enterprise/releases-enterprise/#highlights_21","title":"Highlights","text":"<ul> <li>When adding applications, you can now preview the changes(PR) before creating a pull request</li> <li>You can now see included Cluster Profiles when previewing your Create Cluster PR</li> <li>Notifications are now available in the Notifications Page</li> <li>You can now automatically create namespace when adding applications</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_23","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.9.6</li> <li>cluster-controller v1.3.2</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) policy-agent 1.2.1</li> </ul>"},{"location":"enterprise/releases-enterprise/#v095","title":"v0.9.5","text":"<p>2022-09-22</p>"},{"location":"enterprise/releases-enterprise/#highlights_22","title":"Highlights","text":"<ul> <li>Tenancy</li> <li><code>gitops create tenant</code> now supports <code>--prune</code> to remove old resources from the cluster if you're not using <code>--export</code> with GitOps.</li> <li><code>deploymentRBAC</code> section in <code>tenancy.yaml</code> allows you to specify the permissions given to the flux <code>Kustomizations</code> that will apply the resources from git to your tenants' namespaces in the cluster.</li> <li>Support for <code>OCIRepository</code> sources when restricting/allowing the sources that can be applied into tenants' namespaces.</li> <li>Templates</li> <li>Templates now support helm functions for simple transformations of values: <code>{{ .params.CLUSTER_NAME | upper }}</code></li> <li>Templates has moved to its own page in the UI, this is the first step in moving towards embracing them as a more generic feature, not just for cluster creation.</li> <li>If a version is not specified in a template profile annotation it can be selected by the user.</li> <li>A <code>namespace</code> can be specified in the template profile annotation that will be provided as the <code>HelmRelease</code>'s <code>targetNamespace</code> by default.</li> <li>Bootstrapping</li> <li>A ClusterBootstrapConfig can now optionally be triggered when <code>phase=\"Provisioned\"</code>, rather than <code>ControlPlaneReady=True</code> status.</li> </ul>"},{"location":"enterprise/releases-enterprise/#dependency-versions_24","title":"Dependency versions","text":"<ul> <li>weave-gitops v0.9.5</li> <li>cluster-controller v1.3.2</li> <li>cluster-bootstrap-controller v0.3.0</li> <li>(optional) policy-agent 1.1.0</li> </ul>"},{"location":"enterprise/releases-enterprise/#known-issues_3","title":"Known issues","text":"<ul> <li>[UI] Notifications page shows a 404 instead of the notification-controller's configuration.</li> </ul>"},{"location":"enterprise/releases-enterprise/#breaking-changes-from-v094","title":"\u26a0\ufe0f Breaking changes from v0.9.4","text":"<p>If using the policy-agent included in the weave-gitops-enterprise helm chart, the configuration should now be placed under the <code>config</code> key.</p> <p>old <pre><code>policy-agent:\nenabled: true\naccountId: \"my-account\"\nclusterId: \"my-cluster\"\n</code></pre></p> <p>new <pre><code>policy-agent:\nenabled: true\nconfig:\naccountId: \"my-account\"\nclusterId: \"my-cluster\"\n</code></pre></p>"},{"location":"explorer/","title":"Explorer ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>As platform engineer or as developer, your applications and platform services will likely span multiple kubernetes clusters or infrastructure components.  In order to manage and operate them you require a platform capability that allows you to discover the resources from a single place.</p> <p>Explorer is that capability that allows any platform user to discover platform resources from a single place across all your kubernetes clusters.</p> <p></p>"},{"location":"explorer/#faq","title":"FAQ","text":""},{"location":"explorer/#which-journeys-would-be-able-to-use-explorer-for","title":"Which journeys would be able to use explorer for?","text":"<p>Explorer is better suited for journeys matching the discovery of resources across the platform resources inventory.</p>"},{"location":"explorer/#which-journeys-would-be-better-using-other-weave-gitops-capabilities-for","title":"Which journeys would be better using other weave gitops capabilities for?","text":"<p>If you have a particular resources you want to manage, weave gitops offers single resource experience for almost every resource.</p>"},{"location":"explorer/#which-kinds-does-explorer-support","title":"Which Kinds does explorer support?","text":"<p>Explorer support all Flux Applications and Sources CRDs</p> <p>See Supported Kinds for more details.</p>"},{"location":"explorer/#next-steps","title":"Next Steps","text":"<p>Now that you know what Explorer is, follow getting started to quickly have a feeling of what Explorer can do for you.</p>"},{"location":"explorer/configuration/","title":"Configuration ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>This page helps you to understand the options available to configure Explorer</p>"},{"location":"explorer/configuration/#prerequisites","title":"Prerequisites","text":"<p>Before using Explorer, please ensure that: - You have Weave Gitops Enterprise v0.23.0</p>"},{"location":"explorer/configuration/#setup","title":"Setup","text":"<p>The following configuration options are available for you to setup Explorer.</p> <ul> <li><code>.spec.values.enableExplorer</code>: feature flag to control whether Explorer is enabled.</li> <li><code>.spec.values.useQueryServiceBackend</code>: feature flag to control whether you want to leverage Explorer backend capabilities for other UI experiences like Applications or Sources</li> <li><code>.spec.values.explorer.collector.serviceAccount</code>: ServiceAccount <code>name</code> and <code>namespace</code> that explorer collector will use to impersonate in leaf clusters. Make sure you read authz for collector before setting it. Default values are <code>name: collector</code>, <code>namespace: flux-system</code>.</li> </ul> <p>You should specify them in your HelmRelease values:</p> <pre><code>---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: weave-gitops-enterprise\nnamespace: flux-system\nspec:\n# ... other spec components\nvalues:\nenableExplorer: true # feature flag to enable explorer\nuseQueryServiceBackend: true # uses explorer query backend in collection UIs\nexplorer:\ncollector:\nserviceAccount: # service account that collector will impersonate in leaf clusters\nname: collector\nnamespace: flux-system\n</code></pre>"},{"location":"explorer/configuration/#configuration","title":"Configuration","text":""},{"location":"explorer/configuration/#clusters","title":"Clusters","text":"<p>Explorer watches the GitopsClusters that you have connected to Weave Gitops Enterprise, as well as your Management cluster.</p>"},{"location":"explorer/configuration/#kinds","title":"Kinds","text":"<p>Explorer watches for the following kind resources out of the box:</p> <p>Flux GitOps Toolkit</p> <ul> <li>HelmRelease</li> <li>Kustomizations</li> <li>Sources</li> <li>GitRepostiories</li> <li>OciRepositories</li> <li>HelmRepositories</li> <li>HelmCharts</li> <li>Buckets</li> </ul> <p>Weave Gitops - GitopsSets - Templates - Policy Audit Violations</p>"},{"location":"explorer/configuration/#data-layer","title":"Data Layer","text":"<p>Explorer take a simple approach to manage resource views. It leverages a Data Store for caching the views and query them. The storage lifecycle is bounded to Weave Gitops Enterprise app and does not provide persistence guarantees. Instead, it requests data as required to the leaf clusters. In its simplest form, the data store used is SQLite.</p>"},{"location":"explorer/configuration/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>There are two main paths to consider within Explorer in the context of authentication and authorization (authN/authZ):</p> <ol> <li>The read or querying path is exercised when a weave gitops user queries the data.</li> <li>The write or collecting path is exercised to gather the resources from the leaf clusters.</li> </ol> <p>We look into them separately.</p>"},{"location":"explorer/configuration/#authentication-and-authorization-for-querying","title":"Authentication and Authorization for querying","text":"<p>Explorer leverages existing authentication and authorization built-in the application. It identifies for a user logged in the application: its identity and the access permissions via Kuberentes RBAC. Query results are filtered honouring the access determined via RBAC.</p>"},{"location":"explorer/configuration/#authentication-and-authorization-for-collecting","title":"Authentication and Authorization for collecting","text":"<p>GitopsClusters define the connection and security context that Explorer leverages to collect data from leaf clusters. Given that you have followed the indications in setup RBAC, the GitopsCluster service account is able to impersonate any user or group.</p> <p>Tip</p> <p>Collector RBAC resources are part of your leaf clusters common RBAC configuration. It is commonly located in your  <code>clusters/bases</code> folder, as described in Getting started.</p> <p>To configure collection, you would need to extend this configuration with the following:</p> <ol> <li>Create a ServiceAccount for the one that you specified in your setup <code>.spec.values.explorer.collector.serviceAccount</code>.</li> </ol> Expand to see example <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: collector # should match .spec.values.explorer.collector.serviceAccount.name\nnamespace: flux-system # should match .spec.values.explorer.collector.serviceAccount.namespace\n</code></pre> <ol> <li>Create a ClusterRole with the permissions to watch the supported resources.</li> </ol> Expand to see example <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: collector # could be .spec.values.explorer.collector.serviceAccount.name\nrules:\n- apiGroups: [ \"rbac.authorization.k8s.io\" ]\nresources: [ \"roles\", \"clusterroles\", \"rolebindings\", \"clusterrolebindings\" ]\nverbs: [ \"list\", \"watch\" ]\n- apiGroups: [ \"kustomize.toolkit.fluxcd.io\" ]\nresources: [ \"kustomizations\" ]\nverbs: [ \"list\", \"watch\" ]\n- apiGroups: [ \"helm.toolkit.fluxcd.io\" ]\nresources: [ \"helmreleases\" ]\nverbs: [ \"list\", \"watch\" ]\n- apiGroups: [ \"source.toolkit.fluxcd.io\" ]\nresources: [ \"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\" ]\nverbs: [ \"list\", \"watch\" ]\n</code></pre> <ol> <li>Create a ClusterRolebinding to assign previous ClusterRole to the created collector <code>ServiceAccount</code>.</li> </ol> Expand to see example <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: collector # could be .spec.values.explorer.collector.serviceAccount.name\nsubjects:\n- kind: ServiceAccount\nname: collector # should match .spec.values.explorer.collector.serviceAccount.name\nnamespace: flux-system # should match .spec.values.explorer.collector.serviceAccount.namespace\nroleRef:\nkind: ClusterRole\nname: collector # name of the cluster role created earlier\napiGroup: rbac.authorization.k8s.io\n</code></pre> <p>If you want the collector to watch a particular namespace use a RoleBinding instead.</p> <ol> <li>Extend impersonation rules to allow service account impersonation for ServiceAccount <code>collector</code></li> </ol> Expand to see example <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: clusters-service-impersonator-role\nrules:\n- apiGroups: [\"\"]\nresources: [\"users\", \"groups\"]\nverbs: [\"impersonate\"]\n- apiGroups: [ \"\" ]\nresources: [ \"serviceaccounts\" ]\nverbs: [ \"impersonate\" ]\nresourceNames:\n- \"collector\" # should match .spec.values.explorer.collector.serviceAccount.name\n</code></pre>"},{"location":"explorer/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>See querying to deep dive in how to query.</li> <li>See operations for day troubleshooting and operations.</li> </ul>"},{"location":"explorer/getting-started/","title":"Getting started  ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>This guide shows you the basics steps to start using Explorer.</p>"},{"location":"explorer/getting-started/#pre-requisites","title":"Pre-requisites","text":"<p>Before using Explorer, please ensure that:</p> <ul> <li>You have Weave Gitops Enterprise v0.23.0 or later version</li> <li>You have deployed an application.</li> </ul>"},{"location":"explorer/getting-started/#setup","title":"Setup","text":"<p>Explorer is enabled via configuration through the feature flag  <code>explorer.enabled</code> that you could configure in your Weave Gitops Enterprise HelmRelease values:</p> <pre><code>---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: weave-gitops-enterprise\nnamespace: flux-system\nspec:\n# ... other spec components\nvalues:\nexplorer:\nenabled: true # global enable/disable flag\ncollector:\n# ServiceAccount that explorer will use to watch clusters for resources\nserviceAccount:\nname: \"collector\"\nnamespace: \"flux-system\"\ncleaner:\ndisabled: false\nenabledFor: # controls which parts of the UI utilize the Explorer UI/Server components\n- applications\n- sources\n- gitopssets\n- templates\n</code></pre> <p>The <code>enabledFor</code> field will control which parts of the UI utilize the Explorer backend for performant queries. Note that this does not control the collection of these objects, only the presentation of the objects in the UI.</p> <p>For a complete overview on the configuration you could see configuration.</p>"},{"location":"explorer/getting-started/#explorer-ui","title":"Explorer UI","text":"<p>Login to Weave Gitops and Explorer will be shown in the navigation menu <code>Explorer</code>.</p> <p>Explorer UI looks as follows:</p> <p></p> <p>It has two main components:</p> <ul> <li>A search dialog with filter to querying the platform resources</li> <li>A table with the filtered resources.</li> </ul> <p>For a more detailed view on the UI you could see querying.</p>"},{"location":"explorer/operations/","title":"Operations ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>As platform engineer you could need to have a finer understanding on the underlying logic for Explorer. The following options are available to you to operate and troubleshoot it.</p>"},{"location":"explorer/operations/#debug-access-rules","title":"Debug Access Rules","text":"<p>It is a debugging tool to make visible explorer authorization logic. You could find it as tab <code>Access Rules</code>  alongside the <code>Query</code> tab.</p> <p></p> <p>You could discover by <code>Cluster</code> and <code>Subject</code> the <code>Kinds</code> it is allowed to read. These are the rules that will be the source of truth doing authorization when a user does a query.</p>"},{"location":"explorer/operations/#monitoring","title":"Monitoring","text":"<p>Explorer provides the following telemetry to use for operations.</p>"},{"location":"explorer/operations/#metrics","title":"Metrics","text":"<p>Explorer exports Prometheus metrics. See setup to get started.</p>"},{"location":"explorer/operations/#querying","title":"Querying","text":"<p>Explorer querying path is composed of three components exporting metrics:</p> <ul> <li>API server</li> <li>Datastore Reads</li> <li>Indexer Reads</li> </ul>"},{"location":"explorer/operations/#api-server","title":"API Server","text":"<p>Based on go-http-metrics, the following metrics are generated.</p> <p>Request Duration: histogram with the latency of the HTTP requests.</p> <pre><code>http_request_duration_seconds_bucket{handler=\"/v1/query\",method=\"POST\",le=\"0.05\"} 0\nhttp_request_duration_seconds_sum{handler=\"/v1/query\",method=\"POST\"} 10.088081923\nhttp_request_duration_seconds_count{handler=\"/v1/query\",method=\"POST\"} 51\n</code></pre> <p>Response Size: histogram with the size of the HTTP responses in bytes</p> <pre><code>http_response_size_bytes_bucket{handler=\"/v1/query\",method=\"POST\",le=\"0.05\"} 10\nhttp_response_size_bytes_sum{handler=\"/v1/query\",method=\"POST\"} 120\nhttp_response_size_bytes_count{handler=\"/v1/query\",method=\"POST\"} 10\n</code></pre> <p>Requests In Flight: gauge with the number of inflight requests being handled at the same time.</p> <pre><code>http_requests_inflight{handler=\"/v1/query\"} 0\n</code></pre>"},{"location":"explorer/operations/#datastore-reads","title":"Datastore Reads","text":"<p>Request Latency: histogram with the latency of the datastore read requests.</p> <ul> <li><code>action</code> is the datastore read operation that could be either <code>GetObjects</code>, <code>GetAccessRules</code>, <code>GetObjectByID</code>, <code>GetRoles</code> or <code>GetRoleBindings</code>.</li> <li><code>status</code> is the result of the operation. It could be either  read operation that could be either <code>success</code> or <code>error</code>.</li> </ul> <p><pre><code>datastore_latency_seconds_bucket{action=\"GetObjectByID\", le=\"+Inf\", status=\"success\"} 1175\ndatastore_latency_seconds_bucket{action=\"GetObjectByID\", le=\"0.01\", status=\"success\"} 1174\n</code></pre> <pre><code>datastore_latency_seconds_count{action=\"GetObjectByID\",  status=\"success\"} 1175\ndatastore_latency_seconds_count{action=\"GetRoleBindings\",  status=\"success\"} 47\ndatastore_latency_seconds_count{action=\"GetRoles\",  status=\"success\"} 47\n</code></pre> <pre><code>datastore_latency_seconds_sum{action=\"GetObjectByID\",  status=\"success\"} 0.6924557999999995\ndatastore_latency_seconds_sum{action=\"GetRoleBindings\",  status=\"success\"} 1.329158916\ndatastore_latency_seconds_sum{action=\"GetRoles\",  status=\"success\"} 3.942473879999999\n</code></pre></p> <p>Requests In Flight: gauge with the number of inflight requests being handled at the same time.</p> <ul> <li><code>action</code> is the datastore read operation that could be either <code>GetObjects</code>, <code>GetAccessRules</code>, <code>GetObjectByID</code>, <code>GetRoles</code> or <code>GetRoleBindings</code></li> </ul> <pre><code>datastore_inflight_requests{action=\"GetObjectByID\"} 0\ndatastore_inflight_requests{action=\"GetRoleBindings\"} 0\ndatastore_inflight_requests{action=\"GetRoles\"} 0\n</code></pre>"},{"location":"explorer/operations/#indexer-reads","title":"Indexer Reads","text":"<p>Request Latency: histogram with the latency of the indexer read requests.</p> <ul> <li><code>action</code> is the index read operation that could be either <code>ListFacets</code> or <code>Search</code></li> <li><code>status</code> is the result of the operation. It could be either  read operation that could be either <code>success</code> or <code>error</code></li> </ul> <p><pre><code>indexer_latency_seconds_bucket{action=\"ListFacets\", le=\"+Inf\", status=\"success\"} 1\nindexer_latency_seconds_bucket{action=\"Search\", le=\"+Inf\", status=\"success\"} 47\n</code></pre> <pre><code>indexer_latency_seconds_sum{action=\"ListFacets\", status=\"success\"} 0.008928666\nindexer_latency_seconds_sum{action=\"Search\", status=\"success\"} 0.06231312599999999\n</code></pre> <pre><code>indexer_latency_seconds_count{action=\"ListFacets\", status=\"success\"} 1\nindexer_latency_seconds_count{action=\"Search\", status=\"success\"} 47\n</code></pre></p> <p>Requests In Flight: gauge with the number of inflight requests being handled at the same time.</p> <ul> <li><code>action</code> is the index read operation that could be either <code>ListFacets</code> or <code>Search</code></li> </ul> <pre><code>indexer_inflight_requests{action=\"ListFacets\"} 0\nindexer_inflight_requests{action=\"Search\"} 0\n</code></pre>"},{"location":"explorer/operations/#collecting","title":"Collecting","text":"<p>Explorer collecting path is composed of three components exporting metrics:</p> <ul> <li>Cluster Watcher Manager</li> <li>Datastore Writes</li> <li>Indexer Writes</li> </ul> <p>The following metrics are available to monitor its health.</p>"},{"location":"explorer/operations/#cluster-watcher","title":"Cluster Watcher","text":"<p>The metric <code>collector_cluster_watcher</code> provides the number of the cluster watchers it the following <code>status</code>: - Starting: a cluster watcher is starting at the back of detecting that a new cluster has been registered. - Started: cluster watcher has been started and collecting events from the remote cluster. This is the stable state. - Stopping: a cluster has been deregistered so its cluster watcher is no longer required. In the process of stopping it. - Failed: a cluster watcher has failed during the creation or starting process and cannot collect events from the remote clusters. This is the unstable state.</p> <p>Where <code>collector</code> is the type of collector, it could be - rbac: for collecting RBAC resources (ie roles) - objects: for collecting non-rbac resources (ie kustomizations)</p> <pre><code>collector_cluster_watcher{collector=\"objects\", status=\"started\"} 1\ncollector_cluster_watcher{collector=\"objects\", status=\"starting\"} 0\ncollector_cluster_watcher{collector=\"rbac\", status=\"started\"} 1\ncollector_cluster_watcher{collector=\"rbac\", status=\"starting\"} 0\n</code></pre> <p>A sum on <code>collector_cluster_watcher</code> gives the total number of cluster watchers that should be equal to the number of clusters</p>"},{"location":"explorer/operations/#datastore-writes","title":"Datastore Writes","text":"<p>Request Latency: histogram with the latency of the datastore write requests.</p> <ul> <li><code>action</code> is the datastore write operation that could be either <code>StoreRoles</code>, <code>StoreRoleBindings</code>, <code>StoreObjects</code>, <code>DeleteObjects</code>, <code>DeleteAllObjects</code>, <code>DeleteRoles</code>, <code>DeleteAllRoles</code>, <code>DeleteRoleBindings</code>, <code>DeleteAllRoleBindings</code></li> <li><code>status</code> is the result of the operation. It could be either  read operation that could be either <code>success</code> or <code>error</code></li> </ul> <pre><code>datastore_latency_seconds_bucket{action=\"StoreRoles\", le=\"+Inf\", status=\"success\"} 1175\ndatastore_latency_seconds_bucket{action=\"StoreRoles\", le=\"0.01\", status=\"success\"} 1174\n</code></pre> <pre><code>datastore_latency_seconds_count{action=\"StoreRoles\",  status=\"success\"} 1175\ndatastore_latency_seconds_count{action=\"DeleteRoles\",  status=\"success\"} 47\ndatastore_latency_seconds_count{action=\"DeleteAllRoleBindings\",  status=\"success\"} 47\n</code></pre> <pre><code>datastore_latency_seconds_sum{action=\"StoreRoles\",  status=\"success\"} 0.6924557999999995\ndatastore_latency_seconds_sum{action=\"DeleteRoles\",  status=\"success\"} 1.329158916\ndatastore_latency_seconds_sum{action=\"DeleteAllRoleBindings\",  status=\"success\"} 3.942473879999999\n</code></pre> <p>Requests In Flight: gauge with the number of inflight write requests being handled at the same time.</p> <ul> <li><code>action</code> is the datastore write operation that could be either <code>StoreRoles</code>, <code>StoreRoleBindings</code>, <code>StoreObjects</code>, <code>DeleteObjects</code>, <code>DeleteAllObjects</code>, <code>DeleteRoles</code>, <code>DeleteAllRoles</code>, <code>DeleteRoleBindings</code>, <code>DeleteAllRoleBindings</code></li> </ul> <pre><code>datastore_inflight_requests{action=\"StoreRoles\"} 0\ndatastore_inflight_requests{action=\"StoreRoleBindings\"} 0\ndatastore_inflight_requests{action=\"DeleteAllRoleBindings\"} 0\n</code></pre>"},{"location":"explorer/operations/#indexer-writes","title":"Indexer Writes","text":"<p>Request Latency: histogram with the latency of the indexer write requests.</p> <ul> <li><code>action</code> is the index write operation that could be either <code>Add</code>, <code>Remove</code> or <code>RemoveByQuery</code></li> <li><code>status</code> is the result of the operation. It could be either <code>success</code> or <code>error</code></li> </ul> <p><pre><code>indexer_latency_seconds_bucket{action=\"Add\",status=\"success\",le=\"+Inf\"} 109\nindexer_latency_seconds_bucket{action=\"Remove\",status=\"success\",le=\"+Inf\"} 3\n</code></pre> <pre><code>indexer_latency_seconds_sum{action=\"Add\",status=\"success\"} 8.393912168\nindexer_latency_seconds_sum{action=\"Remove\",status=\"success\"} 0.012298476\n</code></pre> <pre><code>indexer_latency_seconds_count{action=\"Add\",status=\"success\"} 109\nindexer_latency_seconds_count{action=\"Remove\",status=\"success\"} 3\n</code></pre></p> <p>Requests In Flight: gauge with the number of inflight requests being handled at the same time.</p> <ul> <li><code>action</code> is the index write operation that could be either <code>Add</code>, <code>Remove</code> or <code>RemoveByQuery</code></li> </ul> <pre><code>indexer_inflight_requests{action=\"Add\"} 0\nindexer_inflight_requests{action=\"Remove\"} 0\n</code></pre>"},{"location":"explorer/operations/#dashboard","title":"Dashboard","text":"<p>Use Explorer dashboard to monitor its golden signals</p> <p></p> <p>Explorer dashboard is part of Weave GitOps Dashboards</p>"},{"location":"explorer/querying/","title":"Querying ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>Explorer recommended way to discover resources is via its search dialog. This guide provides the background to understand it and set how to use it.</p>"},{"location":"explorer/querying/#schema","title":"Schema","text":"<p>Every resource is normalised to the following common schema:</p> Key Description Cluster Name of cluster where the resource exists. As gitops cluster <code>&lt;GitopsClusterNamespace,GitopsClusterName&gt;</code> Namespace Namespace name where the resource exists. Kind Resource kubernetes type or kind Name Resource name as specified in its manifest. Status Resource health status. Indicates the status of its reconciliation. Message Resource health status message. It extends status field with information about the status. <p>For a <code>podinfo</code> helm release from a cluster <code>default/progress-delivery-demo2-32</code> like this:</p> <pre><code>apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: podinfo\nnamespace: flux-system\nspec:\nchart:\nspec:\nchart: podinfo\ninterval: 1m\nreconcileStrategy: ChartVersion\nsourceRef:\nkind: HelmRepository\nname: podinfo\nversion: 6.0.0\ninterval: 1m\nstatus:\nconditions:\n- message: Release reconciliation succeeded\nreason: ReconciliationSucceeded\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>The schema looks like</p> Cluster Namespace Kind Name Status Message <code>default/progress-delivery-demo2-32</code> <code>flux-system</code> <code>HelmRelease</code> <code>podinfo</code> <code>Success</code> <code>Release reconciliation succeeded</code> <p>You can open the query filter settings by clicking on the filter button:</p> <p></p>"},{"location":"explorer/querying/#filtering-and-searching","title":"Filtering and Searching","text":"<p>The <code>Search</code> field allows for free-form text entry to query objects across all fields. For example, if we enter the term \"podinfo\", we will get matches for not only object names, but also strings from the <code>Message</code> field:</p> <p></p> <p>To filter the results by cluster, kind, namespace, enable the checkbox filters:</p> <p></p> <p>Note that the free-form terms only apply to the filtered results from the kind filter. In this case, we only match the \"podinfo\" string on results that are <code>Kustomizations</code>.</p> <p>We can also \"OR\" filters together. Note that filters within a category are OR'd together, but terms are AND'd across categories. For example, selecting the <code>Kind=Kustomization</code> and <code>Kind=HelmRelease</code> filters will show both <code>Kustomizations</code> and <code>HelmReleases</code>:</p> <p></p>"},{"location":"gitops-templates/","title":"Introduction ENTERPRISE","text":"<p>A <code>GitOpsTemplate</code> enables application developers to self-service components and services easily through the Weave GitOps Dashboard. It's a simple YAML file that you can enrich with parameters, variables, metadata, and conditions.</p> <p>Use a <code>GitOpsTemplate</code> to template any resource that can be expressed in YAML (basic Kubernetes resources, Flux primitives, Terraform controller, Crossplane, Cluster API, etc.) into a standardised definition.</p> <p>Application developers can use a template through our GUI. The rendered template is added to their GitOps repository via a pull request. When merged and reconciled, the resources in the template are created. A resource can be a <code>MachinePool</code> for CAPI objects, a Flux Kustomization, or a Terraform Controller resource, to name a few examples.</p> <p>Tip</p> <p>A <code>GitOpsTemplate</code> must be valid <code>yaml</code>. Beyond this, a rendered template can create any resource you need .</p> <p></p> <p>Info</p> <p>GitOpsTemplate or CAPITemplate?</p> <p>The only difference between <code>CAPITemplate</code> and <code>GitOpsTemplate</code> is the default value of these two annotations:</p> Annotation default value for <code>CAPITemplate</code> default value for <code>GitOpsTemplate</code> <code>templates.weave.works/add-common-bases</code> <code>\"true\"</code> <code>\"false\"</code> <code>templates.weave.works/inject-prune-annotations</code> <code>\"true\"</code> <code>\"false\"</code>"},{"location":"gitops-templates/annotations/","title":"Annotations ENTERPRISE","text":""},{"location":"gitops-templates/annotations/#the-add-common-bases-annotation","title":"The <code>add-common-bases</code> annotation","text":"<p>The <code>templates.weave.works/add-common-bases: \"true\"</code> annotation can be used to enable and disable the addition of a \"common bases\" <code>Kustomization</code> to the list of rendered files. This kustomization will sync a path that is common to all clusters (<code>clusters/bases</code>).</p> <p>An example usecase would be to ensure that certain RBAC or policies are applied to all clusters using this template.</p>"},{"location":"gitops-templates/annotations/#the-inject-prune-annotation-annotation","title":"The <code>inject-prune-annotation</code> annotation","text":"<p>The <code>templates.weave.works/inject-prune-annotation: \"true\"</code> annotation can be used to enable and disable the injection of Flux's <code>prune</code> annotation into certain resources.</p> <p>When enabled, GitOps automatically injects a <code>kustomize.toolkit.fluxcd.io/prune: disabled</code> annotation into every resource in the <code>spec.resourcetemplates</code> that is not a <code>cluster.x-k8s.io.Cluster</code> and not a <code>gitops.weave.works.GitopsCluster</code>.</p> <p>The intention here is stop Flux from explicitly deleting subresources of the <code>Cluster</code> like <code>AWSCluster</code>, <code>KubeadmControlPlane</code>, <code>AWSMachineTemplate</code> etc and let the CAPI controllers handle their removal.</p> <p>This is the pattern recommended in the capi-quickstart guide https://cluster-api.sigs.k8s.io/user/quick-start.html#clean-up.</p>"},{"location":"gitops-templates/cli/","title":"Template CLI ENTERPRISE","text":"<p>The Enterprise <code>gitops</code> CLI tool provides a set of commands to help you manage your templates.</p> <p>Here we're going to talk about the <code>gitops create template</code> command that allows you to render templates locally and airgapped, without a full WGE installation in a Kubernetes cluster.</p>"},{"location":"gitops-templates/cli/#use-cases","title":"Use cases","text":"<ul> <li>In CI/CD systems where you want to render a template and then use the raw output in a pipeline</li> <li>For quickly debugging templates</li> </ul>"},{"location":"gitops-templates/cli/#restrictions","title":"Restrictions","text":"<p>The <code>gitops create template</code> command only works with <code>GitOpsTemplate</code> objects. It does not work with <code>CAPITemplate</code> objects. You should be able to migrate any <code>CAPITemplate</code> objects to <code>GitOpsTemplate</code> with some small tweaks.</p> <p>Info</p> <p>GitOpsTemplate or CAPITemplate?</p> <p>The only difference between <code>CAPITemplate</code> and <code>GitOpsTemplate</code> is the default value of these two annotations:</p> Annotation default value for <code>CAPITemplate</code> default value for <code>GitOpsTemplate</code> <code>templates.weave.works/add-common-bases</code> <code>\"true\"</code> <code>\"false\"</code> <code>templates.weave.works/inject-prune-annotations</code> <code>\"true\"</code> <code>\"false\"</code>"},{"location":"gitops-templates/cli/#installation","title":"Installation","text":"<p>See the Weave Gitops Enterprise installation instructions for details on how to install the EE <code>gitops</code> CLI tool.</p>"},{"location":"gitops-templates/cli/#getting-started","title":"Getting started","text":"<p>Using a local <code>GitOpsTemplate</code> manifest with required parameters exported in the environment, the command can render the template to one of the following: 1. The current kubecontext directly (default) 1. stdout with <code>--export</code> 1. The local file system with <code>--output-dir</code>, this will use the     <code>spec.resourcestemplates[].path</code> fields in the template to determine where to     write the rendered files.     This is the recommended approach for GitOps as you can then commit the     rendered files to your repository.</p> <pre><code>gitops create template \\\n--template-file capd-template.yaml \\\n--output-dir ./clusters/ \\\n--values CLUSTER_NAME=foo\n</code></pre>"},{"location":"gitops-templates/cli/#profiles","title":"Profiles","text":"<p>As in the UI you can add profiles to your template. However instead of reading the latest version of a profile and its layers from a <code>HelmRepository</code> object in the cluster, we instead read from your local helm cache.</p> <pre><code>helm repo add weaveworks-charts https://raw.githubusercontent.com/weaveworks/weave-gitops-profile-examples/gh-pages\nhelm repo update\n</code></pre> <p>This particular helm repo provides a version of the <code>cert-manager</code> repo and others.</p>"},{"location":"gitops-templates/cli/#supplying-values-to-a-profile","title":"Supplying values to a profile","text":"<p>You can supply a <code>values.yaml</code> file to a profile using the <code>values</code> parameter. For example we can supply <code>cert-manager</code>'s <code>values.yaml</code> with:</p> <pre><code>gitops create template \\\n--template-file capd-template.yaml \\\n--output-dir ./out \\\n--values CLUSTER_NAME=foo \\\n--profiles \"name=cert-manager,namespace=foo,version=&gt;0.1,values=cert-manager-values.yaml\"\n</code></pre>"},{"location":"gitops-templates/cli/#using-a-config-file","title":"Using a config file","text":"<p>Instead of specifying the parameters on the command line you can supply a config file. For example the above invocation can be replaced like so:</p> <p>```yaml title=config.yaml template-file: capd-capi-template.yaml output-dir: ./out values:   - CLUSTER_NAME=foo profiles:   - name=cert-manager,namespace=foo,version=&gt;0.1,values=cert-manager-values.yaml <pre><code>and executed with:\n\n```bash\ngitops create template --config config.yaml\n</code></pre></p>"},{"location":"gitops-templates/create-cluster-example/","title":"CAPI Cluster Template Example ENTERPRISE","text":"<p>GitOps template objects need to be wrapped with the <code>GitOpsTemplate</code> custom resource and then loaded into the management cluster.</p> <pre><code>apiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: cluster-template-development\nlabels:\nweave.works/template-type: cluster\nspec:\ndescription: This is the std. CAPD template\nrenderType: templating\nparams:\n- name: CLUSTER_NAME\ndescription: This is used for the cluster naming.\nresourcetemplates:\n- apiVersion: cluster.x-k8s.io/v1alpha3\nkind: Cluster\nmetadata:\nname: \"{{ .params.CLUSTER_NAME }}\"\n</code></pre>"},{"location":"gitops-templates/creating-templates/","title":"Creating GitOpsTemplates ENTERPRISE","text":"<p>Tip</p> <p>For complete examples of widely-used templates, see the Quickstart guide.</p> <p>GitOps Templates were originally introduced to enable self-service operations for the the cluster creation workflow.</p> <p>We have since extended this capability to cover Terraform, Crossplane and general Kubernetes resources.</p> <p>An example template could, upon merging to a GitOps repository and reconciling in a cluster, provide a running developer environment consisting of an EKS cluster, an RDS database, and a branch and revision of the current application through single template.</p> <p>Templates can be loaded into the cluster by Platform Operator by adding them to the Flux-manage GitOps repository for the target cluster. Alternatively, they can be applied directly to the cluster with <code>kubectl</code>.</p> <p>Info</p> <p>Weave GitOps will search for templates in the <code>default</code> namespace. This can be changed by configuring the <code>config.capi.namespace</code> value in the Weave GitOps Enterprise Helm Chart.</p>"},{"location":"gitops-templates/creating-templates/#template-type","title":"Template Type","text":"<p>Template types are used by Weave GitOps to group the templates nicely in the Dashboard UI.</p> <p>There are 4 recommended template types:</p> <ul> <li><code>application</code> - for application templates</li> <li><code>cluster</code> - for cluster templates</li> <li><code>terraform</code> - for Terraform templates</li> <li><code>pipeline</code> - for Pipeline templates</li> </ul> <p>Declare this in the object manifest by using the <code>weave.works/template-type</code> label and setting the value as the name of the type.</p> <pre><code>---\napiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: example-template\nnamespace: default\nlabels:\nweave.works/template-type: pipeline\nspec:\n# ...\n</code></pre>"},{"location":"gitops-templates/creating-templates/#template-components","title":"Template Components","text":"<p>The rendering of certain component sections in a template can be enabled or disabled with annotations. The annotation keys are of the form <code>templates.weave.works/COMPONENT-enabled</code> and have <code>boolean</code> values.</p> <p>Supported components:</p> <ul> <li><code>profiles</code></li> <li><code>kustomizations</code></li> <li><code>credentials</code></li> </ul> <p>Example:</p> <pre><code>annotations:\ntemplates.weave.works/profiles-enabled: \"true\"\ntemplates.weave.works/kustomizations-enabled: \"false\"\ntemplates.weave.works/credentials-enabled: \"true\"\n</code></pre>"},{"location":"gitops-templates/creating-templates/#in-ui-template-editing","title":"In-UI Template Editing","text":"<p>When rendering a template, a <code>templates.weave.works/create-request</code> annotation is added by default to the first resource in the <code>resourcetemplates</code>.</p> <p>It can be added to any other resource by simply adding the annotation in empty form. This annotation holds information about which template generated the resource and the parameter values used as a json string.</p> <p>If the resource type is one of the following and has this annotation, an <code>Edit resource</code> button will appear in the GitOps UI which allows the editing of the resource by users, after which it will be re-rendered:</p> <ul> <li>Applications:</li> <li><code>HelmRelease</code></li> <li><code>Kustomization</code></li> <li>Sources:</li> <li><code>HelmRepository</code></li> <li><code>GitRepository</code></li> <li>Clusters:</li> <li><code>GitopsCluster</code></li> </ul> <p>Example:</p> <pre><code>spec:\nresourcetemplates:\n- apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: my-configmap\ndata:\nmy-key: my-value\n- apiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: HelmRepository\nmetadata:\n# This annotation will add an `Edit resource` button in the UI for this resource\nannotations:\ntemplates.weave.works/create-request: ''\nname: nginx\nnamespace: default\n</code></pre>"},{"location":"gitops-templates/params/","title":"Parameters ENTERPRISE","text":"<p>When users have chosen a template, they will be presented with a form to complete.</p> <p>This form will collect the specific resource configuration which they would like applied to their instance.</p> <p>Resource variables, or parameters, are set by the template author in the template object manifest under <code>spec.params</code>.</p>"},{"location":"gitops-templates/params/#required-params","title":"Required params","text":"<p>Some params are required for all resources as they will be used to generate paths for the eventually rendered resources.</p> <p>These are: - <code>CLUSTER_NAME</code> - <code>RESOURCE_NAME</code></p>"},{"location":"gitops-templates/params/#parameters-metadata","title":"Parameters metadata","text":"<p>The following metadata fields can be added for each parameter under <code>spec.params</code>. These will get rendered nicely in the UI form allowing users to understand what each field is for.</p> <ul> <li><code>name</code>: The variable name within the resource templates.</li> <li><code>description</code>: Description of the parameter. This will be rendered in both the UI     and CLI.</li> <li><code>options</code>: The list of possible values this parameter can be set to.</li> <li><code>required</code> -  Whether the parameter must contain a non-empty value.</li> <li><code>default</code> - Default value of the parameter.</li> </ul> <p>Example: <pre><code>spec:\nparams:\n- name: IP_ADDRESS\ndescription: 'The IP address of this service'\noptions: [1.2.3.4, 5.6.7.8]\ndefault: 1.2.3.4\n</code></pre></p>"},{"location":"gitops-templates/profiles/","title":"Adding Profiles to Templates ENTERPRISE","text":"<p>Profiles are enhanched Helm Charts which allow operators to make additional components either optional or required to developers using self-service templates.</p> <p>Default and required profiles can be added via the template <code>spec.charts</code> section.</p> <pre><code>spec:\ncharts:\nitems:\n- name: nginx\nversion: 1.0.0\ntargetNamespace: nginx\n- name: cert-manager\ntargetNamespace: cert-manager\n</code></pre> <p>A template with the above profiles would offer Application Developers the option to add <code>nginx</code> and <code>cert-manager</code> resources to their templated resources, ready for deployment to their cluster.</p>"},{"location":"gitops-templates/profiles/#profile-operator-settings","title":"Profile Operator Settings","text":"<p>Keys available in the <code>spec.charts</code> section and the template variables available to them.</p> Key Description Template vars <code>helmRepositoryTemplate.path</code> Path the <code>HelmRepository</code> will be written to <code>params</code> <code>items</code> list of charts to configure, see below <p>Keys available in the <code>spec.charts.items</code> entries and the template variables available to them.</p> Key Description Template vars <code>template.content</code> Full or partial <code>HelmRelease</code> CR template <code>params</code> <code>template.path</code> Path the HelmRelease will be written to <code>params</code> <code>chart</code> Shortcut to <code>HelmRelease.spec.chart.spec.chart</code> <code>version</code> Shortcut to <code>HelmRelease.spec.chart.spec.version</code> <code>targetNamespace</code> Shortcut to <code>HelmRelease.spec.targetNamespace</code> <code>values</code> Shortcut to <code>HelmRelease.spec.values</code> <code>params</code> <code>layer</code> Layer to install as <code>required</code> (default=false) Allow the user to de-select this profile <code>editable</code> (default=false) Allow the user to edit the values.yaml of this profile Expand for a complete yaml example <pre><code>spec:\ncharts:\nhelmRepositoryTemplate:\npath: clusters/${CLUSTER_NAME}/helm-repositories.yaml\nitems:\n- chart: cert-manager\nversion: v1.5.3\neditable: false\nrequired: true\nvalues:\ninstallCRDs: ${CERT_MANAGER_INSTALL_CRDS}\ntargetNamespace: cert-manager\nlayer: layer-1\ntemplate:\npath: clusters/${CLUSTER_NAME}/cert-manager.yaml\ncontent:\nmetadata:\nlabels:\napp.kubernetes.io/name: cert-manager\nspec:\nretries: ${CERT_MANAGER_RETRY_COUNT}\n</code></pre> <p>Tip</p> <p><code>template.content</code> will be merged over the top of a default <code>HelmRelease</code> CR so it does not need to be complete.</p>"},{"location":"gitops-templates/profiles/#declaring-profiles-with-annotations","title":"Declaring Profiles with Annotations","text":"<p>Deprecated feature</p> <p>Where possible please use the <code>spec.charts</code> section as detailed above to declare profiles.</p> <p>Profiles can also be included within templates by the <code>capi.weave.works/profile-INDEX</code> annotation.</p> <pre><code>annotations:\ncapi.weave.works/profile-0: '{\"name\": \"NAME\", \"version\": \"VERSION\", \"editable\": EDITABLE, \"namespace\": \"NAMESPACE\"}'\n</code></pre> <p>Where:</p> <ul> <li><code>name</code> - is the name of the profile in the default profiles repository</li> <li><code>version</code> - (optional) will choose the default version</li> <li><code>namespace</code> - (optional) is the default target namespace for the profile</li> <li><code>editable</code> - (optional, default=<code>false</code>), allow the user to de-select this profile, making it a default instead of a requirement.</li> </ul>"},{"location":"gitops-templates/quickstart-templates/","title":"Quickstart GitOps Templates ENTERPRISE","text":"<p><code>Quickstart</code> templates are <code>GitOpsTemplate</code>s that you could use when getting started with Weave Gitops Enterprise It aims to provide a simplified basic experience.</p>"},{"location":"gitops-templates/quickstart-templates/#getting-started","title":"Getting Started","text":"<p>The templates exist as a Helm Chart in the weave-gitops-quickstart github repo.</p> <p>To get started, add the following <code>HelmRelease</code> object to your Weave GitOps Enterprise configuration repo for your management cluster.</p> Expand to view <pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: GitRepository\nmetadata:\nname: weave-gitops-quickstart\nnamespace: flux-system\nspec:\ninterval: 10m0s\nref:\nbranch: main\nurl: https://github.com/weaveworks/weave-gitops-quickstart\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: quickstart-templates\nnamespace: flux-system\nspec:\nchart:\nspec:\nchart: \"quickstart-templates\"\nversion: \"&gt;=0.1.0\"\nsourceRef:\nkind: GitRepository\nname: weave-gitops-quickstart\nnamespace: flux-system\ninterval: 10m0s\n</code></pre> <p>Commit and merge the above file. Once the <code>HelmRelease</code> has been successfully deployed to your cluster, navigate to your Weave GitOps UI Dashboard. You will see that the <code>templates</code> Chart is now deployed to your cluster.</p> <p></p> <p>If you click on the <code>Templates</code> tab in the sidebar, you will see the Quickstart templates are now available for use:</p> <p></p>"},{"location":"gitops-templates/quickstart-templates/#available-templates","title":"Available Templates","text":"<p>The following pipeline templates have been made available on your Weave GitOps Enterprise instance:</p> <ul> <li><code>pipeline-view</code>: A template to create a sample pipeline to visualize a     <code>HelmRelease</code> application delivered to dev, test and prod environments.</li> <li><code>pipeline-promotion-resources</code>: A template to create the Flux Notification     Controller resources required for promoting applications via pipelines.</li> <li><code>pipeline-view-promote-by-cluster</code>: A template to create pipelines for hard     tenancy when applications are isolated by cluster.</li> <li><code>pipeline-view-promote-by-namespace</code>: A template to create pipelines for soft     tenancy when applications are isolated by namespace.</li> </ul>"},{"location":"gitops-templates/quickstart-templates/#using-gitopstemplates-as-a-platform-engineer","title":"Using <code>GitOpsTemplate</code>s as a Platform Engineer","text":"<p>The above Quickstart templates are designed to provide a practical getting started experience. We encourage Platform Operators to start off with these templates within their team to ramp up on using Weave GitOps.</p> <p>If the need arises later, operators can always expand on these templates to develop their own set of self-service capabilities.</p>"},{"location":"gitops-templates/quickstart-templates/#using-gitopstemplates-as-an-application-developer","title":"Using <code>GitOpsTemplate</code>s as an Application Developer","text":"<p>As a developer using Weave GitOps Enterprise, use the templates to explore GitOps's capabilities. For example, to create a pipeline for your application: use the above template provided by your Operations team to create required resources. Once they have been added to your GitOps repository, you can adapt the rendered resources to meet your needs.</p> <p>Want to contribute?</p> <p>The Quickstart templates are maintained by the Weave Gitops team. If you would like to make alterations, suggest fixes, or even contribute a new template which you find cool, just head to the repo and open a new issue or PR!</p>"},{"location":"gitops-templates/repo-rendered-paths/","title":"Rendered Template Paths ENTERPRISE","text":"<p>Template authors can configure the eventual locatation of the rendered template in the user's GitOps repository.</p> <p>This allows for more control over where different resources in the template are rendered.</p>"},{"location":"gitops-templates/repo-rendered-paths/#configuring-paths","title":"Configuring Paths","text":"<p>The path for rendered resources is configured via the <code>spec.resourcetemplates[].path</code> field.</p> <p>Important to note</p> <ul> <li>The path is relative to the repository root</li> <li>The path can be templated using params</li> </ul> Expand to see example <pre><code>spec:\nresourcetemplates:\n// highlight-next-line\n- path: clusters/${CLUSTER_NAME}/definition/cluster.yaml\ncontent:\n- apiVersion: cluster.x-k8s.io/v1alpha4\nkind: Cluster\nmetadata:\nname: ${CLUSTER_NAME}\n...\n- apiVersion: infrastructure.cluster.x-k8s.io/v1alpha4\nkind: AWSCluster\nmetadata:\nname: ${CLUSTER_NAME}\n...\n// highlight-next-line\n- path: clusters/${CLUSTER_NAME}/workloads/helmreleases.yaml\ncontent:\n- apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: ${CLUSTER_NAME}-nginx\n...\n- apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: ${CLUSTER_NAME}-cert-manager\n...\n</code></pre>"},{"location":"gitops-templates/repo-rendered-paths/#configuring-paths-for-charts","title":"Configuring paths for <code>charts</code>","text":"<p>The <code>spec.charts.helmRepositoryTemplate.path</code> and <code>spec.charts.items[].template.path</code> fields can be used to specify the paths of these resources:</p> <p>Example</p> <pre><code>spec:\ncharts:\nhelmRepositoryTemplate:\n// highlight-next-line\npath: clusters/${CLUSTER_NAME}/workloads/helm-repo.yaml\nitems:\n- chart: cert-manager\nversion: 0.0.8\ntemplate:\n// highlight-next-line\npath: clusters/${CLUSTER_NAME}/workloads/cert-manager.yaml\n</code></pre>"},{"location":"gitops-templates/repo-rendered-paths/#default-paths","title":"Default Paths","text":"<p>If the <code>spec.resourcetemplates[].path</code> is omitted, a default path for the rendered template is calculated.</p> <p>In this case some of the submitted params are used. Users must provide one of the following parameters: - <code>CLUSTER_NAME</code> - <code>RESOURCE_NAME</code></p> <p>To ensure users supply these values, set the parameters to <code>required</code> in the the template definition:</p> <pre><code>spec:\nparams:\n- name: RESOURCE_NAME\nrequired: true\n# or\n- name: CLUSTER_NAME\nrequired: true\n</code></pre> <p>Important</p> <p>The kustomization feature and the <code>add-common-bases</code> annotation feature always use a calculated default path. If you are using these features one of <code>CLUSTER_NAME</code> or <code>RESOURCE_NAME</code> must be provided, even if you specify a <code>path</code> for all the other resources in the template.</p> <p>The default path for a template has a few components: - From the params: <code>CLUSTER_NAME</code> or <code>RESOURCE_NAME</code>, required. - From the params: <code>NAMESPACE</code>, default: <code>default</code> - From <code>values.yaml</code> for the Weave GitOps Enterprise <code>mccp</code> chart: <code>values.config.capi.repositoryPath</code>, default: <code>clusters/management/clusters</code></p> <p>These are composed to create the path: <code>${repositoryPath}/${NAMESPACE}/${CLUSTER_OR_RESOURCE_NAME}.yaml</code></p> <p>Using the default values and supplying <code>CLUSTER_NAME</code> as <code>my-cluster</code> will result in the path: <code>clusters/management/clusters/default/my-cluster.yaml</code></p>"},{"location":"gitops-templates/resource-templates/","title":"Resource templates ENTERPRISE","text":"<p>Resource templates are used to create Kubernetes resources. They are defined in the <code>spec.resourcetemplates</code> section of the template.</p>"},{"location":"gitops-templates/resource-templates/#the-content-key","title":"The <code>content</code> key","text":"<p>The <code>content</code> key is used to define a list of resources:</p> <pre><code>spec:\nresourcetemplates:\n- content:\n- apiVersion: v1\nkind: Namespace\nmetadata:\nname: nginx\n- apiVersion: v1\nkind: Namespace\nmetadata:\nname: cert-manager\n</code></pre>"},{"location":"gitops-templates/resource-templates/#the-raw-key","title":"The <code>raw</code> key","text":"<p>The <code>raw</code> key is used to define a raw string that will written to the specified path.</p> <p>This can be useful to preserve comments or formatting in the rendered resource.</p> <pre><code>spec:\nresourcetemplates:\n- path: \"helm-release.yaml\"\nraw: |\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: podinfo\nnamespace: prod-github\nspec:\ninterval: 1m\nchart:\nspec:\nchart: podinfo\nversion: \"6.0.0\" # {\"$promotion\": \"flux-system:podinfo-github:prod\"}\nsourceRef:\nkind: HelmRepository\nname: podinfo\ninterval: 1m\n</code></pre> <p>Info</p> <ul> <li>The <code>raw</code> key is not compatible with the <code>content</code> key. Only one of the two can be used.</li> <li>The <code>raw</code> key data must still be a valid kubernetes unstructured object.</li> </ul>"},{"location":"gitops-templates/supported-langs/","title":"Supported Templating Languages ENTERPRISE","text":"<p>The following templating languages are supported: - envsubst (default) - templating</p> <p>Declare the templating language to be used to render the template by setting <code>spec.renderType</code>.</p>"},{"location":"gitops-templates/supported-langs/#envsubst","title":"Envsubst","text":"<p><code>envsubst</code>, which is short for 'environment substitution', uses envsubst for rendering. This templating format is used by clusterctl.</p> <p>Variables can be set for rendering into the template in the <code>${VAR_NAME}</code> syntax.</p>"},{"location":"gitops-templates/supported-langs/#supported-functions","title":"Supported Functions","text":"Expression Meaning <code>${var}</code> Value of <code>$var</code> <code>${#var}</code> String length of <code>$var</code> <code>${var^}</code> Uppercase first character of <code>$var</code> <code>${var^^}</code> Uppercase all characters in <code>$var</code> <code>${var,}</code> Lowercase first character of <code>$var</code> <code>${var,,}</code> Lowercase all characters in <code>$var</code> <code>${var:n}</code> Offset <code>$var</code> <code>n</code> characters from start <code>${var:n:len}</code> Offset <code>$var</code> <code>n</code> characters with max length of <code>len</code> <code>${var#pattern}</code> Strip shortest <code>pattern</code> match from start <code>${var##pattern}</code> Strip longest <code>pattern</code> match from start <code>${var%pattern}</code> Strip shortest <code>pattern</code> match from end <code>${var%%pattern}</code> Strip longest <code>pattern</code> match from end <code>${var-default}</code> If <code>$var</code> is not set, evaluate expression as <code>$default</code> <code>${var:-default}</code> If <code>$var</code> is not set or is empty, evaluate expression as <code>$default</code> <code>${var=default}</code> If <code>$var</code> is not set, evaluate expression as <code>$default</code> <code>${var:=default}</code> If <code>$var</code> is not set or is empty, evaluate expression as <code>$default</code> <code>${var/pattern/replacement}</code> Replace as few <code>pattern</code> matches as possible with <code>replacement</code> <code>${var//pattern/replacement}</code> Replace as many <code>pattern</code> matches as possible with <code>replacement</code> <code>${var/#pattern/replacement}</code> Replace <code>pattern</code> match with <code>replacement</code> from <code>$var</code> start <code>${var/%pattern/replacement}</code> Replace <code>pattern</code> match with <code>replacement</code> from <code>$var</code> end"},{"location":"gitops-templates/supported-langs/#templating","title":"Templating","text":"<p>Templating uses text/templating for rendering, using go-templating style syntax <code>{{ .params.CLUSTER_NAME }}</code> where params are provided by the <code>.params</code> variable. Template functions can also be used with the syntax <code>{{ .params.CLUSTER_NAME | FUNCTION }}</code>.</p>"},{"location":"gitops-templates/supported-langs/#supported-functions_1","title":"Supported Functions","text":"<p>As taken (from the Sprig library)</p> Function Type Functions String Functions trim, wrap, randAlpha, plural String List Functions splitList, sortAlpha Integer Math Functions add, max, mul Integer Slice Functions until, untilStep Float Math Functions addf, maxf, mulf Date Functions now, date Defaults Functions default, empty, coalesce, fromJson, toJson, toPrettyJson, toRawJson, ternary Encoding Functions b64enc, b64dec Lists and List Functions list, first, uniq Dictionaries and Dict Functions get, set, dict, hasKey, pluck, dig, deepCopy Type Conversion Functions atoi, int64, toString Flow Control Functions fail UUID Functions uuidv4 Version Comparison Functions semver, semverCompare Reflection typeOf, kindIs, typeIsLike"},{"location":"gitops-templates/supported-langs/#custom-delimiters","title":"Custom Delimiters","text":"<p>The default delimiters for <code>renderType: templating</code> are <code>{{</code> and <code>}}</code>. These can be changed by setting the <code>templates.weave.works/delimiters</code> annotation on the template. For example:</p> <ul> <li><code>templates.weave.works/delimiters: \"{{,}}\"</code> - default</li> <li><code>templates.weave.works/delimiters: \"${{,}}\"</code></li> <li>Use <code>${{</code> and <code>}}</code>, for example <code>\"${{ .params.CLUSTER_NAME }}\"</code></li> <li>Useful as <code>{{</code> in yaml is invalid syntax and needs to be quoted. If you need to provide a un-quoted number value like <code>replicas: 3</code> you should use these delimiters.         -  <code>replicas: {{ .params.REPLICAS }}</code> Invalid yaml         -  <code>replicas: \"{{ .params.REPLICAS }}\"</code> Valid yaml, incorrect type. The type is a <code>string</code> not a <code>number</code> and will fail validation.         -  <code>replicas: ${{ .params.REPLICAS }}</code> Valid yaml and correct <code>number</code> type.</li> <li><code>templates.weave.works/delimiters: \"&lt;&lt;,&gt;&gt;\"</code></li> <li>Use <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, for example <code>&lt;&lt; .params.CLUSTER_NAME &gt;&gt;</code></li> <li>Useful if you are nesting templates and need to differentiate between the delimiters used in the inner and outer templates.</li> </ul>"},{"location":"gitops-templates/versions/","title":"Version Information ENTERPRISE","text":"<p>There are now multiple published versions of the template CRD.</p>"},{"location":"gitops-templates/versions/#migration-notes","title":"Migration notes","text":""},{"location":"gitops-templates/versions/#v1alpha1-to-v1alpha2","title":"<code>v1alpha1</code> to <code>v1alpha2</code>","text":"<p>When manually migrating a template from <code>v1alpha1</code> to <code>v1alpha2</code> (for example in git) you will need to: 1. Update the <code>apiVersion</code>:     1. for <code>GitopsTemplate</code> update the apiVersion to <code>templates.weave.works/v1alpha2</code>     1. for <code>CAPITemplate</code> update the apiVersion to <code>capi.weave.works/v1alpha2</code> 1. Move the <code>spec.resourcetemplates</code> field to <code>spec.resourcetemplates[0].content</code> 1. Either leave the <code>spec.resourcetemplates[0].path</code> field empty or give it a sensible value.</p> <p>If you experience issues with the path not being recognised when Flux reconciles the new template versions, try manually applying the new template to the cluster directly with: 1. Run <code>kubectl apply -f capi-template.yaml</code> 1. Run <code>flux reconcile kustomization --with-source flux-system</code> twice.</p>"},{"location":"gitops-templates/versions/#conversion-webhook","title":"Conversion Webhook","text":"<p>As of Weave Gitops Enterprise 0.28.0 the conversion webhook has been removed.</p> <p>This removed the need for cert-manager to be installed, but you will now have to convert any <code>v1alpha1</code> templates to <code>v1alpha2</code> manually in git.</p>"},{"location":"gitops-templates/versions/#v1alpha2-default-notes","title":"<code>v1alpha2</code> (default) notes","text":"<p>This version changes the type of <code>spec.resourcetemplates</code> from a list of objects to a list of files with a <code>path</code> and <code>content</code>:</p> <p>Example: <pre><code>spec:\nresourcetemplates:\n- path: \"clusters/{{ .params.CLUSTER_NAME }}.yaml\"\ncontent:\n- apiVersion: cluster.x-k8s.io/v1alpha3\nkind: Cluster\nmetadata:\nname: \"{{ .params.CLUSTER_NAME }}\"\npath: \"clusters/{{ .params.CLUSTER_NAME }}.yaml\"\n</code></pre></p>"},{"location":"gitops-templates/versions/#v1alpha1-notes","title":"<code>v1alpha1</code> notes","text":"<p>The original version of the template. This version no longer works with Weave Gitops Enterprise 0.28.0 and above.</p> <p>It uses <code>spec.resourcetemplates</code> as a list of resources to render.</p> <p>Example: <pre><code>spec:\nresourcetemplates:\n- apiVersion: cluster.x-k8s.io/v1alpha3\nkind: Cluster\nmetadata:\nname: \"{{ .params.CLUSTER_NAME }}\"\n</code></pre></p>"},{"location":"gitopssets/","title":"GitOpsSets ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change</p> <p>We're very excited for people to use this feature. However, please note that some changes will be made to the API and behavior, particularly to enhance security by implementing impersonation for more fine-grained control over how the generated resources are applied.</p>"},{"location":"gitopssets/#introduction","title":"Introduction","text":"<p>GitOpsSets enable Platform Operators to have a single definition for an application for multiple environments and a fleet of clusters. A single definition can be used to generate the environment and cluster-specific configuration.</p> <p>As an example, we can take an application that needs to be deployed to various environments (Dev, Test, Prod) built by a fleet of clusters. Each of those environments + clusters requires a specialized configuration powering the same Application. With GitOpsSets and the generators you just declare the template you want to use, the selector that will match the cluster of the inventory, and where to get the special configuration. </p> <p>GitOpsSets will create out of the single resource all the objects and Flux primitives that are required to successfully deploy this application. An operation that required the editing of hundreds of files can now be done with a single command. </p> <p>The initial generators that are coming with the preview release are:</p> <ul> <li>List Generator: The simplest generator. Provide a list of Key/Value pairs that you want to feed the template with.</li> <li>Git Generator: Enables you to extract a set of files (environment-specific configurations) from a Flux GitRepository and make their contents available to the templates. This lets you have config in app-dev.json, app-staging.json, and app-production.json, for example.</li> <li>Matrix Generator: Combine slices of generators into the desired compounded input.</li> <li>Pull request Generator: Automatically discover open pull requests within a repository to generate a new deployment.</li> <li>API Client Generator: Poll an HTTP endpoint and parse the result as the generated values.</li> <li>OCI Repository</li> <li>Cluster</li> <li>ImagePolicy</li> <li>Config</li> </ul>"},{"location":"gitopssets/#use-cases","title":"Use Cases","text":"<ul> <li>Single application definition for different environments (EU-West, North America, Germany)</li> <li>Deployment of a single definition across fleet of clusters matching any cluster based on a label (Production) </li> <li>Separation of concerns between teams (teams managing different artifacts flowing into a single definition via generators)</li> </ul>"},{"location":"gitopssets/_api/","title":"api","text":"<p>Packages:</p> <ul> <li> templates.weave.works/v1alpha1 </li> </ul>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1","title":"templates.weave.works/v1alpha1","text":"<p>Package v1alpha1 contains API Schema definitions for the gitopssets v1alpha1 API group</p> <p>Resource Types:</p> <ul><li> GitOpsSet </li></ul>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitOpsSet","title":"GitOpsSet","text":"<p>GitOpsSet is the Schema for the gitopssets API</p> Field Description <code>apiVersion</code> string <code>templates.weave.works/v1alpha1</code> <code>kind</code> string  <code>GitOpsSet</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  GitOpsSetSpec  <code>suspend</code>  bool  (Optional) <p>Suspend tells the controller to suspend the reconciliation of this GitOpsSet.</p> <code>generators</code>  []GitOpsSetGenerator  <p>Generators generate the data to be inserted into the provided templates.</p> <code>templates</code>  []GitOpsSetTemplate  <p>Templates are a set of YAML templates that are rendered into resources from the data supplied by the generators.</p> <code>serviceAccountName</code>  string  (Optional) <p>The name of the Kubernetes service account to impersonate when reconciling this Kustomization.</p> <code>status</code>  GitOpsSetStatus"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.APIClientGenerator","title":"APIClientGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>APIClientGenerator defines a generator that queries an API endpoint and uses that to generate data.</p> Field Description <code>interval</code>  Kubernetes meta/v1.Duration  <p>The interval at which to poll the API endpoint.</p> <code>endpoint</code>  string  (Optional) <p>This is the API endpoint to use.</p> <code>method</code>  string  <p>Method defines the HTTP method to use to talk to the endpoint.</p> <code>jsonPath</code>  string  <p>JSONPath is string that is used to modify the result of the API call.</p> <p>This can be used to extract a repeating element from a response. https://kubernetes.io/docs/reference/kubectl/jsonpath/</p> <code>headersRef</code>  HeadersReference  (Optional) <p>HeadersRef allows optional configuration of a Secret or ConfigMap to add additional headers to an outgoing request.</p> <p>For example, a Secret with a key Authorization: Bearer abc123 could be used to configure an authorization header.</p> <code>body</code>  Kubernetes pkg/apis/apiextensions/v1.JSON  (Optional) <p>Body is set as the body in a POST request.</p> <p>If set, this will configure the Method to be POST automatically.</p> <code>singleElement</code>  bool  (Optional) <p>SingleElement means generate a single element with the result of the API call.</p> <p>When true, the response must be a JSON object and will be returned as a single element, i.e. only one element will be generated containing the entire object.</p> <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>Reference to Secret in same namespace with a field \u201ccaFile\u201d which provides the Certificate Authority to trust when making API calls.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.ClusterGenerator","title":"ClusterGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>ClusterGenerator defines a generator that queries the cluster API for relevant clusters.</p> Field Description <code>selector</code>  Kubernetes meta/v1.LabelSelector  (Optional) <p>Selector is used to filter the clusters that you want to target.</p> <p>If no selector is provided, no clusters will be matched.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.ConfigGenerator","title":"ConfigGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>ConfigGenerator loads a referenced ConfigMap or Secret from the Cluster and makes it available as a resource.</p> Field Description <code>kind</code>  string  <p>Kind of the referent.</p> <code>name</code>  string  <p>Name of the referent.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitOpsSetGenerator","title":"GitOpsSetGenerator","text":"<p> (Appears on: GitOpsSetSpec) </p> <p>GitOpsSetGenerator is the top-level set of generators for this GitOpsSet.</p> Field Description <code>list</code>  ListGenerator  <code>pullRequests</code>  PullRequestGenerator  <code>gitRepository</code>  GitRepositoryGenerator  <code>ociRepository</code>  OCIRepositoryGenerator  <code>matrix</code>  MatrixGenerator  <code>cluster</code>  ClusterGenerator  <code>apiClient</code>  APIClientGenerator  <code>imagePolicy</code>  ImagePolicyGenerator  <code>config</code>  ConfigGenerator"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitOpsSetNestedGenerator","title":"GitOpsSetNestedGenerator","text":"<p> (Appears on: MatrixGenerator) </p> <p>GitOpsSetNestedGenerator describes the generators usable by the MatrixGenerator. This is a subset of the generators allowed by the GitOpsSetGenerator because the CRD format doesn\u2019t support recursive declarations.</p> Field Description <code>name</code>  string  (Optional) <p>Name is an optional field that will be used to prefix the values generated by the nested generators, this allows multiple generators of the same type in a single Matrix generator.</p> <code>list</code>  ListGenerator  <code>gitRepository</code>  GitRepositoryGenerator  <code>ociRepository</code>  OCIRepositoryGenerator  <code>pullRequests</code>  PullRequestGenerator  <code>cluster</code>  ClusterGenerator  <code>apiClient</code>  APIClientGenerator  <code>imagePolicy</code>  ImagePolicyGenerator  <code>config</code>  ConfigGenerator"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitOpsSetSpec","title":"GitOpsSetSpec","text":"<p> (Appears on: GitOpsSet) </p> <p>GitOpsSetSpec defines the desired state of GitOpsSet</p> Field Description <code>suspend</code>  bool  (Optional) <p>Suspend tells the controller to suspend the reconciliation of this GitOpsSet.</p> <code>generators</code>  []GitOpsSetGenerator  <p>Generators generate the data to be inserted into the provided templates.</p> <code>templates</code>  []GitOpsSetTemplate  <p>Templates are a set of YAML templates that are rendered into resources from the data supplied by the generators.</p> <code>serviceAccountName</code>  string  (Optional) <p>The name of the Kubernetes service account to impersonate when reconciling this Kustomization.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitOpsSetStatus","title":"GitOpsSetStatus","text":"<p> (Appears on: GitOpsSet) </p> <p>GitOpsSetStatus defines the observed state of GitOpsSet</p> Field Description <code>ReconcileRequestStatus</code>  github.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus  <p> (Members of <code>ReconcileRequestStatus</code> are embedded into this type.) </p> <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the last observed generation of the HelmRepository object.</p> <code>conditions</code>  []Kubernetes meta/v1.Condition  (Optional) <p>Conditions holds the conditions for the GitOpsSet</p> <code>inventory</code>  ResourceInventory  (Optional) <p>Inventory contains the list of Kubernetes resource object references that have been successfully applied</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitOpsSetTemplate","title":"GitOpsSetTemplate","text":"<p> (Appears on: GitOpsSetSpec) </p> <p>GitOpsSetTemplate describes a resource to create</p> Field Description <code>repeat</code>  string  <p>Repeat is a JSONPath string defining that the template content should be repeated for each of the matching elements in the JSONPath expression. https://kubernetes.io/docs/reference/kubectl/jsonpath/</p> <code>content</code>  k8s.io/apimachinery/pkg/runtime.RawExtension  <p>Content is the YAML to be templated and generated.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.GitRepositoryGenerator","title":"GitRepositoryGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>GitRepositoryGenerator generates from files in a Flux GitRepository resource.</p> Field Description <code>repositoryRef</code>  string  <p>RepositoryRef is the name of a GitRepository resource to be generated from.</p> <code>files</code>  []RepositoryGeneratorFileItem  <p>Files is a set of rules for identifying files to be parsed.</p> <code>directories</code>  []RepositoryGeneratorDirectoryItem  <p>Directories is a set of rules for identifying directories to be generated.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.HeadersReference","title":"HeadersReference","text":"<p> (Appears on: APIClientGenerator) </p> <p>HeadersReference references either a Secret or ConfigMap to be used for additional request headers.</p> Field Description <code>kind</code>  string  <p>The resource kind to get headers from.</p> <code>name</code>  string  <p>Name of the resource in the same namespace to apply headers from.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.ImagePolicyGenerator","title":"ImagePolicyGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>ImagePolicyGenerator generates from the ImagePolicy.</p> Field Description <code>policyRef</code>  string  <p>PolicyRef is the name of a ImagePolicy resource to be generated from.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.ListGenerator","title":"ListGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>ListGenerator generates from a hard-coded list.</p> Field Description <code>elements</code>  []Kubernetes pkg/apis/apiextensions/v1.JSON"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.MatrixGenerator","title":"MatrixGenerator","text":"<p> (Appears on: GitOpsSetGenerator) </p> <p>MatrixGenerator defines a matrix that combines generators. The matrix is a cartesian product of the generators.</p> Field Description <code>generators</code>  []GitOpsSetNestedGenerator  <p>Generators is a list of generators to be combined.</p> <code>singleElement</code>  bool  (Optional) <p>SingleElement means generate a single element with the result of the merged generator elements.</p> <p>When true, the matrix elements will be merged to a single element, with whatever prefixes they have. It\u2019s recommended that you use the Name field to separate out elements.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.OCIRepositoryGenerator","title":"OCIRepositoryGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>OCIRepositoryGenerator generates from files in a Flux OCIRepository resource.</p> Field Description <code>repositoryRef</code>  string  <p>RepositoryRef is the name of a OCIRepository resource to be generated from.</p> <code>files</code>  []RepositoryGeneratorFileItem  <p>Files is a set of rules for identifying files to be parsed.</p> <code>directories</code>  []RepositoryGeneratorDirectoryItem  <p>Directories is a set of rules for identifying directories to be generated.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.PullRequestGenerator","title":"PullRequestGenerator","text":"<p> (Appears on: GitOpsSetGenerator,  GitOpsSetNestedGenerator) </p> <p>PullRequestGenerator defines a generator that queries a Git hosting service for relevant PRs.</p> Field Description <code>interval</code>  Kubernetes meta/v1.Duration  <p>The interval at which to check for repository updates.</p> <code>driver</code>  string  <p>Determines which git-api protocol to use.</p> <code>serverURL</code>  string  (Optional) <p>This is the API endpoint to use.</p> <code>repo</code>  string  <p>This should be the Repo you want to query. e.g. my-org/my-repo</p> <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>Reference to Secret in same namespace with a field \u201cpassword\u201d which is an auth token that can query the Git Provider API.</p> <code>labels</code>  []string  (Optional) <p>Labels is used to filter the PRs that you want to target. This may be applied on the server.</p> <code>forks</code>  bool  (Optional) <p>Fork is used to filter out forks from the target PRs if false, or to include forks if  true</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.RepositoryGeneratorDirectoryItem","title":"RepositoryGeneratorDirectoryItem","text":"<p> (Appears on: GitRepositoryGenerator,  OCIRepositoryGenerator) </p> <p>RepositoryGeneratorDirectoryItem stores the information about a specific directory to be generated from.</p> Field Description <code>path</code>  string  <code>exclude</code>  bool"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.RepositoryGeneratorFileItem","title":"RepositoryGeneratorFileItem","text":"<p> (Appears on: GitRepositoryGenerator,  OCIRepositoryGenerator) </p> <p>RepositoryGeneratorFileItem defines a path to a file to be parsed when generating.</p> Field Description <code>path</code>  string  <p>Path is the name of a file to read and generate from can be JSON or YAML.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.ResourceInventory","title":"ResourceInventory","text":"<p> (Appears on: GitOpsSetStatus) </p> <p>ResourceInventory contains a list of Kubernetes resource object references that have been applied by a Kustomization.</p> Field Description <code>entries</code>  []ResourceRef  <p>Entries of Kubernetes resource object references.</p>"},{"location":"gitopssets/_api/#templates.weave.works/v1alpha1.ResourceRef","title":"ResourceRef","text":"<p> (Appears on: ResourceInventory) </p> <p>ResourceRef contains the information necessary to locate a resource within a cluster.</p> Field Description <code>id</code>  string  <p>ID is the string representation of the Kubernetes resource object\u2019s metadata, in the format \u2018namespace_name_group_kind\u2019.</p> <code>v</code>  string  <p>Version is the API version of the Kubernetes resource object\u2019s kind.</p> <p>This page was automatically generated with <code>gen-crd-api-reference-docs</code></p>"},{"location":"gitopssets/api-reference/","title":"API reference","text":"<p>import GeneratedAPI from './_api.md'; import apiToc from './_api-toc.json'; export const toc = apiToc;</p> <p></p>"},{"location":"gitopssets/gitopssets-api-reference/","title":"API reference","text":"<p>import GeneratedAPI from './_api.md'; import apiToc from './_api-toc.json'; export const toc = apiToc;</p> <p></p>"},{"location":"gitopssets/gitopssets-installation/","title":"Installation ENTERPRISE","text":"<p>The gitopssets-controller can be installed in two ways:</p> <ul> <li>As part of the Weave GitOps Enterprise installation. (installed by default)</li> <li>As a standalone installation using a Helm chart.</li> </ul> <p>The standalone installation can be useful for leaf clusters that don't have Weave GitOps Enterprise installed.</p>"},{"location":"gitopssets/gitopssets-installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing the gitopssets-controller, ensure that you've installed Flux.</p>"},{"location":"gitopssets/gitopssets-installation/#installing-the-gitopssets-controller","title":"Installing the gitopssets-controller","text":"<p>To install the gitopssets-controller using a Helm chart, use the following HelmRelease:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: gitopssets-system\n---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: weaveworks-oci-charts\nnamespace: gitopssets-system\nspec:\ninterval: 1m\ntype: oci\nurl: oci://ghcr.io/weaveworks/charts\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: gitopssets-controller\nnamespace: gitopssets-system\nspec:\ninterval: 10m\nchart:\nspec:\nchart: gitopssets-controller\nsourceRef:\nkind: HelmRepository\nname: weaveworks-oci-charts\nnamespace: gitopssets-system\nversion: 0.15.3\ninstall:\ncrds: CreateReplace\nupgrade:\ncrds: CreateReplace\n</code></pre> <p>After adding the Namespace, HelmRepository and HelmRelease to a Git repository synced by Flux, commit the changes to complete the installation process.</p>"},{"location":"gitopssets/gitopssets-installation/#customising-the-generators","title":"Customising the Generators","text":"<p>Not all generators are enabled by default, this is because not all CRDs are required by the generators.</p> <p>You might want to enable or disable individual generators via the Helm Chart:</p> <pre><code>gitopssets-controller:\nenabled: true\ncontrollerManager:\nmanager:\nargs:\n- --health-probe-bind-address=:8081\n- --metrics-bind-address=127.0.0.1:8080\n- --leader-elect\n# enable the cluster generator which is not enabled by default\n- --enabled-generators=GitRepository,Cluster,PullRequests,List,APIClient,Matrix,Config\n</code></pre>"},{"location":"gitopssets/gitopssets-releases/","title":"Gitopssets Controller Releases ENTERPRISE","text":""},{"location":"gitopssets/gitopssets-releases/#v0161","title":"v0.16.1","text":"<p>2023-09-06</p> <ul> <li>Bump client-go to 0.26.8 - avoids a buggy version of the upstream client   package</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0160","title":"v0.16.0","text":"<p>2023-09-05</p> <ul> <li>Fix partial-apply resources bug - errors generating resources could lead to   incomplete inventories and errors when regenerating resources</li> <li>Bump the memory limits for the Helm chart and document that these may need to   be increased.</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0153","title":"v0.15.3","text":"<p>2023-08-17</p> <ul> <li>Fix bug when a Matrix generator doesn't generate any elements.</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0152","title":"v0.15.2","text":"<p>2023-08-17</p> <ul> <li>Update the ImagePolicy generator to add the image by splitting the image from   the tag.</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0151","title":"v0.15.1","text":"<p>2023-08-17</p> <ul> <li>Fix bug in the processing of empty artifacts in GitRepositories and   OCIRepositories - the directory listing will also return the special empty   marker when the Repository is empty.</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0150","title":"v0.15.0","text":"<p>2023-08-10</p> <ul> <li>ClusterGenerator - return labels as generic maps - this makes it easier to   query for labels in a map.</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0141","title":"v0.14.1","text":"<p>2023-07-26</p> <ul> <li>When a GitRepository or OCIRepository artifact is empty, handle this as a   special case that doesn't mean \"no resources\" this prevents removal of   resources when the Flux resource hasn't populated yet.</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0140","title":"v0.14.0","text":"<p>2023-07-14</p> <ul> <li>Support multidoc when rendering via the CLI tool</li> <li>Allow custom CAs for the APIGenerator HTTPClient</li> <li>Single element Matrix generation - compress multiple Matrix elements into a   single element</li> <li>Implement element index and repeat index</li> <li>Local GitRepository generation from the filesystem in the CLI tool</li> <li>Implement OCIGenerator - functionally very similar to the GitRepository   generator</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0133","title":"v0.13.3","text":"<p>2023-06-26</p> <ul> <li>Secrets are now provided in Elements as strings rather than byte slices</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0131","title":"v0.13.1","text":"<p>2023-06-21</p> <ul> <li>Expose the latest tag not just the latest image in the ImageRepository</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0130","title":"v0.13.0","text":"<p>2023-06-20</p> <ul> <li>Fix bug in matrix generator when updating GitRepository resources</li> <li>Config generator - track Secrets and ConfigMaps and generate from them</li> <li>CLI tool for rendering GitOpsSets</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0120","title":"v0.12.0","text":"<p>2023-05-24</p> <ul> <li>Allow altering the delimiters</li> <li>Imagerepository generator by @bigkevmcd in #71</li> <li>Allow cross-namespace resources</li> <li>Upgrade the matrix to support \"unlimited\" numbers of generators</li> <li>Add support for Flux annotation triggered rereconciliation</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0110","title":"v0.11.0","text":"<p>2023-05-10</p> <ul> <li>Support for using the <code>repeat</code> mechanism within maps not just arrays</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v0100","title":"v0.10.0","text":"<p>2023-04-28</p> <ul> <li>Bump to support Flux v2</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v090","title":"v0.9.0","text":"<p>2023-04-27</p> <ul> <li>Fail if we cannot find a relevant generator</li> <li>Suppress caching of Secrets and ConfigMaps</li> <li>Improve APIClient error message</li> <li>Support correctly templating numbers - insertion of numeric values is improved</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v080","title":"v0.8.0","text":"<p>2023-04-13</p> <ul> <li>Add events recording to GitOpsSets</li> <li>Fix updating of ConfigMaps</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v070","title":"v0.7.0","text":"<p>2023-03-30</p> <ul> <li>Implement custom delimiters</li> </ul>"},{"location":"gitopssets/gitopssets-releases/#v061","title":"v0.6.1","text":"<p>2023-03-20</p> <ul> <li>Implement optional list expansion</li> </ul>"},{"location":"gitopssets/templating-from-generators/","title":"Templating from Generators","text":""},{"location":"gitopssets/templating-from-generators/#basics","title":"Basics","text":"<p>Currently rendering templates operates in two phases:</p> <ul> <li>Generate all template parameters from the configured generators</li> <li>Render all the templates for each set of template parameters</li> </ul> <p>Please read the security information below before using this.</p>"},{"location":"gitopssets/templating-from-generators/#general-behaviour","title":"General behaviour","text":"<p>GitOpsSets can be suspended, by setting the <code>spec.suspend</code> flag to be true.</p> <p>When this is the case, updates will not be applied, no resources created or deleted.</p> <p>In addition, a manual reconciliation can be requested by annotating a GitOpsSet with the <code>reconcile.fluxcd.io/requestedAt</code> annotation.</p>"},{"location":"gitopssets/templating-from-generators/#generation","title":"Generation","text":"<p>The simplest generator is the <code>List</code> generator.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: gitopsset-sample\nspec:\ngenerators:\n- list:\nelements:\n- env: dev\nteam: dev-team\n- env: production\nteam: ops-team\n- env: staging\nteam: ops-team\n</code></pre> <p>The elements in there are a set JSON of objects[^yaml], there are three in this example, and each of them has two keys, <code>env</code> and <code>team</code>.</p> <p>Other generators provide different sets of keys and values.</p> <p>The generators documentation below provides more information on what the other generators output.</p>"},{"location":"gitopssets/templating-from-generators/#rendering-templates","title":"Rendering templates","text":"<p>Templates are Kubernetes resources in YAML format.</p> <p>Each template is rendered for each element generated by the generators.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: gitopsset-sample\nspec:\ngenerators:\n- list:\nelements:\n- env: dev\nteam: dev-team\n- env: production\nteam: ops-team\n- env: staging\nteam: ops-team\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.env }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.env }}\"\ncom.example/team: \"{{ .Element.team }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre> <p>The generated elements are provided to the template in the <code>Element</code> scope, so <code>.Element.dev</code> refers to the <code>dev</code> field from the List element.</p> <p>The output from all generators is exposed in the <code>Element</code> scope, not just List generators.</p> <p>In addition to the <code>.Element</code> field, a <code>.ElementIndex</code> is also available, this represents the zero-based index into the set of generated elements.</p> <p>NOTE: It's not recommended that you use this to name resources where the ordering of the queries for generating the elements is not guaranteed to be ordered, otherwise you could generate churn in resources as we look for resources by name when updating them, so, <code>.ElementIndex</code> 1 may not be the same as <code>.ElementIndex</code> 1 was the previous time, and this could cause resources to be updated unnecessarily with undesirable effects.</p>"},{"location":"gitopssets/templating-from-generators/#repeating-templates","title":"Repeating templates","text":"<p>The output from a generator is an array of JSON objects[^yaml], the keys of which can contain repeating elements, either further JSON objects, or scalar values.</p> <p>It can be desirable to repeat a template for a repeated element in a generated value.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: repeated-gitopsset-sample\nspec:\ngenerators:\n- list:\nelements:\n- env: dev\nteam: dev-team\nteams:\n- name: \"team1\"\n- name: \"team2\"\n- name: \"team3\"\n- env: staging\nteam: staging-team\nteams:\n- name: \"team4\"\n- name: \"team5\"\n- name: \"team6\"\ntemplates:\n- repeat: \"{ .teams }\"\ncontent:\nkind: ConfigMap\napiVersion: v1\nmetadata:\nname: \"{{ .Repeat.name }}-demo\"\ndata:\nname: \"{{ .Repeat.name }}-demo\"\nteam: \"{{ .Element.team }}\"\n</code></pre> <p>The template <code>repeat</code> field is a JSONPath expression that is applied to each element during the template rendering.</p> <p>Templates that use <code>repeat</code> will have two separate scopes for the template params, <code>.Element</code> which is the top-level element generated by the generator, and the additional <code>.Repeat</code> scope, which is the repeating element.</p> <p>In this case, six different <code>ConfigMaps</code> are generated, three for the \"dev-team\" and three for the \"staging-team\".</p> <p>As with the <code>.ElementIndex</code>, for repeated elements both <code>.ElementIndex</code> and <code>.RepeatIndex</code> are available.</p>"},{"location":"gitopssets/templating-from-generators/#delimiters","title":"Delimiters","text":"<p>The default delimiters for the template engine are <code>{{</code> and <code>}}</code>, which is the same as the Go template engine.</p> <p>These can be changed by adding an annotation to the <code>GitOpsSet</code>:</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: gitopsset-sample\nannotations:\ntemplates.weave.works/delimiters: \"${{,}}\"\n</code></pre> <p>Changing the delimiters can useful for:</p> <ul> <li>Nesting GitopsSets within each other, as the default delimiters will conflict</li> <li>Providing unquoted values to yaml</li> </ul>"},{"location":"gitopssets/templating-from-generators/#unquoted-values","title":"Unquoted values","text":"<p>In yaml <code>{{</code> is invalid syntax and needs to be quoted. If you need to provide a un-quoted number value like <code>replicas: 3</code> you should use the <code>${{,}}</code> delimiters.</p> <ul> <li>\u274c <code>replicas: {{ .params.REPLICAS }}</code> Invalid yaml</li> <li>\u274c <code>replicas: \"{{ .params.REPLICAS }}\"</code> Valid yaml, incorrect type. The type is a string not a number and will fail validation.</li> <li>\u2705 <code>replicas: ${{ .params.REPLICAS }}</code> Valid yaml and correct number type.</li> </ul> <p>Unquoted values allow you to include objects in your templates too.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: gitopsset-sample\nannotations:\ntemplates.weave.works/delimiters: \"${{,}}\"\nspec:\ngenerators:\n- list:\nelements:\n- env: dev\nresources:\nlimits:\ncpu: 100m\nmemory: 128Mi\n- env: staging\nresources:\nlimits:\ncpu: 100m\nmemory: 128Mi\ntemplates:\n- content:\nkind: Deployment\napiVersion: apps/v1\nmetadata:\nname: go-demo\nspec:\ntemplate:\nspec:\ncontainers:\n- name: go-demo\nimage: weaveworks/go-demo:0.2.0\nresources: ${{ .Element.resources | toJson }}\n</code></pre> <p>With the default <code>{{,}}</code> delimiters this would fail as the \"resources\" field would need to be quoted.</p> <p>Again, if we quote them we would get a string value, not an object.</p>"},{"location":"gitopssets/templating-from-generators/#generators","title":"Generators","text":"<p>We currently provide these generators: - list - pullRequests - gitRepository - ociRepository - matrix - apiClient - cluster - imagepolicy - config</p>"},{"location":"gitopssets/templating-from-generators/#list-generator","title":"List generator","text":"<p>This is the simplest generator, which is a hard-coded array of JSON objects, described as YAML mappings.</p>"},{"location":"gitopssets/templating-from-generators/#gitrepository-generator","title":"GitRepository generator","text":"<p>The <code>GitRepository</code> generator operates on Flux GitRepositories.</p> <p>When a <code>GitRepository</code> is updated, this will trigger a regeneration of templates.</p> <p>The generator operates in two different ways, you can parse files (YAML or JSON) into Elements, or you can scan directories for subdirectories.</p>"},{"location":"gitopssets/templating-from-generators/#generation-from-files","title":"Generation from files","text":"<pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: repository-sample\nspec:\ngenerators:\n- gitRepository:\nrepositoryRef: go-demo-repo\nfiles:\n- path: examples/generation/dev.yaml\n- path: examples/generation/production.yaml\n- path: examples/generation/staging.yaml\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.env }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.env }}\"\ncom.example/team: \"{{ .Element.team }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre> <p>In this example, a Flux <code>GitRepository</code> called <code>go-demo-repo</code> in the same namespace as the <code>GitOpsSet</code> will be tracked, and <code>Kustomization</code> resources will be generated from the three files listed.</p> <p>These files can be JSON or YAML.</p> <p>In this example we expect to find the following structure in the files:</p> <pre><code>env: dev\nteam: developers\n</code></pre> <p>Changes pushed to the <code>GitRepository</code> will result in rereconciliation of the templates into the cluster.</p> <p>For security reasons, you need to explicitly list out the files that the generator should parse.</p>"},{"location":"gitopssets/templating-from-generators/#generation-from-directories","title":"Generation from directories","text":"<pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nlabels:\napp.kubernetes.io/name: gitopsset\napp.kubernetes.io/instance: gitopsset-sample\napp.kubernetes.io/part-of: gitopssets-controller\napp.kubernetes.io/managed-by: kustomize\napp.kubernetes.io/created-by: gitopssets-controller\nname: repository-sample\nspec:\ngenerators:\n- gitRepository:\nrepositoryRef: go-demo-repo\ndirectories:\n- path: examples/kustomize/environments/*\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.Base }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.Base }}\"\ncom.example/team: \"{{ .Element.Base }}\"\nspec:\ninterval: 5m\npath: \"{{ .Element.Directory }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre> <p>In this example, a Flux <code>GitRepository</code> called <code>go-demo-repo</code> in the same namespace as the <code>GitOpsSet</code> will be tracked, and <code>Kustomization</code> resources are generated from paths within the <code>examples/kustomize/environments/*</code> directory within the repository.</p> <p>Each generated element has two keys, <code>.Element.Directory</code> which will be a repo-relative path and <code>.Element.Base</code> which contains the last element of the path, for example, for a directory <code>./examples/kustomize/environments/production</code> this will be <code>production</code>.</p> <p>It is also possible to exclude paths from the generated list, for example, if you do not want to generate for a directory you can exclude it with:</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: repository-sample\nspec:\ngenerators:\n- gitRepository:\nrepositoryRef: go-demo-repo\ndirectories:\n- path: examples/kustomize/environments/*\n- path: examples/kustomize/environments/production\nexclude: true\ntemplates:\n- content:\n</code></pre> <p>In this case, all directories that are subdirectories of <code>examples/kustomize/environments</code> will be generated, but not <code>examples/kustomize/environments/production</code>.</p> <p>Note: The directory tree detection is restricted to the same directory as the path, no recursion is done.</p> <p>In fact the path is treated as a Glob.</p>"},{"location":"gitopssets/templating-from-generators/#ocirepository-generator","title":"OCIRepository generator","text":"<p>The <code>OCIRepository</code> generator operates on Flux OCIRepositories.</p> <p>When an <code>OCIRepository</code> is updated, this will trigger a regeneration of templates.</p> <p>The <code>OCIRepository</code> generator operates in exactly the same way as the GitRepository generator, except it operates on OCIRepositories.</p>"},{"location":"gitopssets/templating-from-generators/#generation-from-files_1","title":"Generation from files","text":"<pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: oci-repository-sample\nspec:\ngenerators:\n- ociRepository:\nrepositoryRef: go-demo-oci-repo\nfiles:\n- path: examples/generation/dev.yaml\n- path: examples/generation/production.yaml\n- path: examples/generation/staging.yaml\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.env }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.env }}\"\ncom.example/team: \"{{ .Element.team }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#pullrequests-generator","title":"PullRequests generator","text":"<p>This will require to make authenticated requests to your Git hosting provider e.g. GitHub, GitLab, Bitbucket etc.</p> <p>It does only require read-only access, but all API tokens should be guarded as carefully as possible, what is a \"read-only\" token today, might become a token with higher-privilege in the future.</p> <p>There have been many security compromises using API access tokens, do not let this happen to you!</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: pull-requests-sample\nspec:\ngenerators:\n- pullRequests:\ninterval: 5m\ndriver: github\nrepo: bigkevmcd/go-demo\nsecretRef:\nname: github-secret\ntemplates:\n- content:\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: GitRepository\nmetadata:\nname: \"pr-{{ .Element.Number }}-gitrepository\"\nnamespace: default\nspec:\ninterval: 5m0s\nurl: \"{{ .Element.CloneURL }}\"\nref:\nbranch: \"{{ .Element.Branch }}\"\n- content:\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\nname: \"pr-{{ .Element.Number }}-demo\"\nnamespace: default\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/dev\"\nprune: true\ntargetNamespace: \"{{ .Element.Branch }}-ns\"\nsourceRef:\nkind: GitRepository\nname: \"pr-{{ .Element.Number }}-gitrepository\"\n</code></pre> <p>This example will poll \"github.com/bigkevmcd/go-demo\" for open pull requests and trigger the deployment of these by creating a Flux <code>GitRepository</code> and a <code>Kustomization</code> to deploy.</p> <p>As the generator only queries open pull requests, when a PR is closed, the generated resources will be removed.</p> <p>For non-public installations, you can configure the <code>serverURL</code> field and point it to your own installation.</p> <p>The <code>driver</code> field can be <code>github</code> or <code>gitlab</code> or <code>bitbucketserver</code>, other options can be supported from go-scm.</p> <p>The <code>forks</code> flag field can be used to indicate whether to include forks in the target pull requests or not. If set to <code>true</code> any pull request from a fork repository will be included, otherwise if <code>false</code> or not indicated the pull requests from fork repositories are discarded.</p> <p>Additionally labels can be provided for querying pull requests with matching labels e.g.</p> <pre><code>- pullRequests:\ninterval: 5m\ndriver: github\nrepo: bigkevmcd/go-demo\nsecretRef:\nname: github-secret\nforks: false\nlabels:\n- deploy\n</code></pre> <p>The fields emitted by the pull-request are as follows:</p> <ul> <li><code>Number</code> this is generated as a string representation</li> <li><code>Branch</code> this is the source branch</li> <li><code>HeadSHA</code> this is the SHA of the commit in the merge branch</li> <li><code>CloneURL</code> this is the HTTPS clone URL for this repository</li> <li><code>CloneSSHURL</code> this is the SSH clone URL for this repository</li> <li><code>Fork</code> this indicates whether the pull request is from a fork (true) or not (false)</li> </ul> <p>Create a read-only token that can list Pull Requests, and store it in a secret:</p> <pre><code>$ kubectl create secret generic github-secret \\\n--from-literal password=&lt;insert access token here&gt;\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#matrix-generator","title":"Matrix generator","text":"<p>The matrix generator doesn't generate resources by itself. It combines the results of generation from other generators e.g.:</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: matrix-sample\nspec:\ngenerators:\n- matrix:\ngenerators:\n- gitRepository:\nrepositoryRef: go-demo-repo\nfiles:\n- path: examples/generation/dev.yaml\n- path: examples/generation/production.yaml\n- path: examples/generation/staging.yaml\n- list:\nelements:\n- cluster: dev-cluster\nversion: 1.0.0\n</code></pre> <p>Given the files mentioned all have the following structure:</p> <pre><code>env: dev\nteam: developers\n</code></pre> <p>This will result in three sets of generated parameters, which are a combination of the maps in the files in the gitRepository, and the elements in the list generator, this can result in a combinatorial explosion of resources being created in your cluster.</p> <pre><code>- env: dev\nteam: developers\ncluster: dev-cluster\nversion: 1.0.0\n- env: staging\nteam: staging-team\ncluster: dev-cluster\nversion: 1.0.0\n- env: production\nteam: production-team\ncluster: dev-cluster\nversion: 1.0.0\n</code></pre> <p>These can be referenced in the templates, note that all keys in the merged generators from the Matrix are contained in the <code>Element</code> scope.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: matrix-sample\nspec:\ngenerators:\n- matrix:\ngenerators:\n- gitRepository:\nrepositoryRef: go-demo-repo\nfiles:\n- path: examples/generation/dev.yaml\n- path: examples/generation/production.yaml\n- path: examples/generation/staging.yaml\n- list:\nelements:\n- cluster: dev-cluster\nversion: 1.0.0\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.env }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.env }}\"\ncom.example/team: \"{{ .Element.team }}\"\ncom.example/cluster: \"{{ .Element.cluster }}\"\ncom.example/version: \"{{ .Element.version }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#optional-name-for-matrix-elements","title":"Optional Name for Matrix elements","text":"<p>If you want to use two generators in a Matrix that output the same fields, they will collide, for example, the <code>ImagePolicy</code> generator outputs a <code>latestImage</code> field, if you have two, they will collide.</p> <p>You can provide a name for the generator in the Matrix:</p> <p><pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: matrix-sample\nspec:\ngenerators:\n- matrix:\ngenerators:\n- name: gen1\ngitRepository:\nrepositoryRef: go-demo-repo\nfiles:\n- path: examples/generation/dev.yaml\n- path: examples/generation/production.yaml\n- path: examples/generation/staging.yaml\n- name: gen2\nlist:\nelements:\n- cluster: dev-cluster\nversion: 1.0.0\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.gen1.env }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.gen1.env }}\"\ncom.example/team: \"{{ .Element.gen1.team }}\"\ncom.example/cluster: \"{{ .Element.gen2.cluster }}\"\ncom.example/version: \"{{ .Element.gen2.version }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.gen1.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre> The name value is used as a key in the generated results.</p> <p>The example above will yield:</p> <pre><code>- gen1:\nenv: dev\nteam: developers\ngen2:\ncluster: dev-cluster\nersion: 1.0.0\n- gen1:\nenv: staging\nteam: staging-team\ngen2:\ncluster: dev-cluster\nversion: 1.0.0\n- gen1:\nenv: production\nteam: production-team\ngen2:\ncluster: dev-cluster\nversion: 1.0.0\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#single-element-for-matrix","title":"Single Element for Matrix","text":"<p>A matrix generator will normally generate a cartesian result, but you can also generate a single result.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: single-element-matrix-sample\nspec:\ngenerators:\n- matrix:\nsingleElement: true\ngenerators:\n- name: staging\ncluster:\nselector:\nmatchLabels:\nenv: staging\n- name: production\ncluster:\nselector:\nmatchLabels:\nenv: production\n</code></pre> <p>This would query for clusters matching the respective labels.</p> <p>The resulting output would look like this (in YAML):</p> <pre><code>- production:\n- ClusterAnnotations: {}\nClusterLabels:\nenv: production\nClusterName: production-cluster1\nClusterNamespace: clusters\n- ClusterAnnotations: {}\nClusterLabels:\nenv: production\nClusterName: production-cluster2\nClusterNamespace: clusters\nstaging:\n- ClusterAnnotations: {}\nClusterLabels:\nenv: staging\nClusterName: staging-cluster1\nClusterNamespace: clusters\n- ClusterAnnotations: {}\nClusterLabels:\nenv: staging\nClusterName: staging-cluster2\nClusterNamespace: clusters\n</code></pre> <p>Compare this with the alternative without the <code>singleElement</code> flag:</p> <pre><code>- production:\nClusterAnnotations: {}\nClusterLabels:\nenv: production\nClusterName: production-cluster1\nClusterNamespace: clusters\nstaging:\nClusterAnnotations: {}\nClusterLabels:\nenv: staging\nClusterName: staging-cluster1\nClusterNamespace: clusters\n- production:\nClusterAnnotations: {}\nClusterLabels:\nenv: production\nClusterName: production-cluster2\nClusterNamespace: clusters\nstaging:\nClusterAnnotations: {}\nClusterLabels:\nenv: staging\nClusterName: staging-cluster1\nClusterNamespace: clusters\n- production:\nClusterAnnotations: {}\nClusterLabels:\nenv: production\nClusterName: production-cluster1\nClusterNamespace: clusters\nstaging:\nClusterAnnotations: {}\nClusterLabels:\nenv: staging\nClusterName: staging-cluster2\nClusterNamespace: clusters\n- production:\nClusterAnnotations: {}\nClusterLabels:\nenv: production\nClusterName: production-cluster2\nClusterNamespace: clusters\nstaging:\nClusterAnnotations: # omitted\nClusterLabels:\nenv: staging\nClusterName: staging-cluster2\nClusterNamespace: clusters\n</code></pre> <p>In the <code>singleElement</code> case, there is only one generated element, only one template will be rendered for each content item.</p> <p>If the Matrix generators are unnamed, they will be grouped under a top-level <code>.Matrix</code> name.</p>"},{"location":"gitopssets/templating-from-generators/#apiclient-generator","title":"apiClient generator","text":"<p>This generator is configured to poll an HTTP endpoint and parse the result as the generated values.</p> <p>This will poll an endpoint on the interval, instead of using the simpler to use PullRequest generator, you can access GitHub's API with the APIClient generator.</p> <p>The PullRequest generator is simpler to use, and works across multiple different git-providers.</p> <p>The GitHub documentation for the API endpoint shows:</p> <pre><code>curl \\\n-H \"Accept: application/vnd.github+json\" \\\n-H \"Authorization: Bearer &lt;YOUR-TOKEN&gt;\"\\\n-H \"X-GitHub-Api-Version: 2022-11-28\" \\\nhttps://api.github.com/repos/OWNER/REPO/pulls\n</code></pre> <p>This can be translated into...</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nlabels:\napp.kubernetes.io/name: gitopsset\napp.kubernetes.io/instance: gitopsset-sample\napp.kubernetes.io/part-of: gitopssets-controller\napp.kubernetes.io/managed-by: kustomize\napp.kubernetes.io/created-by: gitopssets-controller\nname: api-client-sample\nspec:\ngenerators:\n- apiClient:\ninterval: 5m\nendpoint: https://api.github.com/repos/bigkevmcd/go-demo/pulls\nheadersRef:\nname: github-secret\nkind: Secret\ntemplates:\n- content:\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: GitRepository\nmetadata:\nname: \"pr-{{ .Element.id | toJson}}-gitrepository\"\nnamespace: default\nspec:\ninterval: 5m0s\nurl: \"{{ .Element.head.repo.clone_url }}\"\nref:\nbranch: \"{{ .Element.head.ref }}\"\n- content:\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\nname: \"pr-{{ .Element.id | toJson }}-demo\"\nnamespace: default\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/dev\"\nprune: true\ntargetNamespace: \"{{ .Element.head.ref }}-ns\"\nsourceRef:\nkind: GitRepository\nname: \"pr-{{ .Element.id | toJson }}-gitrepository\"\n</code></pre> <p>As with the Pull Request generator, this also requires a secret token to be able to access the API</p> <p>We need to pass this as an HTTP header.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: github-secret\nnamespace: default\ntype: Opaque\nstringData:\nAccept: application/vnd.github+json\nAuthorization: Bearer ghp_&lt;redacted&gt;\nX-GitHub-Api-Version: \"2022-11-28\"\n</code></pre> <p>The keys in the secret match the command-line example using curl.</p> <p>Unlike the Pull Request generator, you need to figure out the paths to the elements yourself.</p>"},{"location":"gitopssets/templating-from-generators/#apiclient-jsonpath","title":"APIClient JSONPath","text":"<p>Not all APIs return an array of JSON objects, sometimes it's nested within a result type structure e.g.</p> <pre><code>{\n\"things\": [\n{\n\"env\": \"dev\",\n\"team\": \"dev-team\"\n},\n{\n\"env\": \"production\",\n\"team\": \"opts-team\"\n},\n{\n\"env\": \"staging\",\n\"team\": \"opts-team\"\n}\n]\n}\n</code></pre> <p>You can use JSONPath to extract the fields from this data...</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nlabels:\napp.kubernetes.io/name: gitopsset\napp.kubernetes.io/instance: gitopsset-sample\napp.kubernetes.io/part-of: gitopssets-controller\napp.kubernetes.io/managed-by: kustomize\napp.kubernetes.io/created-by: gitopssets-controller\nname: api-client-sample\nspec:\ngenerators:\n- apiClient:\ninterval: 5m\nendpoint: https://api.example.com/demo\njsonPath: \"{ $.things }\"\n</code></pre> <p>This will generate three maps for templates, with just the env and team keys.</p>"},{"location":"gitopssets/templating-from-generators/#apiclient-post-body","title":"APIClient POST body","text":"<p>Another piece of functionality in the APIClient generator is the ability to POST JSON to the API.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nlabels:\napp.kubernetes.io/name: gitopsset\napp.kubernetes.io/instance: gitopsset-sample\napp.kubernetes.io/part-of: gitopssets-controller\napp.kubernetes.io/managed-by: kustomize\napp.kubernetes.io/created-by: gitopssets-controller\nname: api-client-sample\nspec:\ngenerators:\n- apiClient:\ninterval: 5m\nendpoint: https://api.example.com/demo\nbody:\nname: \"testing\"\nvalue: \"testing2\"\n</code></pre> <p>This will send a request body as JSON (Content-Type \"application/json\") to the server and interpret the result.</p> <p>The JSON body sent will look like this:</p> <pre><code>{ \"name\": \"testing\", \"value\": \"testing2\" }\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#apiclient-simple-results","title":"APIClient simple results","text":"<p>Instead of using the JSONPath to extract from a complex structure, you can configure the result to be a single element.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nlabels:\napp.kubernetes.io/name: gitopsset\napp.kubernetes.io/instance: gitopsset-sample\napp.kubernetes.io/part-of: gitopssets-controller\napp.kubernetes.io/created-by: gitopssets-controller\nname: api-client-sample\nspec:\ngenerators:\n- apiClient:\nsingleElement: true\ninterval: 5m\nendpoint: https://api.example.com/demo\n</code></pre> <p>Whatever result is parsed from the API endpoint will be returned as a map in a single element.</p> <p>For generation, you might need to use the <code>repeat</code> mechanism to generate repeating results.</p>"},{"location":"gitopssets/templating-from-generators/#apiclient-custom-ca","title":"APIClient Custom CA","text":"<p>If the API endpoint you are accessing requires a custom CA you can provide this via the secret field.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nlabels:\napp.kubernetes.io/name: gitopsset\napp.kubernetes.io/instance: gitopsset-sample\napp.kubernetes.io/part-of: gitopssets-controller\napp.kubernetes.io/created-by: gitopssets-controller\nname: api-client-sample\nspec:\ngenerators:\n- apiClient:\nsingleElement: true\ninterval: 5m\nendpoint: https://api.example.com/demo\nsecretRef:\nname: https-ca-credentials\n</code></pre> <p>This secret should look like this:</p> <pre><code>---\napiVersion: v1\nkind: Secret\nmetadata:\nname: https-ca-credentials\ntype: Opaque\ndata:\ncaFile: &lt;BASE64&gt;\n</code></pre> <p>The request will be made with the custom CA.</p>"},{"location":"gitopssets/templating-from-generators/#cluster-generator","title":"Cluster generator","text":"<p>The cluster generator generates from in-cluster GitOpsCluster resources.</p> <p>For example, this <code>GitOpsSet</code> will generate a <code>Kustomization</code> resource for each cluster matching the Label selector.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: cluster-sample\nspec:\ngenerators:\n- cluster:\nselector:\nmatchLabels:\nenv: dev\nteam: dev-team\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.ClusterName }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.ClusterName }}\"\ncom.example/team: \"{{ .Element.ClusterLabels.team }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.ClusterLabels.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre> <p>The following fields are generated for each GitOpsCluster.</p> <ul> <li><code>ClusterName</code> the name of the cluster</li> <li><code>ClusterNamespace</code> the namespace that this cluster is from</li> <li><code>ClusterLabels</code> the labels from the metadata field on the GitOpsCluster</li> <li><code>ClusterAnnotations</code> the annotations from the metadata field on the GitOpsCluster</li> </ul> <p>If the selector is not provided, all clusters from all namespaces will be returned:</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: cluster-sample\nspec:\ngenerators:\n- cluster: {}\n</code></pre> <p>Otherwise if the selector is empty, no clusters will be generated:</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: cluster-sample\nspec:\ngenerators:\n- cluster:\nselector: {}\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#imagepolicy-generator","title":"ImagePolicy generator","text":"<p>The <code>ImagePolicy</code> generator works with the Flux Image Automation.</p> <p>When an <code>ImagePolicy</code> is updated, this will trigger a regeneration of templates.</p> <p>The generated elements have the following fields:</p> <ul> <li>latestImage - the latest image from the status field on the <code>ImagePolicy</code></li> <li>latestTag - only the tag part of the latestImage, e.g. will be v0.1 for an image of \"testing/image:v0.1\"</li> <li>previousImage - the previous image from the status field on the <code>ImagePolicy</code></li> </ul> <p>This can be used simply, to create a deployment with an image...or, combined with a Matrix generator, to manage multiple workloads with the same image.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: imagepolicy-example\nnamespace: default\nspec:\ngenerators:\n- imagePolicy:\npolicyRef: podinfo\ntemplates:\n- content:\nkind: ConfigMap\napiVersion: v1\nmetadata:\nname: \"demo-configmap\"\ndata:\nimage: \"{{ .Element.latestImage }}\"\n</code></pre> <p>In this example, a <code>ConfigMap</code> is generated containing the latest image whenever an <code>ImagePolicy</code> called <code>podinfo</code> is updated.</p> <p>Combined in a Matrix, like this, it will generate two <code>ConfigMaps</code> with the values.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: imagepolicy-matrix-example\nnamespace: default\nspec:\ngenerators:\n- matrix:\ngenerators:\n- imagePolicy:\npolicyRef: podinfo\n- list:\nelements:\n- cluster: dev-cluster\nversion: 1.0.0\n- cluster: prod-cluster\nversion: 1.0.0\ntemplates:\n- content:\nkind: ConfigMap\napiVersion: v1\nmetadata:\nname: \"demo-configmap-{{ .Element.cluster }}\"\ndata:\nimage: \"{{ .Element.latestImage }}\"\ncluster: \"{{ .Element.cluster }}\"\nversion: \"{{ .Element.version }}\"\n</code></pre> <p>The resulting ConfigMaps look like this:</p> <pre><code>$ kubectl get configmaps\nNAME                          DATA   AGE\ndemo-configmap-dev-cluster    3      3m19s\ndemo-configmap-prod-cluster   3      3m19s\n</code></pre> <p>With the templated fields like this:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: demo-configmap-dev-cluster\nnamespace: default\ndata:\ncluster: dev-cluster\nimage: stefanprodan/podinfo:5.1.4\nversion: 1.0.0\n</code></pre> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: demo-configmap-prod-cluster\nnamespace: default\ndata:\ncluster: prod-cluster\nimage: stefanprodan/podinfo:5.1.4\nversion: 1.0.0\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#config-generator","title":"Config generator","text":"<p>The <code>Config</code> generator with Kubernetes ConfigMaps and Secrets.</p> <p>When an <code>ConfigMap</code> or <code>Secret</code> is updated, this will trigger a regeneration of templates.</p> <p>This can be used simply, to create a resource with an config variable...or, combined with a Matrix generator, to manage multiple workloads with the same values.</p> <p>With the existing <code>ConfigMap</code> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: test-cm\ndata:\nname: test-config\ndemo: test-value\n</code></pre> And the GitOpsSet below <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: config-sample\nspec:\ngenerators:\n- config:\nkind: ConfigMap\nname: test-cm\ntemplates:\n- content:\nkind: ConfigMap\napiVersion: v1\nmetadata:\nname: \"{{ .Element.name }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.name }}\"\ndata:\ngeneratedValue: \"{{ .Element.demo }}\"\n</code></pre> In this example, a new <code>ConfigMap</code> is generated containing the value of the \"demo\" field from the existing <code>ConfigMap</code> test-cm.</p> <p>As with the other generators, the <code>Config</code> generator can be combined with other generators:</p> <p>This will generate two <code>ConfigMaps</code> with the values. <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: imagepolicy-matrix-example\nnamespace: default\nspec:\ngenerators:\n- matrix:\ngenerators:\n- config:\nkind: ConfigMap\nname: test-cm\n- list:\nelements:\n- cluster: dev-cluster\nversion: 1.0.0\n- cluster: prod-cluster\nversion: 1.0.0\ntemplates:\n- content:\nkind: ConfigMap\napiVersion: v1\nmetadata:\nname: \"demo-configmap-{{ .Element.cluster }}\"\ndata:\ngeneratedValue: \"{{ .Element.demo }}\"\ncluster: \"{{ .Element.cluster }}\"\nversion: \"{{ .Element.version }}\"\n</code></pre></p> <p>The resulting ConfigMaps look like this:</p> <pre><code>$ kubectl get configmaps\nNAME                          DATA   AGE\ndemo-configmap-dev-cluster    3      3m19s\ndemo-configmap-prod-cluster   3      3m19s\n</code></pre> <p>With the templated fields like this:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: demo-configmap-dev-cluster\nnamespace: default\ndata:\ncluster: dev-cluster\ngeneratedValue: test-value\nversion: 1.0.0\n</code></pre> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: demo-configmap-prod-cluster\nnamespace: default\ndata:\ncluster: prod-cluster\ngeneratedValue: test-value\nversion: 1.0.0\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#templating-functions","title":"Templating functions","text":"<p>Currently, the Sprig functions are available in the templating, with some functions removed[^sprig] for security reasons.</p> <p>In addition, we also provide two additional functions:</p> <ul> <li>sanitize - sanitises strings to be compatible with Kubernetes DNS name requirements</li> <li>getordefault - gets a key from the <code>.Element</code> or defaults to another value.</li> </ul> <p>The examples below assume an element that looks like this:</p> <pre><code>{\n\"team\": \"engineering dev\"\n}\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#sanitize-template-function","title":"sanitize template function","text":"<p>And a template that looks like this:</p> <pre><code>kind: Service\nmetadata:\nname: {{ sanitize .Element.team }}-demo\n</code></pre> <p>This would output:</p> <pre><code>kind: Service\nmetadata:\nname: engineeringdev-demo\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#getordefault","title":"getordefault","text":"<p>For template that looks like this:</p> <pre><code>kind: Service\nmetadata:\nname: {{ getordefault .Element \"name\" \"defaulted\" }}-demo\n</code></pre> <p>This would output:</p> <pre><code>kind: Service\nmetadata:\nname: defaulted-demo\n</code></pre> <p>If the key to get does exist in the <code>.Element</code> it will be inserted, the \"default\" is only inserted if it doesn't exist.</p>"},{"location":"gitopssets/templating-from-generators/#security","title":"Security","text":"<p>Warning</p> <p>Generating resources and applying them directly into your cluster can be dangerous to the health of your cluster.</p> <p>This is especially true for the <code>GitRepository</code> generator, where it may not be obvious to the author of the files, or the author of the template the consequences of the template rendering.</p> <p>The default <code>ServiceAccount</code> that is used by the gitopssets-controller is extremely limited, and can not create resources, you will need to explicitly grant permissions to create any of the resources you declare in the template, missing permissions will appear in the controller logs.</p> <p>It is not recommended that you create a role with blanket permissions, under the right circumstances, someone could accidentally or maliciously overwrite the cluster control-plane, which could be very dangerous.</p>"},{"location":"gitopssets/templating-from-generators/#limiting-via-service-accounts","title":"Limiting via service-accounts","text":"<p>You can configure the service-account that is used to create resources.</p> <pre><code>apiVersion: templates.weave.works/v1alpha1\nkind: GitOpsSet\nmetadata:\nname: matrix-sample\nspec:\n# the controller will impersonate this service account\nserviceAccountName: test-sa\ngenerators:\n- list:\nelements:\n- env: dev\nteam: dev-team\n- env: production\nteam: ops-team\n- env: staging\nteam: ops-team\ntemplates:\n- content:\nkind: Kustomization\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nmetadata:\nname: \"{{ .Element.env }}-demo\"\nlabels:\napp.kubernetes.io/name: go-demo\napp.kubernetes.io/instance: \"{{ .Element.env }}\"\ncom.example/team: \"{{ .Element.team }}\"\nspec:\ninterval: 5m\npath: \"./examples/kustomize/environments/{{ .Element.env }}\"\nprune: true\nsourceRef:\nkind: GitRepository\nname: go-demo-repo\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#gitopsset-controller-configuration","title":"gitopsset-controller configuration","text":"<p>The enabled generators can be configured via the <code>--enabled-generators</code> flag, which takes a comma separated list of generators to enable.</p> <p>The default is to enable all generators.</p> <p>For example to enable only the <code>List</code> and <code>GitRepository</code> generators:</p> <pre><code>--enabled-generators=List,GitRepository\n</code></pre> <p>When a GitOpsSet that uses disabled generators is created, the disabled generators will be silently ignored.</p>"},{"location":"gitopssets/templating-from-generators/#kubernetes-process-limits","title":"Kubernetes Process Limits","text":"<p>GitOpsSets can be memory-hungry, for example, the Matrix generator will generate a cartesian result with multiple copies of data.</p> <p>The OCI and GitRepository generators will extract tarballs, the API Generator queries upstream APIs and parses the JSON, and the Config generators will load <code>Secret</code> and <code>ConfigMap</code> resources, all these can lead to using significant amounts of memory.</p> <p>Extracting tarballs can also prove to be CPU intensive, especially where there are lots of files, and you have a very frequent regeneration period.</p> <p>To this end, you will need to monitor the controller metrics, and maybe increase the limits available to the controller.</p> <p>For example, to increase the amount of memory available to the controller:</p> <pre><code>resources:\nlimits:\ncpu: 1000m\nmemory: 2Gi\nrequests:\ncpu: 100m\nmemory: 64Mi\n</code></pre>"},{"location":"gitopssets/templating-from-generators/#notifications","title":"Notifications","text":"<p>Events are enabled which will trigger Kubernetes events when successful reconciliation occurs with a <code>Normal</code> event or when reconciliation fails with an <code>Error</code> event. Fluxcd's Events package is used including the <code>EventRecorder</code> to record these events.</p> <p>To configure receiving the recorded events on a specific host, this can be provided via the <code>--events-addr</code> flag in <code>RUN_ARGS</code> when starting the controller. This can be any HTTP endpoint.</p> <p>See fluxcd event for the struct of the event created.</p> <p>[^yaml]: These are written as YAML mappings [^sprig]: The following functions are removed \"env\", \"expandenv\", \"getHostByName\", \"genPrivateKey\", \"derivePassword\", \"sha256sum\", \"base\", \"dir\", \"ext\", \"clean\", \"isAbs\", \"osBase\", \"osDir\", \"osExt\", \"osClean\", \"osIsAbs\"</p>"},{"location":"guides/anonymous-access/","title":"Anonymous Access","text":"<p>Important</p> <p>Alone, this is an insecure method of securing your dashboard.</p> <p>It is designed to be used with other external authentication systems like auth proxies.</p>"},{"location":"guides/anonymous-access/#configuring-anonymous-access","title":"Configuring Anonymous access","text":"<p>Set the following values in the Helm Chart:</p> <pre><code>#\nadditionalArgs:\n- --insecure-no-authentication-user=gitops-test-user\n#\n</code></pre> <p>The value of the <code>--insecure-no-authentication-user</code> flag is the kubernetes <code>User</code> to be impersonated to make requests into the cluster.</p> <p>When this flag is set all other authentication methods (e.g. those specified via <code>--auth-methods</code>) are disabled.</p> <p>No login screen will be displayed when accessing the dashboard.</p>"},{"location":"guides/anonymous-access/#example-clusterrole","title":"Example ClusterRole","text":"<p>You can bind the user provided to a ClusterRole with a ClusterRoleBinding.</p> <pre><code>---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: minimum-weavegitops-role\nrules:\n- apiGroups: [\"\"]\nresources: [\"secrets\",\"pods\",\"events\"]\nverbs: [\"get\",\"list\"]\n- apiGroups: [\"apps\"]\nresources: [\"deployments\", \"replicasets\"]\nverbs: [\"get\",\"list\"]\n- apiGroups: [\"kustomize.toolkit.fluxcd.io\"]\nresources: [\"kustomizations\"]\nverbs: [\"get\",\"list\"]\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [\"helmreleases\"]\nverbs: [\"get\",\"list\"]\n- apiGroups: [\"source.toolkit.fluxcd.io\"]\nresources: [\"*\"]\nverbs: [\"get\",\"list\"]\n- apiGroups: [\"\"]\nresources: [\"events\"]\nverbs: [\"get\",\"list\",\"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: gitops-test-user-binding\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: minimum-weavegitops-role\nsubjects:\n- kind: User\nname: gitops-test-user\n</code></pre> <p>This would allow access to any resource.</p>"},{"location":"guides/displaying-custom-metadata/","title":"Displaying Custom Metadata","text":"<p>Weave GitOps lets you add annotations with custom metadata to your Flux automations and sources, and they will be displayed in the main UI.</p> <p>For example, you might use this to add links to dashboards, issue systems, or documentation and comments that you wish to be directly visible in the GitOps UI.</p> <p>We will use the <code>podinfo</code> application that we installed in the getting started guide as an example. Open up the podinfo kustomization and add annotations to it so it looks like this:</p> ./clusters/my-cluster/podinfo-kustomization.yaml<pre><code>---\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\nname: podinfo\nnamespace: flux-system\n// highlight-start\nannotations:\nmetadata.weave.works/description: |\nPodinfo is a tiny web application made with Go that showcases best practices of running microservices in Kubernetes.\nPodinfo is used by CNCF projects like Flux and Flagger for end-to-end testing and workshops.\nmetadata.weave.works/grafana-dashboard: https://grafana.my-org.example.com/d/podinfo-dashboard\n// highlight-end\nspec:\ninterval: 5m0s\npath: ./kustomize\nprune: true\nsourceRef:\nkind: GitRepository\nname: podinfo\ntargetNamespace: flux-system\n</code></pre> <p>Close the file and commit and push your changes.</p> <p>Back in your GitOps dashboard, navigate to the 'Applications' tab and select the <code>podinfo</code> kustomization. At the bottom of the 'Details' section you will see the new 'Metadata' entries:</p> <p></p> <p>Restrictions</p> <ul> <li>The annotation key must start with the domain <code>metadata.weave.works</code>. Any other annotations will be ignored.</li> <li>The key that will be displayed is whatever you put after the domain, title cased, and with dashes replaced with spaces. Above, <code>metadata.weave.works/grafana-dashboard</code> was displayed as \"Grafana Dashboard\".</li> <li>The value can either be a link, or can be plain text. Newlines in plain text will be respected.</li> <li>The key is subject to certain limitations that kubernetes imposes on annotations, including:<ul> <li>it must be shorter than 63 characters (not including the domain)</li> <li>it must be an English alphanumeric character, or one of <code>-._</code>.</li> <li>See the kubernetes documentation for the full list of restrictions.</li> </ul> </li> </ul>"},{"location":"guides/fluxga-upgrade/","title":"Upgrade to Flux GA","text":"<p>We are very excited for the release of the Flux v2.0 GA!</p> <p>This guide aims to answer some common questions before starting the upgrade, and provides step-by-step instructions.</p>"},{"location":"guides/fluxga-upgrade/#before-starting-the-upgrade","title":"Before Starting the Upgrade","text":"<p>Useful terms used in this guide:</p> <ul> <li><code>Flux Beta or Flux v0.x</code> as the latest Flux Beta Release.</li> <li><code>Flux GA</code> as the latest Flux GA Release Candidate</li> <li><code>Weave GitOps</code> as the latest Weave GitOps Enterprise release</li> </ul>"},{"location":"guides/fluxga-upgrade/#faq","title":"FAQ","text":"<p>Here you can find the most common questions around upgrading.</p>"},{"location":"guides/fluxga-upgrade/#why-upgrade-to-flux-ga","title":"Why Upgrade to Flux GA","text":"<p>Although Flux Beta APIs have been stable and used in production for quite some time, Flux GA is the main supported API version for new features and development. Features like horizontal scaling are only available in Flux GA. Also, beta APIs will be removed after six months.</p>"},{"location":"guides/fluxga-upgrade/#can-i-use-weave-gitops-with-flux-ga","title":"Can I Use Weave GitOps with Flux GA?","text":"<p>Yes. This has been possible since Weave Gitops v0.22.0. Use the latest available release for the best experience.</p>"},{"location":"guides/fluxga-upgrade/#can-i-use-weave-gitops-enterprise-with-flux-ga","title":"Can I Use Weave GitOps Enterprise with Flux GA?","text":"<p>Yes. This has been possible since Weave GitOps Enterprise v0.22.0. Use the latest available release for the best experience.</p> <p>The following limitations are knowns by version:</p>"},{"location":"guides/fluxga-upgrade/#v0230-onwards","title":"v0.23.0 onwards","text":"<p>No limitations</p>"},{"location":"guides/fluxga-upgrade/#v0220","title":"v0.22.0","text":"<p>If you are using GitOpsSets, upgrade that component to v0.10.0 for Flux GA compatibility. Update the Weave GitOps Enterprise HelmRelease values to use the new version.</p> <pre><code>gitopssets-controller:\ncontrollerManager:\nmanager:\nimage:\ntag: v0.10.0\n</code></pre>"},{"location":"guides/fluxga-upgrade/#can-i-use-weave-gitops-with-flux-v2-0x-pre-ga-versions","title":"Can I Use Weave GitOps with Flux v2 0.x (pre-GA versions)?","text":"<p>As of Weave GitOps v0.29, only Flux v2.0 GA is supported. Please follow the Upgrade section to help you with the process.</p> <p>Earlier versions of Weave GitOps work with both Flux v2 GA and Flux v2 0.x (the pre-GA ones), but it is encouraged that you upgrade to the latest version for the best experience.</p>"},{"location":"guides/fluxga-upgrade/#upgrade","title":"Upgrade","text":"<p>Hosted flux?</p> <p>If you are using a hosted Flux version, please check with your provider if they support Flux GA before upgrading following this guide. Known hosted Flux providers:</p> <ul> <li>EKS Anywhere</li> <li>Azure AKS Flux-GitOps extension</li> </ul> <p>As of writing they do not yet support the new version, so please wait before upgrading to Flux GA.</p> <p>Below, we'll take you through the multiple steps required to migrate to your system to Flux GA. After each step the cluster will be in a working state, so you can take your time to complete the migration.</p> <ol> <li>Upgrade to Flux GA on your existing leaf clusters and management clusters</li> <li>Upgrade to Flux GA in <code>ClusterBootstrapConfig</code>s.</li> <li>Upgrade to latest Weave GitOps.</li> <li>Upgrade GitopsTemplates, GitopsSets and ClusterBootstrapConfigs.</li> </ol>"},{"location":"guides/fluxga-upgrade/#1-upgrade-to-flux-ga-on-your-existing-leaf-clusters-and-management-clusters","title":"1. Upgrade to Flux GA on your existing leaf clusters and management clusters","text":"<p>Follow the upgrade instructions from the Flux v2.0.0 release notes.</p> <p>At minimum, you'll need to rerun the <code>flux bootstrap</code> command on your leaf clusters and management clusters.</p> <p>You'll also need to bump API versions in your manifests to <code>v1</code> as described in the Flux upgrade instructions:</p> <p>Bumping the APIs version in manifests can be done gradually. It is advised to not delay this procedure as the beta versions will be removed after 6 months.</p> <p>At this stage all clusters are running Flux GA.</p>"},{"location":"guides/fluxga-upgrade/#2-upgrade-to-flux-ga-in-clusterbootstrapconfigs","title":"2. Upgrade to Flux GA in ClusterBootstrapConfigs","text":"<p>First, we ensure any new clusters are bootstrapped with Flux GA. Then we'll upgrade the existing clusters.</p> <p><code>ClusterBootstrapConfig</code> will most often contain an invocation of <code>flux bootstrap</code>. Make sure the image is using <code>v2</code>.</p> Expand to see example <pre><code>diff --git a/tools/dev-resources/user-guide/cluster-bootstrap-config.yaml b/tools/dev-resources/user-guide/cluster-bootstrap-config.yaml\nindex bd41ec036..1b21df860 100644\n--- a/tools/dev-resources/user-guide/cluster-bootstrap-config.yaml\n+++ b/tools/dev-resources/user-guide/cluster-bootstrap-config.yaml\n@@ -1,34 +1,34 @@\napiVersion: capi.weave.works/v1alpha1\nkind: ClusterBootstrapConfig\nmetadata:\nname: capi-gitops\nnamespace: default\nspec:\nclusterSelector:\n    matchLabels:\n    weave.works/capi: bootstrap\njobTemplate:\n    generateName: \"run-gitops-{{ .ObjectMeta.Name }}\"\n    spec:\n    containers:\n-        - image: ghcr.io/fluxcd/flux-cli:v0.34.0\n+        - image: ghcr.io/fluxcd/flux-cli:v2.0.0\n        name: flux-bootstrap\n        ...\n</code></pre> <p>At this stage, your new bootstrapped clusters will run Flux GA.</p>"},{"location":"guides/fluxga-upgrade/#3-upgrade-to-latest-wge","title":"3. Upgrade to latest WGE","text":"<p>Use your regular WGE upgrade procedure to bring it to the latest version</p> <p>At this stage you have Weave GitOps running Flux GA.</p>"},{"location":"guides/fluxga-upgrade/#4-upgrade-gitopstemplates-gitopssets-and-clusterbootstrapconfigs","title":"4. Upgrade GitOpsTemplates, GitOpsSets, and ClusterBootstrapConfigs","text":"<p>Bumping the APIs version in manifests can be done gradually. We advise against delaying this procedure as the Beta versions will be removed after six months.</p>"},{"location":"guides/fluxga-upgrade/#gitopstemplate-and-capitemplate","title":"<code>GitOpsTemplate</code> and <code>CAPITemplate</code>","text":"<p>Update <code>GitRepository</code> and <code>Kustomization</code> CRs in the <code>spec.resourcetemplates</code> to <code>v1</code> as described in the flux upgrade instructions.</p>"},{"location":"guides/fluxga-upgrade/#gitopssets","title":"<code>GitOpsSets</code>","text":"<p>Update <code>GitRepository</code> and <code>Kustomization</code> CRs in the <code>spec.template</code> of your <code>GitOpsSet</code> resources to <code>v1</code> as described in the Flux upgrade instructions.</p>"},{"location":"guides/fluxga-upgrade/#5-future-steps","title":"5. Future steps","text":"<p>If you haven't done it yet, plan to update your  <code>Kustomization</code> , <code>GitRepository</code> and <code>Receiver</code> resources to <code>v1</code>, you can also upgrade to the future release of Flux that will drop support for <code>&lt; v1</code> APIs.</p>"},{"location":"guides/fluxga-upgrade/#contact-us","title":"Contact us","text":"<p>If you find any issues, please let us know via support.</p>"},{"location":"open-source/aws-marketplace/","title":"AWS Marketplace","text":""},{"location":"open-source/aws-marketplace/#aws-marketplace","title":"AWS Marketplace","text":"<p>Weave GitOps is also available via the AWS Marketplace.</p> <p>The following steps will allow you to deploy the Weave GitOps product to an EKS cluster via a Helm Chart.</p> <p>These instructions presume you already have installed <code>kubectl</code>, <code>eksctl</code>, <code>helm</code> and the Helm S3 Plugin.</p>"},{"location":"open-source/aws-marketplace/#step-1-subscribe-to-weave-gitops-on-the-aws-marketplace","title":"Step 1: Subscribe to Weave GitOps on the AWS Marketplace","text":"<p>To deploy the managed Weave GitOps solution, first subscribe to the product on AWS Marketplace.</p> <p>Note: it may take ~20 minutes for your Subscription to become live and deployable.</p>"},{"location":"open-source/aws-marketplace/#step-2-configure-an-eks-cluster","title":"Step 2: Configure an EKS Cluster","text":"Create a new EKS ClusterUse an existing EKS Cluster <p>If you do not have a cluster on EKS, you can use <code>eksctl</code> to create one.</p> <p>Copy the contents of the sample file below into <code>cluster-config.yaml</code> and replace the placeholder values with your settings. See the <code>eksctl</code> documentation for more configuration options.</p> Expand for file contents cluster-config.yaml<pre><code>---\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\nmetadata:\nname: CLUSTER_NAME # Change this\nregion: REGION # Change this\n\n# This section is required\niam:\nwithOIDC: true\nserviceAccounts:\n- metadata:\nname: wego-service-account # Altering this will require a corresponding change in a later command\nnamespace: flux-system\nroleOnly: true\nattachPolicy:\nVersion: \"2012-10-17\"\nStatement:\n- Effect: Allow\nAction:\n- \"aws-marketplace:RegisterUsage\"\nResource: '*'\n\n# This section will create a single Managed nodegroup with one node.\n# Edit or remove as desired.\nmanagedNodeGroups:\n- name: ng1\ninstanceType: m5.large\ndesiredCapacity: 1\n</code></pre> <p>Create the cluster:</p> <pre><code>eksctl create cluster -f cluster-config.yaml\n</code></pre> <p>In order to use the Weave GitOps container product, your cluster must be configured to run containers with the correct IAM Policies.</p> <p>The recommended way to do this is via IRSA.</p> <p>Use this <code>eksctl</code> configuration below (replacing the placeholder values) to: - Associate an OIDC provider - Create the required service account ARN</p> <p>Save the example below as <code>oidc-config.yaml</code></p> Expand for file contents oidc-config.yaml<pre><code>---\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\nmetadata:\nname: CLUSTER_NAME # Change this\nregion: REGION # Change this\n\n# This section is required\niam:\nwithOIDC: true\nserviceAccounts:\n- metadata:\nname: wego-service-account # Altering this will require a corresponding change in a later command\nnamespace: flux-system\nroleOnly: true\nattachPolicy:\nVersion: \"2012-10-17\"\nStatement:\n- Effect: Allow\nAction:\n- \"aws-marketplace:RegisterUsage\"\nResource: '*'\n</code></pre> <pre><code>eksctl utils associate-iam-oidc-provider -f oidc-config.yaml --approve\neksctl create iamserviceaccount -f oidc-config.yaml --approve\n</code></pre>"},{"location":"open-source/aws-marketplace/#step-3-fetch-the-service-account-role-arn","title":"Step 3: Fetch the Service Account Role ARN","text":"<p>First retrieve the ARN of the IAM role which you created for the <code>wego-service-account</code>:</p> <pre><code># replace the placeholder values with your configuration\n# if you changed the service account name from wego-service-account, update that in the command\nexport SA_ARN=$(eksctl get iamserviceaccount --cluster &lt;cluster-name&gt; --region &lt;region&gt; | awk '/wego-service-account/ {print $3}')\n\necho $SA_ARN\n# should return\n# arn:aws:iam::&lt;account-id&gt;:role/eksctl-&lt;cluster-name&gt;-addon-iamserviceaccount-xxx-Role1-1N41MLVQEWUOF\n</code></pre> <p>This value will also be discoverable in your IAM console, and in the Outputs of the Cloud Formation template which created it.</p>"},{"location":"open-source/aws-marketplace/#step-4-install-weave-gitops","title":"Step 4: Install Weave GitOps","text":"<p>Copy the Chart URL from the Usage Instructions in AWS Marketplace, or download the file from the Deployment template to your workstation.</p> <p>To be able to log in to your new installation, you need to set up authentication. Create a new file <code>values.yaml</code> where you set your username, and a bcrypt hash of your desired password, like so:</p> ./values.yaml<pre><code>gitops:\nadminUser:\ncreate: true\nusername: &lt;UPDATE&gt;\npasswordHash: &lt;UPDATE&gt;\n</code></pre> <p>Then install it:</p> Using the default Service Account NameUsing a configured Service Account Name <pre><code>helm install wego &lt;URL/PATH&gt; \\\n--namespace=flux-system \\\n--create-namespace \\\n--set serviceAccountRole=\"$SA_ARN\" \\\n--values ./values.yaml\n</code></pre> <pre><code>helm install wego &lt;URL/PATH&gt; \\\n--namespace=flux-system \\\n--create-namespace \\\n--set serviceAccountName='&lt;name&gt;' \\\n--set serviceAccountRole=\"$SA_ARN\" \\\n--values ./values.yaml\n</code></pre>"},{"location":"open-source/aws-marketplace/#step-5-check-your-installation","title":"Step 5: Check your installation","text":"<p>Run the following from your workstation:</p> <pre><code>kubectl get pods -n flux-system\n# you should see something like the following returned\nflux-system          helm-controller-5b96d94c7f-tds9n                    1/1     Running   0          53s\nflux-system          kustomize-controller-8467b8b884-x2cpd               1/1     Running   0          53s\nflux-system          notification-controller-55f94bc746-ggmwc            1/1     Running   0          53s\nflux-system          source-controller-78bfb8576-stnr5                   1/1     Running   0          53s\nflux-system          wego-metering-f7jqp                                 1/1     Running   0          53s\nflux-system          ww-gitops-weave-gitops-5bdc9f7744-vkh65             1/1     Running   0          53s\n</code></pre> <p>Your Weave GitOps installation is now ready!</p>"},{"location":"open-source/deploy-oss/","title":"Step 3: Deploy an Application","text":"<p>Now that you have a feel for how to navigate the dashboard, let's deploy a new application. In this section we will use podinfo as our sample web application.</p>"},{"location":"open-source/deploy-oss/#deploying-podinfo","title":"Deploying podinfo","text":"<ol> <li>Clone or navigate back to your Git repository where you have bootstrapped Flux. For example:</li> </ol> <pre><code>git clone https://github.com/$GITHUB_USER/fleet-infra\ncd fleet-infra\n</code></pre> <ol> <li>Create a <code>GitRepository</code> Source for podinfo. This will allow you to use different authentication methods for different repositories.</li> </ol> <pre><code>flux create source git podinfo \\\n  --url=https://github.com/stefanprodan/podinfo \\\n  --branch=master \\\n  --interval=30s \\\n  --export &gt; ./clusters/management/podinfo-source.yaml\n</code></pre> <p>More information about <code>GitRepository</code> is available here. </p> <p>If you get stuck here, try the <code>ls</code> command to list your files and directories. If that doesn\u2019t work, try <code>ls -l ./clusters</code>.</p> <ol> <li>Commit and push the <code>podinfo-source</code> to your <code>fleet-infra</code> repository</li> </ol> <pre><code>git add -A &amp;&amp; git commit -m \"Add podinfo source\"\ngit push\n</code></pre> <ol> <li>Create a <code>kustomization</code> to build and apply the podinfo manifest</li> </ol> <pre><code>flux create kustomization podinfo \\\n  --target-namespace=flux-system \\\n  --source=podinfo \\\n  --path=\"./kustomize\" \\\n  --prune=true \\\n  --interval=5m \\\n  --export &gt; ./clusters/management/podinfo-kustomization.yaml\n</code></pre> <ol> <li>Commit and push the <code>podinfo-kustomization</code> to your <code>fleet-infra</code> repository</li> </ol> <pre><code>git add -A &amp;&amp; git commit -m \"Add podinfo kustomization\"\ngit push\n</code></pre>"},{"location":"open-source/deploy-oss/#view-the-application-in-weave-gitops","title":"View the Application in Weave GitOps","text":"<p>Flux will detect the updated <code>fleet-infra</code> and add podinfo. Navigate back to the dashboard to make sure that the podinfo application appears.</p> <p></p> <p>Click on podinfo to find details about the deployment. There should be two pods available.</p> <p></p> <p>Info</p> <p>Podinfo comes with a HorizontalPodAutoscaler, which uses the <code>metrics-server</code>. We don't use the <code>metrics-server</code> in this tutorial, but note that it's the reason why HorizontalPodAutoscaler will report as <code>Not ready</code> in your dashboard. We recommend ignoring the warning.</p>"},{"location":"open-source/deploy-oss/#customize-podinfo","title":"Customize podinfo","text":"<p>To customize a deployment from a repository you don\u2019t control, you can use Flux in-line patches. The following example shows how to use in-line patches to change the podinfo deployment.</p> <ol> <li>Add the <code>patches</code> section as shown below to the field spec of your <code>podinfo-kustomization.yaml</code> file so it looks like this:</li> </ol> Expand to see Kustomization patches ./clusters/management/podinfo-kustomization.yaml<pre><code>---\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\nname: podinfo\nnamespace: flux-system\nspec:\ninterval: 60m0s\npath: ./kustomize\nprune: true\nsourceRef:\nkind: GitRepository\nname: podinfo\ntargetNamespace: flux-system\n// highlight-start\npatches:\n- patch: |-\napiVersion: autoscaling/v2beta2\nkind: HorizontalPodAutoscaler\nmetadata:\nname: podinfo\nspec:\nminReplicas: 3\ntarget:\nname: podinfo\nkind: HorizontalPodAutoscaler\n// highlight-end\n</code></pre> <ol> <li>Commit and push the <code>podinfo-kustomization.yaml</code> changes:</li> </ol> <pre><code>git add -A &amp;&amp; git commit -m \"Increase podinfo minimum replicas\"\ngit push\n</code></pre> <ol> <li>Navigate back to the dashboard. You should see a newly created pod:</li> </ol> <p></p>"},{"location":"open-source/deploy-oss/#suspend-updates","title":"Suspend updates","text":"<p>Suspending updates to a kustomization allows you to directly edit objects applied from a kustomization, without your changes being reverted by the state in Git.</p> <p>To suspend updates for a kustomization, from the details page, click on the suspend button at the top, and you should see it be suspended:</p> <p></p> <p>This shows in the applications view with a yellow warning status indicating it is now suspended</p> <p></p> <p>To resume updates, go back to the details page, click the resume button, and after a few seconds reconsolidation will continue.</p>"},{"location":"open-source/deploy-oss/#delete-podinfo","title":"Delete Podinfo","text":"<p>To delete Podinfo in the GitOps way, run this command from the root of your working directory:</p> <pre><code>  rm ./clusters/management/podinfo-kustomization.yaml\n  rm ./clusters/management/podinfo-source.yaml\n  git add -A &amp;&amp; git commit -m \"Remove podinfo kustomization and source\"\n  git push\n</code></pre>"},{"location":"open-source/deploy-oss/#complete","title":"Complete!","text":"<p>Congratulations \ud83c\udf89\ud83c\udf89\ud83c\udf89</p> <p>You've now completed the getting started guide. We welcome any and all feedback, so please let us know how we could have made your experience better.</p>"},{"location":"open-source/install-oss/","title":"Step 1: Install Weave GitOps Open Source on Your Cluster","text":"<p>Tip</p> <p>These instructions only apply to Weave GitOps Open Source. To install Weave GitOps Enterprise, go here.</p> <p>This page covers Weave GitOps Open Source installation and is adapted from the Flux - Getting Started guide.</p> <p>If you haven't already, please check out our Introduction to Weave GitOps page for additional information about Weave GitOps Open Source as well as our Enterprise version.</p>"},{"location":"open-source/install-oss/#prerequisites","title":"Prerequisites","text":"<p>Before you can install Weave GitOps Open Source, you will need:</p> <ul> <li>An account with a Git provider like GitHub or GitLab, along with a personal access token with repo permissions; if you're using GitHub, for example, go here</li> <li>Your Git client configured properly (if using GitHub, for example, then review their docs on setting your username and your email address)</li> <li>Docker Desktop</li> <li>A Kubernetes cluster such as Kind</li> <li>kubectl</li> <li>A public GitHub repo called <code>fleet-infra</code>. To create this, follow GitHub\u2019s instructions\u2014using <code>fleet-infra</code> instead of <code>hello-world</code>.</li> </ul> <p>We also recommend taking a look at the Flux Core Concepts page if you need to brush up on terminology.</p>"},{"location":"open-source/install-oss/#check-your-clusters-kubernetes-version","title":"Check your Cluster's Kubernetes Version","text":"<p>No matter which version of Weave GitOps you install, you need to have a Kubernetes cluster up and running. We test Weave GitOps against the latest supported Kubernetes releases.</p> <p>Note that the version of Flux that you use might impose further minimum version requirements.</p>"},{"location":"open-source/install-oss/#install-flux","title":"Install Flux","text":"<p>Weave GitOps is an extension to Flux. Therefore, it requires that Flux 0.32 or a later version has already been installed on your Kubernetes cluster. Full documentation is available here.</p> <p>In this section we are going to do the following:</p> <ul> <li>Add Flux component manifests to the repository</li> <li>Deploy Flux components to your Kubernetes cluster</li> <li>Configure the Flux components to track the path <code>./clusters/my-cluster/</code> in the repository</li> </ul> <p>Let's get into it... </p>"},{"location":"open-source/install-oss/#install-the-flux-cli","title":"Install the Flux CLI","text":"<pre><code>brew install fluxcd/tap/flux\n</code></pre> <p>To upgrade to the latest version, run this command:</p> <pre><code>brew upgrade fluxcd/tap/flux\n</code></pre> <p>We recommend upgrading the CLI before running bootstrap to upgrade the controllers with <code>flux bootstrap</code>.</p> <p>Find which version is installed with <code>flux -v</code>, and use that for <code>flux bootstrap --version=v&lt;CLI-VERSION&gt;</code>.</p> <p>With Bash, you can run <code>sudo curl -s https://fluxcd.io/install.sh | sudo FLUX_VERSION=&lt;VERSION&gt; bash</code>.</p> <p>Tip</p> <p>If you want to install an older version of Flux CLI, you can download the binary for your OS from the releases page.</p> <p>For other installation methods, see the relevant Flux documentation.</p>"},{"location":"open-source/install-oss/#export-your-credentials","title":"Export your credentials","text":"<p>Ensure your PAT has <code>repo</code> scope.</p> <pre><code>export GITHUB_TOKEN=&lt;your-token&gt;\nexport GITHUB_USER=&lt;your-username&gt;\n</code></pre>"},{"location":"open-source/install-oss/#check-your-kubernetes-cluster","title":"Check your Kubernetes cluster","text":"<pre><code>flux check --pre\n</code></pre> <p>The output is similar to:</p> <pre><code>\u25ba checking prerequisites\n\u2714 kubernetes 1.22.2 &gt;=1.20.6\n\u2714 prerequisites checks passed\n</code></pre>"},{"location":"open-source/install-oss/#install-flux-onto-your-cluster-with-the-flux-bootstrap-command","title":"Install Flux onto your cluster with the <code>flux bootstrap</code> command","text":"<p><code>flux bootstrap</code> creates a <code>flux system</code> folder in your repository that includes the manifests Flux needs to operate. It also generates a key value pair for Flux to access the repo.</p> <p>The command below assumes the Git provider is <code>github</code>. If you would rather use GitLab, change this to <code>gitlab</code>.</p> <pre><code>flux bootstrap github \\\n  --owner=$GITHUB_USER \\\n  --repository=fleet-infra \\\n  --branch=main \\\n  --path=./clusters/my-cluster \\\n  --personal \\\n  --components-extra image-reflector-controller,image-automation-controller\n</code></pre> <p>Full installation documentation, including how to work with other Git providers, is available here.</p>"},{"location":"open-source/install-oss/#install-the-gitops-cli","title":"Install the <code>gitops</code> CLI","text":"<p>Weave GitOps includes a command-line interface to help users create and manage resources. The <code>gitops</code> CLI is currently supported on Mac (x86 and Arm) and Linux, including Windows Subsystem for Linux (WSL). Windows support is a planned enhancement.</p> <p>There are multiple ways to install the <code>gitops</code> CLI:</p> CurlHomebrew <pre><code>curl --silent --location \"https://github.com/weaveworks/weave-gitops/releases/download/v0.36.0/gitops-$(uname)-$(uname -m).tar.gz\" | tar xz -C /tmp\nsudo mv /tmp/gitops /usr/local/bin\ngitops version\n</code></pre> <pre><code>brew tap weaveworks/tap\nbrew install weaveworks/tap/gitops\n</code></pre>"},{"location":"open-source/install-oss/#deploy-weave-gitops","title":"Deploy Weave GitOps","text":"<p>In this section we will:</p> <ul> <li>use the GitOps CLI tool to generate <code>HelmRelease</code> and <code>HelmRepository</code> objects.</li> <li>create some login credentials to access the dashboard. This is a simple but insecure   method of protecting and accessing your GitOps dashboard.</li> <li>commit the generated yamls to our <code>fleet-infra</code> repo.</li> <li>observe that they are synced to the cluster.</li> </ul>"},{"location":"open-source/install-oss/#clone-your-git-repository-where-flux-has-been-bootstrapped","title":"Clone your Git repository where Flux has been bootstrapped","text":"<pre><code>git clone https://github.com/$GITHUB_USER/fleet-infra\ncd fleet-infra\n</code></pre> <p>If you have difficulty saving the YAML to the correct path, run the command <code>mkdir -p ./clusters/my-cluster</code>.</p>"},{"location":"open-source/install-oss/#deploy","title":"Deploy","text":"<p>Run the following command, which will create a <code>HelmRepository</code> and <code>HelmRelease</code> to deploy Weave GitOps:</p> <pre><code>PASSWORD=\"&lt;A new password you create, removing the brackets and including the quotation marks&gt;\"\ngitops create dashboard ww-gitops \\\n  --password=$PASSWORD \\\n  --export &gt; ./clusters/my-cluster/weave-gitops-dashboard.yaml\n</code></pre> <p>Warning</p> <p>This command stores a hash of a password. This is relatively safe for demo and testing purposes, but we strongly recommend using a more secure method of storing secrets (such as Flux's SOPS integration) for production systems.</p> <p>Our docs on securing access to the dashboard provide additional guidance and alternative login methods.</p> <p>You will use the password you've just created when you've finished Weave GitOps Open Source installation and are ready to login to the dashboard UI.</p> <p>Tip</p> <p>If you need to customize the Weave GitOps Helm release, you can use the <code>--values</code> CLI flag to supply one or more values files.</p>"},{"location":"open-source/install-oss/#commit-and-push-the-weave-gitops-dashboardyaml-to-the-fleet-infra-repository","title":"Commit and push the <code>weave-gitops-dashboard.yaml</code> to the <code>fleet-infra</code> repository","text":"<pre><code>git add -A &amp;&amp; git commit -m \"Add Weave GitOps Dashboard\"\ngit push\n</code></pre>"},{"location":"open-source/install-oss/#validate-that-weave-gitops-and-flux-are-installed","title":"Validate that Weave GitOps and Flux are installed","text":"<p>Note: this wont be instantaneous. Give the Flux controllers a couple of minutes to pull the latest commit.</p> <pre><code>kubectl get pods -n flux-system\n</code></pre> <p>You should see something similar to:</p> <pre><code>NAME                                       READY   STATUS    RESTARTS   AGE\nhelm-controller-5bfd65cd5f-gj5sz           1/1     Running   0          10m\nkustomize-controller-6f44c8d499-s425n      1/1     Running   0          10m\nnotification-controller-844df5f694-2pfcs   1/1     Running   0          10m\nsource-controller-6b6c7bc4bb-ng96p         1/1     Running   0          10m\nww-gitops-weave-gitops-86b645c9c6-k9ftg    1/1     Running   0          5m\n</code></pre> <p>If you wait for a while and still nothing happens, it might be that your manifests haven\u2019t been exported to the repository. This means that Weave GitOps won't install.</p> <p>Tip</p> <p>You can use the Weave GitOps Helm Chart to customize your installation. Find the full Chart reference here.</p>"},{"location":"open-source/install-oss/#next-steps","title":"Next steps","text":"<p>Now let's explore the Weave GitOps Open Source UI. Then, we'll deploy an application.</p>"},{"location":"open-source/run-ui-subpath/","title":"Optional: Running the UI on a Subpath","text":""},{"location":"open-source/run-ui-subpath/#running-the-ui-on-a-subpath","title":"Running the UI on a subpath","text":"<p>By default, the UI is served on the root path <code>/</code>. It is possible to run the UI on a subpath, for example <code>/weave-gitops</code>. This is useful if you want to run weave-gitops alongside other applications on the same domain.</p> <p>To run the UI on a subpath, you need to set the <code>--route-prefix</code> flag on the weave-gitops server. For example, if you want to run the UI on <code>/weave-gitops</code>, you can set the flag to <code>--route-prefix=/weave-gitops</code>.</p> <p>To set the flag we use the <code>additionalArgs</code> field in the <code>spec.values</code> section of the weave-gitops <code>HelmRelease</code>.</p> <pre><code>spec:\nvalues:\nadditionalArgs:\n- --route-prefix=/weave-gitops\n</code></pre>"},{"location":"open-source/run-ui-subpath/#ingress","title":"Ingress","text":"<p><code>Ingress</code> is a Kubernetes resource that allows you to expose your application to the internet. Please refer to the Kubernetes documentation for more information about a complete <code>Ingress</code> configuration. It often depends on the Kubernetes provider you are using and your particular setup.</p> <p>The Weave GitOps Helm chart can generate an <code>Ingress</code> resource to integrate with the ingress controller you have configured for your cluster. To enable ingress generation set the <code>ingress.enabled</code> field to <code>true</code>.</p> <ul> <li>If you are running the UI on a subpath, you need to set the <code>path</code> field to the same subpath specified in the <code>--route-prefix</code> flag.</li> <li>If you have not set a subpath on the weave-gitops server, set the path in the ingress configration to <code>/</code>.</li> </ul> <pre><code>spec:\nvalues:\ningress:\nenabled: true\nhosts:\n- host: \"\"\npaths:\n- path: /wego # set the path to `/` if you have not set the `--route-prefix` flag \npathType: Prefix\n</code></pre> <p>See the Helm chart reference for a list of all supported ingress options.</p>"},{"location":"open-source/ui-oss/","title":"Step 2: Explore the Weave GitOps Open Source UI","text":"<p>The Weave GitOps user interface enables you to manage and view all of your applications in one place. This documentation gives you an overview of the Weave GitOps Open Source UI.</p> <p>Tip</p> <p>To check out Weave GitOps Enterprise's UI, which provides an even richer user experience, please contact sales@weave.works.</p>"},{"location":"open-source/ui-oss/#overview","title":"Overview","text":"<p>A quick preview of what the Weave GitOps Open Source UI provides: * an Applications view that shows summary information from\u00a0<code>Kustomization</code>\u00a0and\u00a0<code>HelmRelease</code>\u00a0objects so that you can quickly understand the state of your deployments across a cluster. * a Sources view that shows summary information from\u00a0gitrepository,\u00a0helmrepository\u00a0and\u00a0bucket\u00a0objects and tells you the current status of resources that are synchronizing content from where you\u2019ve declared the desired state of your system\u2014for example, Git repositories. * a Flux Runtime view that provides the status of the GitOps engine that continuously reconciles your desired and live state. It shows your installed GitOps Toolkit Controllers and version. * an Image Automation view that reduces GitOps friction, particularly in non-production environments, by enabling you to discover repositories, policies, and updates on your cluster. Deploy the latest image in a dev or staging environment with minimal fuss, and keep your platform updated with the latest approved versions\u2014for example, patch releases to reduce exposure to CVEs. Auto-deploy when approval is gated before the image is added to an internal registry. * A Notifications View that leverages Flux's notification controller to show which notifications are already configured within the UI. This enables WeGO users to set up and receive notifications from Weave GitOps. Here you can find the list of providers. If you\u2019re a platform operator, this view will help you to understand your egress topology across clusters so you\u2019ll know where events are being sent beyond your clusters. * multiple views for debugging. * a dark mode option.</p> <p>It also enables you to: * sync your latest Git commits directly from the UI * leverage Kubernetes RBAC to control permissions in the dashboard</p> <p>Let's dive in.</p>"},{"location":"open-source/ui-oss/#login-to-the-gitops-dashboard","title":"Login to the GitOps Dashboard","text":"<p>First, expose the service running on the cluster with this command:</p> <pre><code>kubectl port-forward svc/ww-gitops-weave-gitops -n flux-system 9001:9001\n</code></pre> <p>Next, open the dashboard and login using either the emergency cluster user or OIDC, based on your configuration. (Note: The same directions for WGE apply to OSS for this step.)     If you followed the example above, the emergency user will be configured with the username set to <code>admin</code>. This means that you can use \u201cadmin\u201d as your user name, and the password that you set earlier during installation as <code>$PASSWORD</code>.</p> <p></p> <p>The label of the OIDC button on the login screen is configurable via a feature flag environment variable. This can give your users a more familiar experience when logging in.</p> <p>Adjust the configuration in the Helm <code>values.yaml</code> file or the <code>spec.values</code> section of the Weave GitOps <code>HelmRelease</code> resource:</p> <pre><code>envVars:\n- name: WEAVE_GITOPS_FEATURE_OIDC_BUTTON_LABEL\nvalue: \"Login with ACME\"\n</code></pre>"},{"location":"open-source/ui-oss/#the-applications-view","title":"The Applications View","text":"<p>Upon login you're taken to the Applications view, which allows you to quickly understand the state of your deployments and shows summary information from <code>Kustomization</code> and <code>HelmRelease</code> objects. You can apply dark mode using the toggle switch in the top right corner.</p> <p></p> <p>In the above screenshot you can see: - two <code>Kustomizations</code> called <code>podinfo</code> and <code>canaries</code> corresponding to the applications with the same names. The source referenced by <code>podinfo</code> is <code>shipping-service-podinfo</code> which has been verified whereas the one referenced by <code>canaries</code> does not have verification set up. - three <code>HelmReleases</code> called <code>weave-gitops-enterprise</code>, <code>tf-controller</code> and <code>podinfo</code> which deploys the respective Helm Charts.</p> <p>The table view shows you the reported status so you can understand whether a reconciliation has been successful, and when it was last updated. You can also see where the Flux objects are deployed, which <code>Source</code> object they are reconciling from and whether or not that <code>Source</code> is verified (this requires verification to have been set up for the source). Clicking the name of the Source will take you to a detail view for the given Source object. The view automatically updates every few seconds so you know the current state of your system.</p> <p>Tip</p> <p>For more information about Sources, please take a look at the Flux documentation.</p> <p>For information on Source verification, you can check: - Flux documentation - GitRepository verification - Flux documentation - OCIRepository verification</p> <p>If verification is not set up for the repository, this will appear blank in the UI.</p> <p>More actions you can take: * Click the magnifying glass icon to search for and filter objects by <code>Name</code>. * Filter by <code>Type</code> by clicking the strawberry icon to its right. * Click the <code>Name</code> of an object to get a detailed view for the given <code>Kustomization</code> or <code>HelmRelease</code>. (You'll see this again in the Sources view.) * In the main Applications view, you can use the checkbox to the left of your listed applications to select them and perform actions from the actions menu at the top. These actions are Sync (reconcile), Suspend, and Resume, and they affect Flux resources.</p>"},{"location":"open-source/ui-oss/#a-closer-look-exploring-the-flux-system-deployment","title":"A Closer Look: Exploring the flux-system Deployment","text":"<p>Let's explore the <code>flux-system</code> Kustomization. Navigate back to the <code>Applications</code> view, and click on the <code>flux-system</code> object.</p> <p></p> <p>It might take a few moments for the data to load. Once it does, you should get a result that resembles the above screenshot. Here you can find key information about how the resource is defined: * which <code>Source</code> it is reading from * the latest applied commit * the exact path with the Source repository that is being deployed * the <code>Interval</code> where Flux will look to reconcile any differences between the declared and live state. For example, if a <code>kubectl</code> patch has been applied on the cluster, it will effectively be reverted. If a longer error message is reported by this object, you'll be able to see it in its entirety on this page.</p> <p>Underneath the summary information you'll find:</p> <ul> <li>The Details (default) table view, which shows all the Kubernetes objects (including Flux objects, deployments, pods, services, etc.) managed and deployed through this <code>kustomization</code>.</li> <li>The Events tab (shown below), which shows related Kubernetes events to help you diagnose issues and understand health over time.</li> <li>The Reconciliation Graph (shown below), which provides an alternative to the Details view and helps you to understand how various objects relate to each other.</li> <li>Dependencies, which provides a directional graph to help you clarify any dependencies between objects and ensure that your automations are set up in the correct order.</li> <li>Yaml (shown below), which provides a raw dump yaml view on the object as it currently exists inside your cluster. Note that this will be different from what's in your GitOps repository.</li> </ul> <p>Events tab </p> <p>Reconciliation Graph tab </p> <p>Yaml tab </p>"},{"location":"open-source/ui-oss/#the-sources-view","title":"The Sources View","text":"<p>In the left-hand menu of the UI, click on the Sources view. This will show you where Flux pulls its application definitions from\u2014for example, Git repositories\u2014and the current state of that synchronization. Sources shows summary information from <code>GitRepository</code>, <code>HelmRepository</code>, <code>HelmChart</code>, and <code>Bucket</code> objects.</p> <p></p> <p>In the above screenshot you can see: - a <code>GitRepository</code> called <code>shipping-service-podinfo</code> - an <code>OCIRepository</code> called <code>podinfo-oci</code></p> <p>These have both had verification set up on them which has been completed successfully.</p> <p>The Sources table view displays information about status so that you can see whether Flux has been able to successfully pull from a given source, and which specific commit was last detected. It shows you key information like the <code>Interval</code>\u2014namely, how frequently Flux will check for updates in a given source location. You can also see whether or not that source is verified (if this is something that you have set up for the specific source).</p> <p>Actions you can take: * Apply filtering as you did the Applications view. * Click a <code>URL</code> to navigate to a given source\u2014i.e. a repository in GitHub\u2014or the <code>Name</code> of a <code>Source</code> to view more details about it.</p> <p>Go back to the Details tab, and click <code>GitRepository/flux-system</code> from the summary at the top of the page.</p> <p></p> <p>As with an Application detail view, you can see key information about how the resource is defined.</p>"},{"location":"open-source/ui-oss/#the-image-automation-view","title":"The Image Automation View","text":"<p>Maybe you're an app developer who wants to deploy the latest image in a dev/staging environment with as minimal fuss as possible and reduce GitOps friction. Or you might be a platform engineer who wants to keep your platform up-to-date with the latest approved versions\u2014for example, patch releases to reduce exposure to CVEs\u2014or auto-deploy when approval is gated before adding an image to an internal registry. The Image Automation view can help.</p> <p>WeGO's Image Automation view allows users to configure automatic updates to their workloads based on the detection of a new image tag in a repository. For application developers, this means faster deployments and shorter feedback cycles to easily verify changes to an application in a Kubernetes environment. The view still supports GitOps workflows as the changes are committed back to Git\u2014either to the branch already reconciled by Flux, or to an alternative branch so that a Pull Request can be generated and peer review can occur. </p> <p>Image Automation refers to Flux's ability to update the image tag specified in a manifest based on detection of a newer image and automatically deploy to a cluster. It involves three required objects\u2014ImageRepositories, ImagePolicies, and ImageUpdateAutomations\u2014which WeGO OSS users can discover on their clusters. Users can also view object details either through a YAML-like view, as we do for most non-Flux objects, or a details view. The UI makes it possible to suspend or resume ImageRepositories and ImageUpdateAutomations so that Flux stops looking for new updates or committing these to Git. Also, the UI shows whether all required resources are configured and assists with Image Policy to show the latest image. </p> <p>ImageRepositories, ImagePolicies, and ImageUpdateAutomations are used by Flux's Image Automation Controllers. The Image Reflector controller and the Image Automation controller work together to update a Git repository when new container images are available. In WeGO OSS, if the image-reflector-controller and or image-automation-controller are not installed on a cluster, a warning message will display.</p> <p>If you make a mistake configuring one of the resources, you can use WeGO to easily trace from the Image Repository scan, see whether it is able to select the image based on the Image Policy, and detect whether an Image Update has successfully run. This provides greater visibility into the machinery provided by Flux and enables quicker troubleshooting than what's possible by hunting via the Flux CLI. App devs can triage issues without depending on their platform teams.</p>"},{"location":"open-source/ui-oss/#the-flux-runtime-view","title":"The Flux Runtime View","text":"<p>Let's go back to the left-hand menu of the UI and click on <code>Flux Runtime</code>. This view provides information on the GitOps engine, which continuously reconciles your desired and live state, and helps users to know which apiVersion to use in manifests. It comes with two tabs: one for controllers, and other for custom resource definitions (CRDs).</p>"},{"location":"open-source/ui-oss/#controllers","title":"Controllers","text":"<p>The Controllers tab shows your installed GitOps Toolkit Controllers and their version.</p> <p></p> <p>By default, <code>flux bootstrap</code> will install the following controllers: - helm-controller - kustomize-controller - notification-controller - source-controller</p> <p>From this view you can see whether the controllers are healthy and which version of a given component is currently deployed.</p>"},{"location":"open-source/ui-oss/#crds","title":"CRDs","text":"<p>The CRD tab lists the custom resources that the GitOps Toolkit Controllers use. This allows you to see which resources you will be able to create.</p> <p></p>"},{"location":"open-source/ui-oss/#moving-on","title":"Moving On","text":"<p>Now that we are familiar with the dashboard, let's deploy a new application .</p>"},{"location":"pipelines/","title":"Pipelines ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>Weave GitOps Enterprise Pipelines enables teams to increase the velocity, stability, and security of software systems via automated deployment pipelines. It provides insights into new application versions that are being rolled out across clusters and environments, which allows you to implement security guardrails and track metrics to assess if the application is working as desired. In instances of failures, the change is abandoned with an automatic rollout of the older version.</p> <p>With Pipelines, you define a release pipeline for a given application as a custom resource. The pipeline can comprise any number of environments through which an application is expected to be deployed. Push a change to your application in your dev environment, for example, and watch the update roll out across staging and production environments all from a single PR (or an external process like Jenkins)\u2014with Weave GitOps Enterprise orchestrating everything. </p> <p>Designed with flexibility in mind, Pipelines can be easily integrated within your existing CI setup\u2014for example, CircleCI, Jenkins, Tekton, or GitHub Actions.</p>"},{"location":"pipelines/#benefits-to-developers","title":"Benefits to Developers","text":"<p>The Pipelines feature: - reduces toil and errors when setting up a new pipeline or reproducing previous pipelines through YAML constructs - saves time and overhead with automated code rollout from one environment to another, with minimal intervention from the Ops team - enables users to observe code progression and track application versions through different environments from the Weave GitOps UI - streamlines code deployment from one environment to another, and minimizes friction between application development and Ops teams - enables you to easily define which Helm charts are part of the environments you create\u2014saving lots of time through automated package management</p> <p>Now that you know what delivery pipelines can do for you, follow the guide to get started.</p>"},{"location":"pipelines/authorization/","title":"Authorization ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>To view pipelines, users need read access to the <code>pipeline</code> resource and the underlying <code>application</code> resources. This sample configuration shows a recommended way to configure RBAC to provide such access. The <code>pipeline-reader</code> role and the <code>search-pipeline-reader</code> role-binding allow a group <code>search-developer</code> to access pipeline resources within the <code>search</code> namespace.</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: pipeline-reader\nrules:\n- apiGroups: [ \"pipelines.weave.works\" ]\nresources: [ \"pipelines\" ]\nverbs: [ \"get\", \"list\", \"watch\"]\n- apiGroups: [\"helm.toolkit.fluxcd.io\"]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\", \"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: search-pipeline-reader\nnamespace: search\nsubjects:\n- kind: Group\nname: search-developer\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: ClusterRole\nname: pipeline-reader\napiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"pipelines/pipelines-getting-started/","title":"Getting Started with Pipelines ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p>"},{"location":"pipelines/pipelines-getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before using Pipelines, please ensure that: - You have Weave GitOps Enterprise installed on a cluster. - You have configured Weave GitOps Enterprise RBAC for Pipelines. - The Pipelines feature flag <code>enablePipelines</code> has been enabled. This flag is part of the Weave GitOps Enterprise Helm chart values and is enabled by default. - Any leaf clusters running workloads that you need to visualise using Pipelines have been added to Weave GitOps Enterprise. - You have exposed the promotion webhook  on the management cluster and leaf clusters can reach that webhook endpoint over the network.</p>"},{"location":"pipelines/pipelines-getting-started/#define-a-pipeline","title":"Define a Pipeline","text":"<p>A pipeline allows you to define the route your application is taking, so that you can get it to production. Three main concepts are at play: - the <code>application</code> to deliver - the <code>environments</code> that your app will go through on its way to production (general). An environment describes the different stages of a pipeline and consists of one or more deployment targets. - the <code>deployment targets</code>, the clusters that each environment has. A deployment target consists of a namespace and a <code>GitOpsCluster</code> reference and is used to specify where the application is running in your fleet. </p> <p>You can define a delivery pipeline using a <code>Pipeline</code> custom resource. An example of such a CR is shown here:</p> Expand to view <pre><code>---\napiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\nname: podinfo-02\nnamespace: flux-system\nspec:\nappRef:\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nname: podinfo\nenvironments:\n- name: dev\ntargets:\n- namespace: podinfo-02-dev\nclusterRef:\nkind: GitopsCluster\nname: dev\nnamespace: flux-system\n- name: test\ntargets:\n- namespace: podinfo-02-qa\nclusterRef:\nkind: GitopsCluster\nname: dev\nnamespace: flux-system\n- namespace: podinfo-02-perf\nclusterRef:\nkind: GitopsCluster\nname: dev\nnamespace: flux-system\n- name: prod\ntargets:\n- namespace: podinfo-02-prod\nclusterRef:\nkind: GitopsCluster\nname: prod\nnamespace: flux-system\n</code></pre> <p>In the example above, the <code>podinfo</code> application is delivered to a traditional pipeline composed of <code>dev</code>, <code>test</code>, and <code>prod</code> environments. In this case, the <code>test</code> environment consists of two deployment targets, <code>qa</code> and <code>perf</code>. This is to indicate that, although both targets are part of the same stage (testing), they can evolve separately and may run different versions of the application. Note that two clusters, <code>dev</code> and <code>prod</code>, are used for the environments; both  are defined in the <code>flux-system</code> namespace.</p> <p>For more details about the spec of a pipeline, go here.</p>"},{"location":"pipelines/pipelines-getting-started/#view-your-list-of-pipelines","title":"View Your List of Pipelines","text":"<p>Once Flux has reconciled your pipeline, you can navigate to the Pipelines view in the WGE UI to see the list of pipelines to which you have access.</p> <p></p> <p>For each pipeline, the WGE UI shows a simplified view with the application <code>Type</code> and <code>Environments</code> it goes through.</p>"},{"location":"pipelines/pipelines-getting-started/#view-pipeline-details","title":"View Pipeline Details","text":"<p>Once you have selected a pipeline from the list, navigate to its details view where you can see the current status of your application by environment and deployment target.</p> <p></p>"},{"location":"pipelines/pipelines-templates/","title":"Using GitOpsTemplates for Pipelines ENTERPRISE","text":"<p>To create new Pipelines and their required resources from within Weave GitOps Enterprise, you can leverage GitOpsTemplates, which help platform teams scale for developer self-service.</p> <p>This document provides example configuration that you can adapt and use within your own organization, based on your tenancy model.</p> <p>We will cover the creation of:</p> <ul> <li>Pipelines</li> <li>Alerts</li> <li>Providers</li> </ul> <p>Secrets, required for authentication and authorization between leaf and management clusters as well as to Git, are out of scope for this document and must be handled by your chosen secret management solution.</p> <p>For advice on Secrets Management, refer to the Flux guide.</p> <p>Templates can include a single resource or multiple resources, depending on your use case. For example, you may want to only create the Pipeline custom resource to associate existing HelmReleases. Or, you can create the HelmReleases, notification controller resources, and Pipeline all in a single template. They are highly customizable to meet the needs of your teams.</p>"},{"location":"pipelines/pipelines-templates/#adding-new-resources-from-within-the-weave-gitops-enterprise-dashboard","title":"Adding New Resources From Within the Weave GitOps Enterprise Dashboard","text":"<p>GitOpsTemplates are custom resources installed onto a management cluster where Weave GitOps Enterprise resides. To add a new Pipeline, click <code>Create a Pipeline</code> from within the Pipeline view. This will take you to a pre-filtered list of templates with the label: <code>weave.works/template-type: pipeline</code>.</p> <p></p> <p>The <code>Templates</code> view (shown below) lists all templates for which a given user has the appropriate permission to view. You can install GitOpsTemplates into different namespaces and apply standard Kubernetes RBAC to limit which teams can utilize which templates. You can also configure policy to enforce permitted values within a template.</p> <p></p>"},{"location":"pipelines/pipelines-templates/#example-gitopstemplates","title":"Example: GitOpsTemplates","text":"<p>This section provides examples to help you build your own templates for Pipelines.</p>"},{"location":"pipelines/pipelines-templates/#pipeline-visualization-only","title":"Pipeline: Visualization Only","text":"<p>Included Sample</p> <p>This default template is shipped with Weave GitOps Enterprise to help you get started with Pipelines.</p> <p>For flexibility, this allows the template user to specify the names of the clusters where the application is deployed, and to vary the namespace per cluster. This works even in a tenancy model where environments coexist on the same cluster and use namespaces for isolation.</p> Expand to view example template <pre><code>---\napiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: pipeline-sample\nnamespace: default # Namespace where the GitOpsTemplate is installed, consider that a team will need READ access to this namespace and the custom resource\nlabels:\nweave.works/template-type: pipeline\nspec:\ndescription: Sample Pipeline showing visualization of two helm releases across two environments.\nparams:\n- name: RESOURCE_NAME # This is a required parameter name to enable Weave GitOps to write to your Git Repository\ndescription: Name of the Pipeline\n- name: RESOURCE_NAMESPACE\ndescription: Namespace for the Pipeline on the management cluster\ndefault: flux-system # default values make it easier for users to fill in a template\n- name: FIRST_CLUSTER_NAME\ndescription: Name of GitopsCluster object for the first environment\n- name: FIRST_CLUSTER_NAMESPACE\ndescription: Namespace where this object exists\ndefault: default\n- name: FIRST_APPLICATION_NAME\ndescription: Name of the HelmRelease for your application in the first environment\n- name: FIRST_APPLICATION_NAMESPACE\ndescription: Namespace for this application\ndefault: flux-system\n- name: SECOND_CLUSTER_NAME\ndescription: Name of GitopsCluster object for the second environment\n- name: SECOND_CLUSTER_NAMESPACE\ndescription: Namespace where this object exists\ndefault: default\n- name: SECOND_APPLICATION_NAME\ndescription: Name of the HelmRelease for your application in the second environment\n- name: SECOND_APPLICATION_NAMESPACE\ndescription: Namespace for this application\ndefault: flux-system\nresourcetemplates:\n- content:\n- apiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\nname: ${RESOURCE_NAME}\nnamespace: ${RESOURCE_NAMESPACE}\nspec:\nappRef:\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nname: ${APPLICATION_NAME}\nenvironments:\n- name: First-Environment\ntargets:\n- namespace: ${FIRST_APPLICATION_NAMESPACE}\nclusterRef:\nkind: GitopsCluster\nname: ${FIRST_CLUSTER_NAME}\nnamespace: ${FIRST_CLUSTER_NAMESPACE}\n- name: Second-Environment\ntargets:\n- namespace: ${SECOND_APPLICATION_NAMESPACE}\nclusterRef:\nkind: GitopsCluster\nname: ${SECOND_CLUSTER_NAME}\nnamespace: ${SECOND_CLUSTER_NAMESPACE}\n</code></pre>"},{"location":"pipelines/pipelines-templates/#pipeline-multi-cluster-promotion","title":"Pipeline - Multi-Cluster Promotion","text":"<p>This example extends the above to add a promotion strategy. In this case, it will raise a pull request to update the application version in subsequent environments.</p> Expand to view example template <pre><code>---\napiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: pipeline-sample\nnamespace: default\nlabels:\nweave.works/template-type: pipeline\nspec:\ndescription: Sample Pipeline showing visualization of two helm releases across two environments.\nparams:\n- name: RESOURCE_NAME\ndescription: Name of the Pipeline\n- name: RESOURCE_NAMESPACE\ndescription: Namespace for the Pipeline on the management cluster\ndefault: flux-system\n- name: FIRST_CLUSTER_NAME\ndescription: Name of GitopsCluster object for the first environment\n- name: FIRST_CLUSTER_NAMESPACE\ndescription: Namespace where this object exists\ndefault: default\n- name: FIRST_APPLICATION_NAME\ndescription: Name of the HelmRelease for your application in the first environment\n- name: FIRST_APPLICATION_NAMESPACE\ndescription: Namespace for this application\ndefault: flux-system\n- name: SECOND_CLUSTER_NAME\ndescription: Name of GitopsCluster object for the second environment\n- name: SECOND_CLUSTER_NAMESPACE\ndescription: Namespace where this object exists\ndefault: default\n- name: SECOND_APPLICATION_NAME\ndescription: Name of the HelmRelease for your application in the second environment\n- name: SECOND_APPLICATION_NAMESPACE\ndescription: Namespace for this application\ndefault: flux-system\n- name: APPLICATION_REPO_URL\ndescription: URL for the git repository containing the HelmRelease objects\n- name: APPLICATION_REPO_BRANCH\ndescription: Branch to update with new version\n- name: GIT_CREDENTIALS_SECRET\ndescription: Name of the secret in RESOURCE_NAMESPACE containing credentials to create pull requests\nresourcetemplates:\n- content:\n- apiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\nname: ${RESOURCE_NAME}\nnamespace: ${RESOURCE_NAMESPACE}\nspec:\nappRef:\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nname: ${APPLICATION_NAME}\nenvironments:\n- name: First-Environment\ntargets:\n- namespace: ${FIRST_APPLICATION_NAMESPACE}\nclusterRef:\nkind: GitopsCluster\nname: ${FIRST_CLUSTER_NAME}\nnamespace: ${FIRST_CLUSTER_NAMESPACE}\n- name: Second-Environment\ntargets:\n- namespace: ${SECOND_APPLICATION_NAMESPACE}\nclusterRef:\nkind: GitopsCluster\nname: ${SECOND_CLUSTER_NAME}\nnamespace: ${SECOND_CLUSTER_NAMESPACE}\npromotion:\npull-request:\nurl: ${APPLICATION_REPO_URL}\nbaseBranch: ${APPLICATION_REPO_BRANCH}\nsecretRef:\nname: ${GIT_CREDENTIALS_SECRET}\n</code></pre>"},{"location":"pipelines/pipelines-templates/#git-credentials","title":"Git Credentials","text":"<p>For guidance on configuring credentials, find instructions in the Promoting Applications documentation.</p>"},{"location":"pipelines/pipelines-templates/#promotion-marker-added-to-helmrelease-in-second-environment","title":"Promotion Marker Added to HelmRelease in <code>Second-Environment</code>","text":"<p>You must add a comment to the HelmRelease or Kustomization patch where the <code>spec.chart.spec.version</code> is defined. For example, if the values used in the above template were as follows:</p> <pre><code>RESOURCE_NAME=my-app\nRESOURCE_NAMESPACE=pipeline-01\n</code></pre> <p>Then the marker would be:</p> <pre><code># {\"$promotion\": \"pipeline-01:my-app:Second-Environment\"}\n</code></pre> <p>Find more guidance on adding markers here.</p>"},{"location":"pipelines/pipelines-templates/#alerts-and-providers","title":"Alerts and Providers","text":"<p>This example shows you how you can configure multiple resources in a single template and simplify creation through common naming strategies. The notification controller communicates update events from the leaf clusters where applications are deployed to the management cluster, where the Pipeline Controller resides and orchestrates.</p> <p>For the <code>Alert</code>, this template filters events to detect when an update has occurred. Depending on your use case, you can use different filtering.</p> <p>For the <code>Provider</code>, this template uses authenticated (HMAC) communication to the promotion endpoint, where a secret must be present on both the management cluster and the leaf cluster(s). For simplicity's sake, you can use a <code>generic</code> provider instead; this will not require the secret.</p> Expand to view example template <pre><code>---\napiVersion: templates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: pipeline-notification-resources\nnamespace: default\nlabels:\nweave.works/template-type: application # These are generic Flux resources rather than Pipeline-specific\nspec:\ndescription: Creates flux notification controller resources for a cluster, required for promoting applications via pipelines.\nparams:\n- name: RESOURCE_NAME\ndescription: Name for the generated objects, should match the target Application (HelmRelease) name.\n- name: RESOURCE_NAMESPACE\ndescription: Namespace for the generated objects, should match the target Application (HelmRelease) namespace.\n- name: PROMOTION_HOST\ndescription: Host for the promotion webhook on the management cluster, i.e. \"promotions.example.org\"\n- name: SECRET_REF\ndescription: Name of the secret containing HMAC key in the token field\n- name: ENV_NAME\ndescription: Environment the cluster is a part of within a pipeline.\nresourcetemplates:\n- content:\n- apiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\nname: ${RESOURCE_NAME}\nnamespace: ${RESOURCE_NAMESPACE}\nspec:\naddress: http://${PROMOTION_HOST}/promotion/${APP_NAME}/${ENV_NAME}\ntype: generic-hmac\nsecretRef: ${SECRET_REF}\n- apiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nmetadata:\nname: ${RESOURCE_NAME}\nnamespace: ${RESOURCE_NAMESPACE}\nspec:\nproviderRef:\nname: ${RESOURCE_NAME}\neventSeverity: info\neventSources:\n- kind: HelmRelease\nname: ${RESOURCE_NAME}\nexclusionList:\n- \".*upgrade.*has.*started\"\n- \".*is.*not.*ready\"\n- \"^Dependencies.*\"\n</code></pre> <p>s</p>"},{"location":"pipelines/pipelines-templates/#summary","title":"Summary","text":"<p>GitOpsTemplates provide a highly flexible way for platform and application teams to work together with Pipelines.</p> <p>You can hard-code values, offer a range of accepted values, or allow the template consumer to provide input based on your organization's requirements.</p> <p>Templates are subject to RBAC as with any Kubernetes resource, enabling you to easily control which tenants have access to which templates.</p> <p>For full details on GitOpsTemplates, read our documentation.</p>"},{"location":"pipelines/pipelines-with-jenkins/","title":"Setting Up Pipelines to Notify a Jenkins Webhook ENTERPRISE","text":"<p>Using Flux's Notification Controller, a Jenkins Webhook can be invoked on Pipeline promotion events.</p>"},{"location":"pipelines/pipelines-with-jenkins/#configuring-jenkins","title":"Configuring Jenkins","text":"<p>To enable external callers to trigger a build on a job, an additional \"Generic Webhook Trigger\" plugin is required as Jenkins does not have this functionality built-in.</p> <p>After the plugin is installed a new \"Generic Webhook Trigger\" job configuration option is available.</p> <p>The only mandatory field is the \"Token\". Without this token, Jenkins will not know which build should be triggered.</p> <p></p>"},{"location":"pipelines/pipelines-with-jenkins/#post-content-parameters","title":"Post content parameters","text":"<p>To access fields from the pipeline event payload, each field has to be defined as a \"Post content parameters\".</p> <p></p>  Expand to see an example Promotion Event payload <pre><code>{\n\"involvedObject\": {\n\"kind\": \"Pipeline\",\n\"namespace\": \"flux-system\",\n\"name\": \"podinfo-pipeline\",\n\"uid\": \"74d9e3b6-0269-4c12-9051-3ce8cfb7886f\",\n\"apiVersion\": \"pipelines.weave.works/v1alpha1\",\n\"resourceVersion\": \"373617\"\n},\n\"severity\": \"info\",\n\"timestamp\": \"2023-02-08T12:34:13Z\",\n\"message\": \"Promote pipeline flux-system/podinfo-pipeline to prod with version 6.1.5\",\n\"reason\": \"Promote\",\n\"reportingController\": \"pipeline-controller\",\n\"reportingInstance\": \"chart-pipeline-controller-8549867565-7822g\"\n}\n</code></pre>"},{"location":"pipelines/pipelines-with-jenkins/#configure-notification-provider","title":"Configure Notification Provider","text":"<p>In order to be able to invoke a generic webhook, a notification provider has to be defined. Jenkins expects the secret token which you configured above as a GET parameter or in the request header. The secret token can be stored in a Secret:</p> <pre><code>apiVersion: v1\nkind: Secret\ntype: Opaque\nmetadata:\nname: jenkins-token\nnamespace: podinfo\nstringData:\nheaders: |\ntoken: epicsecret\n</code></pre> <p>Now we can define a Notification Provider using this secret:</p> <pre><code>apiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\nname: jenkins-promotion\nnamespace: podinfo\nspec:\ntype: generic\naddress: https://jenkins.domain.tld/generic-webhook-trigger/invoke\nsecretRef:\nname: jenkins-token\n</code></pre>"},{"location":"pipelines/pipelines-with-jenkins/#set-up-alerts","title":"Set Up Alerts","text":"<p>We can configure an Alert to use the <code>jenkins-promotion</code> provider. For example an Alert for the <code>podinfo-pipeline</code> in the <code>flux-system</code> namespace:</p> <pre><code>apiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nmetadata:\nname: podinfo-pipeline-promotion\nnamespace: podinfo\nspec:\neventSeverity: info\neventSources:\n- kind: Pipeline\nname: podinfo-pipeline\nnamespace: flux-system\nproviderRef:\nname: jenkins-promotion\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/","title":"Setting up Pipelines to Trigger a Tekton Pipeline ENTERPRISE","text":"<p>Using Flux's Notification Controller, a Tekton EventListener can be triggered on Pipeline promotion events.</p>"},{"location":"pipelines/pipelines-with-tekton/#configuring-tekton-pipelines","title":"Configuring Tekton Pipelines","text":""},{"location":"pipelines/pipelines-with-tekton/#tekton-tasks","title":"Tekton Tasks","text":"<p>In this tutorial, we have two tasks to demonstrate how to use parameter values from the Pipeline event payload. Both tasks print out messages with information about the pipeline promotion. Each task has three parameters: <code>name</code>, <code>namespace</code>, and <code>message</code>.</p> <pre><code>---\napiVersion: tekton.dev/v1beta1\nkind: Task\nmetadata:\nname: hello\nnamespace: ww-pipeline\nspec:\nparams:\n- name: name\ntype: string\n- name: namespace\ntype: string\n- name: message\ntype: string\nsteps:\n- name: echo\nimage: alpine\nscript: |\n#!/bin/sh\necho \"Hello $(params.namespace)/$(params.name)!\"\necho \"Message: $(params.message)\"\n---\napiVersion: tekton.dev/v1beta1\nkind: Task\nmetadata:\nname: goodbye\nnamespace: ww-pipeline\nspec:\nparams:\n- name: name\ntype: string\n- name: namespace\ntype: string\n- name: message\ntype: string\nsteps:\n- name: goodbye\nimage: ubuntu\nscript: |\n#!/bin/bash\necho \"Goodbye $(params.namespace)/$(params.name)!\"\necho \"Message: $(params.message)\"\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/#tekton-pipeline","title":"Tekton Pipeline","text":"<p>The <code>hello-goodbye</code> Tekton Pipeline has the same three parameters as the tasks and it passes down the values to them.</p> <pre><code>---\napiVersion: tekton.dev/v1beta1\nkind: Pipeline\nmetadata:\nname: hello-goodbye\nnamespace: ww-pipeline\nspec:\nparams:\n- name: name\ntype: string\n- name: namespace\ntype: string\n- name: message\ntype: string\ntasks:\n- name: hello\ntaskRef:\nname: hello\nparams:\n- name: namespace\nvalue: $(params.namespace)\n- name: name\nvalue: $(params.name)\n- name: message\nvalue: $(params.message)\n- name: goodbye\nrunAfter:\n- hello\ntaskRef:\nname: goodbye\nparams:\n- name: namespace\nvalue: $(params.namespace)\n- name: name\nvalue: $(params.name)\n- name: message\nvalue: $(params.message)\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/#configuring-tekton-pipline-automation","title":"Configuring Tekton Pipline Automation","text":"<p>In order to be able to trigger a Pipeline from an external source, we need three Tekton resources.</p> <ol> <li><code>TriggerBinding</code>: This resource binds the incoming JSON message to parameter    variables.</li> <li><code>TriggerTemplate</code>: This resource is the template of the <code>PipelineRun</code> that    will be started.</li> <li><code>EventListener</code>: This resource glues the above two resources together and    creates an http listener service.</li> </ol>"},{"location":"pipelines/pipelines-with-tekton/#tekton-triggerbinding","title":"Tekton TriggerBinding","text":"<p>A JSON payload from the Notification Service about a Pipeline promotion looks like this:</p> <pre><code>{\n\"involvedObject\": {\n\"kind\": \"Pipeline\",\n\"namespace\": \"flux-system\",\n\"name\": \"podinfo-pipeline\",\n\"uid\": \"74d9e3b6-0269-4c12-9051-3ce8cfb7886f\",\n\"apiVersion\": \"pipelines.weave.works/v1alpha1\",\n\"resourceVersion\": \"373617\"\n},\n\"severity\": \"info\",\n\"timestamp\": \"2023-02-08T12:34:13Z\",\n\"message\": \"Promote pipeline flux-system/podinfo-pipeline to prod with version 6.1.5\",\n\"reason\": \"Promote\",\n\"reportingController\": \"pipeline-controller\",\n\"reportingInstance\": \"chart-pipeline-controller-8549867565-7822g\"\n}\n</code></pre> <p>In our tasks, we are using only the <code>involvedObject.name</code>, <code>involvedObject.namespace</code> and <code>message</code> fields:</p> <pre><code>---\napiVersion: triggers.tekton.dev/v1beta1\nkind: TriggerBinding\nmetadata:\nname: ww-pipeline-binding\nnamespace: ww-pipeline\nspec:\nparams:\n- name: namespace\nvalue: $(body.involvedObject.namespace)\n- name: name\nvalue: $(body.involvedObject.name)\n- name: message\nvalue: $(body.message)\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/#tekton-triggertemplate","title":"Tekton TriggerTemplate","text":"<p>The template has the same parameters as the <code>Pipeline</code> resources:</p> <pre><code>---\napiVersion: triggers.tekton.dev/v1beta1\nkind: TriggerTemplate\nmetadata:\nname: ww-pipeline-template\nnamespace: ww-pipeline\nspec:\nparams:\n- name: namespace\ndefault: \"Unknown\"\n- name: name\ndefault: \"Unknown\"\n- name: message\ndefault: \"no message\"\nresourcetemplates:\n- apiVersion: tekton.dev/v1beta1\nkind: PipelineRun\nmetadata:\ngenerateName: hello-goodbye-run-\nspec:\npipelineRef:\nname: hello-goodbye\nparams:\n- name: name\nvalue: $(tt.params.name)\n- name: namespace\nvalue: $(tt.params.namespace)\n- name: message\nvalue: $(tt.params.message)\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/#tekton-eventlistener","title":"Tekton EventListener","text":"<p>To access all required resources, we need an extra service account:</p> <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: tekton-ww-pipeline-robot\nnamespace: ww-pipeline\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: triggers-example-eventlistener-binding\nnamespace: ww-pipeline\nsubjects:\n- kind: ServiceAccount\nname: tekton-ww-pipeline-robot\nnamespace: ww-pipeline\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: tekton-triggers-eventlistener-roles\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: triggers-example-eventlistener-clusterbinding\nsubjects:\n- kind: ServiceAccount\nname: tekton-ww-pipeline-robot\nnamespace: ww-pipeline\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: tekton-triggers-eventlistener-clusterroles\n</code></pre> <p>With this <code>ServiceAccount</code>, we can create the <code>EventListener</code> using the <code>TriggerBinding</code> and <code>TriggerTemplate</code>:</p> <pre><code>---\napiVersion: triggers.tekton.dev/v1beta1\nkind: EventListener\nmetadata:\nname: ww-pipeline-listener\nnamespace: ww-pipeline\nspec:\nserviceAccountName: tekton-ww-pipeline-robot\ntriggers:\n- name: ww-pipeline-trigger\nbindings:\n- ref: ww-pipeline-binding\ntemplate:\nref: ww-pipeline-template\n</code></pre> <p>At this point, we should have a <code>Service</code> for our <code>EventListener</code>.</p> <pre><code>\u276f kubectl get service -n ww-pipeline\nNAME                      TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE\nel-ww-pipeline-listener   ClusterIP   10.96.250.23   &lt;none&gt;        8080/TCP,9000/TCP   3d\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/#configure-notification-provider","title":"Configure Notification Provider","text":"<p>In this case, we are using Tekton in the same cluster, so we can use an internal address to access the <code>EventListener</code> service. If they are not in the same cluster, exposing the service may be required through an ingress or a service mesh.</p> <pre><code>---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\nname: tekton-promotion\nnamespace: hello-podinfo\nspec:\ntype: generic\naddress: http://el-ww-pipeline-listener.ww-pipeline:8080/\n</code></pre>"},{"location":"pipelines/pipelines-with-tekton/#set-up-alerts","title":"Set Up Alerts","text":"<p>We can configure an Alert to use the <code>tekton-promotion</code> provider. For example, an Alert for the <code>podinfo-pipeline</code> in the <code>flux-system</code> namespace:</p> <pre><code>---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nmetadata:\nname: tekton-promotion-podinfo\nnamespace: hello-podinfo\nspec:\neventSeverity: info\neventSources:\n- kind: Pipeline\nname: hello-podinfo\nnamespace: flux-system\nproviderRef:\nname: tekton-promotion\n</code></pre>"},{"location":"pipelines/promoting-applications/","title":"Promoting applications through pipeline environments","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>Pipelines allow you to configure automatic promotions of applications through a consecutive set of environments, e.g. from dev to staging to production. The environments are defined in the <code>Pipeline</code> resource itself so that each pipeline governs a single application and all the environments to which it is deployed.</p> <p>Info</p> <p>At the moment only applications defined as Flux <code>HelmReleases</code> are supported in automatic promotions.</p> <p> </p> An example of a pull request for an application promotion <p>The Getting Started Guide describes how to create a basic pipeline for an application so you can visualize its deployments across a series of environments. You may also configure a pipeline in order to promote applications across a series of environments. There are currently two supported strategies for application promotions:</p> <ul> <li>Pull request strategy: this strategy is used for applications that are delivered via Flux to all environments of a pipeline. Typically, the versions of these applications are stored in Git and therefore pull requests can be used to update them as part of a promotion.</li> <li>Notification strategy: this strategy is used when an external CI system is responsible for promoting an application across the environments of a pipeline. In this strategy, the notification controller running on the management cluster is used to forward notifications of successful promotions to external CI systems.</li> </ul> <p>Before configuring any of the above promotion strategies, you need to setup notifications from all your environments so that whenever a new version gets deployed, the promotion webhook component of the pipeline controller is notified and takes an action based on the pipeline definition. The rest of this guide describes the configuration needed to setup application promotion via pipelines.</p>"},{"location":"pipelines/promoting-applications/#expose-the-promotion-webhook","title":"Expose the promotion webhook","text":"<p>Applications deployed in leaf clusters use the Flux notification controller running on each leaf cluster, to notify the management cluster of a successful promotion. This requires network connectivity to be established between the leaf cluster and the management cluster.</p> <p>The component responsible for listening to incoming notifications from leaf clusters is the pipeline controller. It hosts a webhook service that needs to be exposed via an ingress resource to make it available for external calls. Exposing the webhook service is done via the Weave GitOps Enterprise Helm chart values and the configuration used depends on your environment. The example below shows the configuration for NGINX ingress controller and needs to be adjusted if another ingress controller is used:</p> <pre><code>spec:\nvalues:\nenablePipelines: true\npipeline-controller:\npromotion:\ningress:\nenabled: true\nclassName: nginx\nannotations:\ncert-manager.io/cluster-issuer: letsencrypt\nhosts:\n- host: promotions.example.org\npaths:\n- path: /?(.*)\npathType: ImplementationSpecific\ntls:\n- secretName: promotions-tls\nhosts:\n- promotions.example.org\n</code></pre> <p>You will need the externally reachable URL of this service later on in this guide.</p>"},{"location":"pipelines/promoting-applications/#setup-notifications-from-leaf-clusters","title":"Setup notifications from leaf clusters","text":"<p>Once the webhook service is exposed over HTTP/S, you need to create alert/provider resources to send notifications to it from leaf clusters. These notifications represent successful promotions for applications running on the leaf clusters.</p> <p>Successful promotion events are triggered by Flux's notification controller. You create a Provider pointing to the promotion webhook exposed earlier and an Alert targeting the app's HelmRelease:</p> <pre><code>---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\nname: promotion-my-app\nspec:\naddress: \"https://promotions.example.org/promotion/pipeline-01/my-app/dev\"\ntype: generic-hmac\nsecretRef:\nname: hmac-secret\n</code></pre> <p>In the example above, the <code>generic-hmac</code> Provider is used to ensure notifications originate from authenticated sources. The referenced Secret, should include a <code>token</code> field which holds the HMAC key. The same HMAC key must be specified in the Secret referenced by the <code>.spec.promotion.strategy.secretRef.name</code> field, so that the pipeline controller can verify any incoming notifications. For more information on the <code>generic-hmac</code> Provider, please refer to the notification controller docs.</p> <p>Note that by default, the promotion webhook endpoint is exposed at <code>/promotion</code> as shown in the example above. However you may use rewrite rules in your ingress configuration to omit it, if desired. For example, if using NGINX ingress controller, you may use the following annotation: <pre><code>annotations:\nnginx.ingress.kubernetes.io/rewrite-target: /promotion/$1\n</code></pre> The Provider address can then be set as <code>https://promotions.example.org/pipeline-01/my-app/dev</code>.</p> <p>Tip</p> <p>You may also use the generic webhook provider type that supports HMAC verification to ensure incoming notifications originate from authenticated sources.</p> <p>The <code>address</code> field's URL path is comprised of 3 components again:</p> <ol> <li>The namespace of the app's pipeline.</li> <li>The name of the pipeline resource.</li> <li>The origin environment's name. This is the name of the environment that the event is created in, e.g. \"dev\" for events coming from the \"dev\" environment.</li> </ol> <p>Weave GitOps Enterprise can then parse the incoming URL path to identify the pipeline resource and look up the next environment for the defined promotion action.</p> <p>An example Alert might look like this:</p> <pre><code>---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nspec:\neventSeverity: info\neventSources:\n- kind: HelmRelease\nname: my-app\nexclusionList:\n- .*upgrade.*has.*started\n- .*is.*not.*ready\n- ^Dependencies.*\nproviderRef:\nname: promotion-my-app\n</code></pre> <p>Tip</p> <p>Be sure to create the Provider/Alert tuple on each of the leaf clusters targeted by a pipeline.</p> <p>Now as soon as the <code>HelmRelease</code> on the first environment defined in the pipeline is bumped (e.g. by Flux discovering a new version in the Helm repository), an event is sent to the promotion webhook which will determine the next action based on the pipeline definition and chosen strategy. The rest of this guide describes how to setup up any of the available strategies depending on your requirements.</p>"},{"location":"pipelines/promoting-applications/#pull-request","title":"Pull request","text":"<p>Danger</p> <p>Creating pull requests requires a personal access token with write access to your git repo. If the secret containing the token is compromised (and you could assume it as a likely scenario), it could in principle allow someone to delete your production applications.</p> <p>Please make sure you understand the Security section below before taking the steps to enable automated pull requests.</p> <p>This section covers adding a promotion by pull request (PR) strategy, so that whenever the application defined in a pipeline is upgraded in one of the pipeline's environments, a PR is created that updates the manifest file setting the application version in the next environment.</p> <p>The dynamic nature of GitOps deployments requires you to assist Weave GitOps a little with information on which repository hosts the manifest files, how to authenticate with the repository and the Git provider API, and which file hosts the version definition for each environment.</p>"},{"location":"pipelines/promoting-applications/#security","title":"Security","text":""},{"location":"pipelines/promoting-applications/#environments-and-repositories","title":"Environments and Repositories","text":"<ol> <li>Use it in low-risk environments and not in production: pipelines is an alpha feature and not yet production-ready.</li> <li>Make sure you have considered possible attack vectors to production, and put controls in place. Some of these scenarios are:</li> <li>In the case of a monorepo: you want to ensure that a compromised token for a test cluster cannot end up doing a promotion in production, without at least a pull request review; for example, by using Codeowners.</li> <li>In the case of repo per environment you want to ensure that a pipeline is configured with your test environment repo URL. You also want to ensure that you have segregation of tokens per environment rather than allowing a token to access any environment repo.</li> </ol>"},{"location":"pipelines/promoting-applications/#rbac","title":"RBAC","text":"<ol> <li> <p>Only allow creation of RBAC resources from paths where compliance controls are in place. For example, do not allow regular users to create or update RBAC resources; or, if users must create RBAC resources, restrict them by namespace.</p> </li> <li> <p>Follow the principle of \"Least Privilege\" RBAC as explained in Kubernetes RBAC Good Practices, with emphasis on the following:</p> </li> </ol> <p>Assign permissions at the namespace level where possible. Use RoleBindings as opposed to ClusterRoleBindings to give users rights only within a specific namespace.</p> <p>Avoid providing wildcard permissions when possible, especially to all resources. As Kubernetes is an extensible system, providing wildcard access gives rights not just to all object types that currently exist in the cluster, but also to all object types which are created in the future.</p> <ol> <li>Prefer granting access to specific secrets, rather than granting <code>list</code> and <code>watch</code> on secrets as:</li> </ol> <p>It is also important to note that list and watch access also effectively allow users to read Secret contents.</p>"},{"location":"pipelines/promoting-applications/#policy","title":"Policy","text":"<p>By following the guidelines above, you can have a safe initial configuration. However, given there are no deny semantics in RBAC, you need to guard future changes.</p> <p>An RBAC Role or ClusterRole contains rules that represent a set of permissions. Permissions are purely additive (there are no \"deny\" rules).</p> <p>You should ensure that attempts to break this contract are blocked and detected. You could achieve it by using Weave GitOps' Policy capabilities. The Policy Agent acts in two complementary modes: - Admission Controller protects from any attempt to create non-compliant RBAC resources that would end granting access to the secret. - Audit helps you identify already existing resources that are out of compliance. For example, roles created before policy agent was introduced as admission controller.</p> <p>Once you have enabled Policy, the Policy Library gives you a set of good practices policies that will help you keep pipeline secrets secure according to the previous RBAC recommendations. Deploy them as Kustomization based on the following example:</p> <p>Tip</p> <p>In case you don't have access to the Policy Library, work with your Weaveworks Technical Account Manager (TAM) or Weaveworks Customer Reliability Engineer (CRE) to help with this step.</p> <pre><code>apiVersion: source.toolkit.fluxcd.io/v1\nkind: GitRepository\nmetadata:\nname: policy-library\nnamespace: flux-system\nspec:\ninterval: 10m0s\nurl: https://github.com/weaveworks/policy-library.git\nsecretRef:\nname: policy-library-github-credentials\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\nname: rbac-secrets-good-practices\nnamespace: flux-system\nspec:\ninterval: 1m0s\nsourceRef:\nkind: GitRepository\nname: policy-library\npath: ./goodpractices/kubernetes/rbac/secrets\nprune: true\n</code></pre> Warning <p>Policies typically allow exclusions, to accommodate privileged workloads like Flux. You can manage them via PolicyConfig. For example, in order to allow Flux you could use the following <code>PolicyConfig</code>:</p> <pre><code>apiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: allow-flux\nspec:\nmatch:\napps:\n- kind: Kustomization\nname: flux-system\nnamespace: flux-system\nconfig:\nweave.templates.rbac-prohibit-wildcards-policyrule-resources:\nparameters:\nexclude_label_key: \"app.kubernetes.io/part-of\"\nexclude_label_value: \"flux\"\nweave.templates.rbac-prohibit-wildcards-policyrule-verbs:\nparameters:\nexclude_label_key: \"app.kubernetes.io/part-of\"\nexclude_label_value: \"flux\"\nweave.policies.rbac-prohibit-list-secrets:\nparameters:\nexclude_label_key: \"app.kubernetes.io/part-of\"\nexclude_label_value: \"flux\"\nweave.policies.rbac-prohibit-watch-secrets:\nparameters:\nexclude_label_key: \"app.kubernetes.io/part-of\"\nexclude_label_value: \"flux\"\nweave.policies.rbac-prohibit-wildcard-secrets:\nparameters:\nexclude_label_key: \"app.kubernetes.io/part-of\"\nexclude_label_value: \"flux\"\n</code></pre> <p>Remind not allowing users to create RBAC resources without compliance checks. Otherwise, they could create RBAC resources that could escape this runtime control.</p> <p>In addition to guarding against privilege escalation via RBAC, you should guard against privilege escalation through workloads:</p> <p>Permission to create workloads (either Pods, or workload resources that manage Pods) in a namespace implicitly grants access to many other resources in that namespace, such as Secrets, ConfigMaps, and PersistentVolumes that can be mounted in Pods</p> <p>You could do that by creating pipeline namespaces to hold the Pipeline and its Secret, without permission to run workloads. You could enforce the latter one by using the Policy Containers Should Not Run In Namespace from the Policy Library and PolicyConfig as follows:</p> <p>Tip</p> <p>Update updates when onboarding a new pipeline. Consider using Weave Gitops self-service capabilities GitOps Templates or GitOpsSets to help you with the task.</p> <pre><code>apiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: reject-workloads-pipeline-namespace\nspec:\nmatch:\nnamespaces:\n- podinfo\nconfig:\nweave.policies.containers-should-not-run-in-namespace:\nparameters:\ncustom_namespace: \"podinfo\"\n</code></pre>"},{"location":"pipelines/promoting-applications/#service-account","title":"Service Account","text":"<p>To enable the Pipeline Controller to read the secret, we need to grant access via RBAC. The promotion credentials secret needs to be in the same namespace as the <code>Pipeline</code> resource on the management cluster. You should create a <code>RoleBinding</code> for the Pipeline Controller <code>ServiceAccount</code> in the pipeline namespace. For a pipeline in namespace <code>podinfo</code>, it would look like the following:</p> <pre><code>---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: read-app-promotion-credentials\nnamespace: podinfo # change for the pipeline namespace\nrules:\n- apiGroups:\n- \"\"\nresourceNames:\n- \"app-promotion-credentials\" # change for the secret name holding the pull requests secret\nresources:\n- \"secrets\"\nverbs:\n- \"get\"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: pipeline-controller-read-app-promotion-credentials\nnamespace: podinfo\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: read-app-promotion-credentials\nsubjects:\n- kind: ServiceAccount\nname: chart-pipeline-controller # change in case pipeline controller service account has a different name in your context\nnamespace: flux-system\n</code></pre>"},{"location":"pipelines/promoting-applications/#verify-security-context","title":"Verify Security Context","text":"<p>Use pipeline promotions security to verify that your environments meets the security context described earlier.</p> <p>Once deployed you could see how the different resources are being rejected. See those rejections in the Violations UI:</p> <p></p> <p>In addition, verify that the Pipeline controller can only get the secret by the following tests:</p> <p>List access is denied:</p> <pre><code>$ kubectl get secret -n podinfo  --as=system:serviceaccount:flux-system:chart-pipeline-controller\n\nError from server (Forbidden): secrets is forbidden: User \"system:serviceaccount:flux-system:chart-pipeline-controller\" cannot list resource \"secrets\" in API group \"\" in the namespace \"podinfo\"\n</code></pre> <p>Get access is allowed:</p> <pre><code>$ kubectl get secret -n podinfo  --as=system:serviceaccount:flux-system:chart-pipeline-controller app-promotion-credentials\n\nNAME                        TYPE     DATA   AGE\napp-promotion-credentials   Opaque   1      21m\n</code></pre>"},{"location":"pipelines/promoting-applications/#tokens","title":"Tokens","text":"<ol> <li>Create a user account for pull request changes: this user context would be used to do any git provider operation, and from the security and auditing perspectives, you don't want to impersonate a real user for it.</li> </ol> Expand to see example <ol> <li>Do not use long-live tokens: set an expiration date and rotate them according to your security policy.</li> </ol> Expand to see example <ol> <li>Honour the least privilege principle: avoid having high privilege tokens. Restrict the token to your just your repo and to just the operations required.</li> </ol> Expand to see example <p>For example, if the case of GitHub, use fine-grained tokens to only allow access to the single repo that your configuration manifests exist.</p> <p> </p> <ol> <li>Review the tokens on a regular basis following your git provider recommendations. Ensure that:<ul> <li>Only the ones that are required are present.</li> <li>Tokens close to their expiration date are cycled.</li> </ul> </li> </ol> Expand to see example <p>For example, using github and fine-grained tokens you could do so.</p> <p> </p> <ol> <li>Review git provider recommendations and examples</li> <li>GitHub</li> <li>GitLab</li> </ol>"},{"location":"pipelines/promoting-applications/#add-markers-to-app-manifests","title":"Add markers to app manifests","text":"<p>The discovery of the version field is done using deterministic markers in a YAML manifest file. An example <code>HelmRelease</code> manifest with such a marker looks like this:</p> <pre><code>---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nspec:\nchart:\nspec:\nversion: 0.13.7 # {\"$promotion\": \"pipeline-01:my-app:prod\"}\n</code></pre> <p>The value of the <code>$promotion</code> field in the comment is comprised of 3 components separated by colons:</p> <ol> <li>The first field is the Namespace of the pipeline resource that the app is part of. In the example above this is <code>pipeline-01</code>.</li> <li>The second field denotes the name of the pipeline resource.</li> <li>The third field is the name of the environment that this specific HelmRelease targets. The environment name in the marker needs to match with the <code>name</code> field of one of the environments defined in the pipeline's <code>.spec.environments</code> array.</li> </ol> <p>Weave GitOps Enterprise will look for this marker whenever it receives an event from the respective HelmRelease of one of the leaf clusters and patch the file with the version denoted in the event (see the section above for instructions on setting up notification events from leaf clusters). Finally, it will create a Git provider PR to update the version of the application for the next environment in the pipeline.</p>"},{"location":"pipelines/promoting-applications/#supported-git-providers","title":"Supported Git Providers","text":"<p>The following Git providers are currently support by this promotion strategy:</p> <ul> <li>GitHub</li> <li>GitLab</li> <li>BitBucket Server / DataCenter</li> </ul> <p>Select your Git provider via <code>.spec.promotion.strategy.pull-request.type</code>. For example, for <code>gitlab</code> it would look similar to:</p> <pre><code>promotion:\nstrategy:\npull-request:\ntype: gitlab\nurl: \"https://gitlab.com/weaveworks/&lt;my-awesome-project.git&gt;\"\nbaseBranch: main\nsecretRef:\nname: gitlab-promotion-credentials\n</code></pre> <p>More info in the spec.</p>"},{"location":"pipelines/promoting-applications/#credentials-secret","title":"Credentials Secret","text":"<p>In the journey of creating a pull request, there are different secrets involved:</p> <ol> <li>Pipeline controller receives events via webhook from leaf clusters. An HMAC is used for verification so a shared key should be provided in this case.</li> <li>Pipeline controller clones and patches manifests to promote from the pipeline configuration repo. A set of git credentials are required.</li> <li>Pipeline controller uses git provider api to create the pull request with the promoted manifests. A Personal Access Token (PAT) needs to be created to interact with pipelines git provider API. This PAT is also used to list pull requests from the configured repository.</li> </ol> <p>Create a Kubernetes secret with the previous data.</p> Expand to see example <pre><code># example to use git over https with basic auth and pat\n$ kubectl create secret generic promotion-credentials \\\n--namespace=pipeline-01 \\\n--from-literal=\"username=&lt;bot account name&gt;\" \\\n--from-literal=\"password=&lt;token value&gt;\" \\\n--from-literal=\"token=&lt;token value&gt;\" \\\n--from-literal=\"hmac-key=&lt;hmac-key value&gt;\"\n</code></pre> <pre><code>---\napiVersion: v1\nkind: Secret\nmetadata:\nname: promotion-credentials\nnamespace: pipeline-01\ndata:\nusername: ZXhhbXBsZQ==\npassword: ZXhhbXBsZS1wYXNzd29yZA==\ntoken: Z2hwX01IL3RsTFpXTXZMY0FxVWRYY1ZGL0lGbzh0WDdHNjdsZmRxWQ==\nhmac-key: OEIzMTNBNjQ0REU0OEVGODgxMTJCQ0VFNTQ3NkE=\ntype: Opaque\n</code></pre> <p>Tip</p> <ul> <li>The Git provider token provided in the <code>token</code> field needs to be given permission to create pull requests in the pipeline's repository (defined in <code>.spec.promotion.strategy.pull-request.url</code>).</li> <li>The <code>hmac-key</code> field must match the key used for the Provider resource (.spec.secretRef), if specified in the leaf clusters.</li> </ul>"},{"location":"pipelines/promoting-applications/#define-promotion-in-pipeline-resource","title":"Define promotion in pipeline resource","text":"<p>The field <code>.spec.promotion.strategy.pull-request</code> defines details about the Git repository used for promoting the given app. Set the <code>secretRef.name</code> field to the name of the Secret created in the previous step and the <code>url</code> and <code>branch</code> fields to the Git repository's HTTPS URL and optionally a specific branch (if the branch is not set, it defaults to <code>main</code>). If using the <code>generic-hmac</code> Provider from leaf clusters, also set the <code>.spec.promotion.strategy.secretRef.name</code> to the name of the Secret created previously.</p> <p>More info in the spec</p>"},{"location":"pipelines/promoting-applications/#notification","title":"Notification","text":"<p>This section explains how to configure pipelines to work with external CI systems that are responsible for application promotions.</p> <p>This strategy uses the notification controller running on the management cluster, to forward any notifications received by the promotion webhook, from leaf clusters to external CI systems. This requires to patch the Flux manifests of the management cluster, in order to allow objects of type <code>Pipeline</code> to be used as event sources. An example of a patch applied to enable this is shown below:</p> <pre><code>---\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n- gotk-components.yaml\n- gotk-sync.yaml\npatches:\n- patch: |\n- op: add\npath: /spec/versions/0/schema/openAPIV3Schema/properties/spec/properties/eventSources/items/properties/kind/enum/-\nvalue: Pipeline\ntarget:\nkind: CustomResourceDefinition\nname:  alerts.notification.toolkit.fluxcd.io\n</code></pre> <p>You can now create Provider/Alert resources on the management cluster to forward notifications to external systems. For example, the Provider resource shown below is used to invoke a GitHub Actions workflow on a repository:</p> <pre><code>---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Provider\nmetadata:\nname: promotion-my-app-via-github-actions\nspec:\ntype: githubdispatch\naddress: https://github.com/my-org/my-app-repo\nsecretRef:\nname: github-credentials\n</code></pre> <p>To use this Provider, add an Alert that uses the pipeline resource defined on the management cluster as an event source. An example of such an Alert is shown below:</p> <pre><code>---\napiVersion: notification.toolkit.fluxcd.io/v1beta1\nkind: Alert\nmetadata:\nname: promotion-my-app-via-github-actions\nspec:\neventSeverity: info\neventSources:\n- kind: Pipeline\nname: my-app\nnamespace: my-app-ns\nproviderRef:\nname: promotion-my-app-via-github-actions\n</code></pre> <p>The notification controller running on the management cluster is now configured to forward any promotion notifications received from leaf clusters. To actually use this strategy from a pipeline, set the promotion field as shown below:</p> <pre><code>---\napiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\nname: my-app\nnamespace: my-app-ns\nspec:\npromotion:\nnotification: {}\n</code></pre> <p>Promotion notifications from leaf clusters should now be forwarded via the notification controller running on the management cluster and should include information about the version of the application being promoted.</p>"},{"location":"pipelines/promoting-applications/#manual-promotion","title":"Manual promotion","text":"<p>The supported strategies mentioned above, do not require any user interaction when handling promotions. However, there is often a need for a human operator to manually approve a promotion to the next environment. To achieve that, set the <code>spec.promotion.manual</code> key to <code>true</code>.</p> Expand to see example <pre><code>apiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\nname: my-app\nnamespace: my-app-ns\nspec:\npromotion:\nmanual: true\nstrategy:\npull-request:\ntype: github\nurl: https://github.com/my-org/my-app-repo\nbaseBranch: main\nsecretRef:\nname: promotion-credentials\n</code></pre> <p>When this key is set and a promotion is detected, Weave GitOps will prompt the user to manually promote the application to the next environment, via the use of a button shown under the next environment.</p> <p> </p> Manual promotion of an application"},{"location":"pipelines/promoting-applications/#configuration","title":"Configuration","text":""},{"location":"pipelines/promoting-applications/#retry-logic","title":"Retry Logic","text":"<p>By default if a promotion fails, an exponential back-off retry happens and returns with an error only after three retries.</p> <p>Through Helm values, the retry logic is configurable.</p> <pre><code># values.yaml\npromotion:\nretry:\n# Initial delay between retries.\ndelay: 2\n# Maximum delay between retries.\nmaxDelay: 20\n# Number of attempts.\nthreshold: 3\n</code></pre> <p>The promotion happens through an HTTP endpoint call, that endpoint may has connection timeout limits, that's why the <code>maxDelay</code> option is there. If the calculated delay would exceed this value, it will use that as delay. For example if the delay values would be <code>[2, 4, 8, 16, 32, 64]</code>, but <code>maxDelay</code> is set to 15, the list will be <code>[2, 4, 8, 15, 15, 15]</code>. With this option, the promotion will be retried on failure, but the sum of delay values will be only 59 seconds instead of 126 seconds.</p>"},{"location":"pipelines/promoting-applications/#rate-limiting","title":"Rate Limiting","text":"<p>The promotion endpoint can be exposed to the internet (for example github actions), to mitigate DoS attacks, the endpoint has rate limits. By default it's 20 requests per 30 seconds.</p> <p>Rate limiting can be configured through Helm values:</p> <pre><code># values.yaml\npromotion:\nrateLimit:\n# Number of requests allowed in set interval.\nvalue: 20\ninterval: 30\n</code></pre>"},{"location":"pipelines/spec/","title":"Pipeline versions","text":""},{"location":"pipelines/spec/#versions","title":"Versions","text":"<ul> <li>v1alpha1</li> </ul>"},{"location":"pipelines/spec/v1alpha1/pipeline/","title":"Pipeline","text":"<p>import TierLabel from \"../../../_components/TierLabel\";</p>"},{"location":"pipelines/spec/v1alpha1/pipeline/#pipeline-enterprise","title":"Pipeline ENTERPRISE","text":"<p>The Pipeline API defines a resource for continuous delivery pipelines.</p> <p>An example of a fully defined pipeline that creates pull requests for application promotions is shown below.</p> <pre><code>apiVersion: pipelines.weave.works/v1alpha1\nkind: Pipeline\nmetadata:\nname: podinfo-02\nnamespace: flux-system\nspec:\nappRef:\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nname: podinfo\nenvironments:\n- name: dev\ntargets:\n- namespace: podinfo-02-dev\nclusterRef:\nkind: GitopsCluster\nname: dev\nnamespace: flux-system\n- name: test\ntargets:\n- namespace: podinfo-02-qa\nclusterRef:\nkind: GitopsCluster\nname: dev\nnamespace: flux-system\n- namespace: podinfo-02-perf\nclusterRef:\nkind: GitopsCluster\nname: dev\nnamespace: flux-system\n- name: prod\ntargets:\n- namespace: podinfo-02-prod\nclusterRef:\nkind: GitopsCluster\nname: prod\nnamespace: flux-system\npromotion:\nstrategy:\npull-request:\ntype: github\nurl: https://github.com/my-org/my-app-repo\nbaseBranch: main\nsecretRef:\nname: github-credentials\n</code></pre>"},{"location":"pipelines/spec/v1alpha1/pipeline/#specification","title":"Specification","text":"<p>The documentation for version <code>v1alpha1</code>  of a <code>Pipeline</code> resource is found next.</p>"},{"location":"pipelines/spec/v1alpha1/pipeline/#pipeline","title":"Pipeline","text":"<pre><code>// Pipeline is the Schema for the pipelines API\ntype Pipeline struct {\nmetav1.TypeMeta   `json:\",inline\"`\nmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\nSpec PipelineSpec `json:\"spec,omitempty\"`\n// +kubebuilder:default={\"observedGeneration\":-1}\nStatus PipelineStatus `json:\"status,omitempty\"`\n}\n\ntype PipelineSpec struct {\n// Environments is a list of environments to which the pipeline's application is supposed to be deployed.\n// +required\nEnvironments []Environment `json:\"environments\"`\n// AppRef denotes the name and type of the application that's governed by the pipeline.\n// +required\nAppRef LocalAppReference `json:\"appRef\"`\n// Promotion defines details about how promotions are carried out between the environments\n// of this pipeline.\n// +optional\nPromotion *Promotion `json:\"promotion,omitempty\"`\n}\n\ntype Environment struct {\n// Name defines the name of this environment. This is commonly something such as \"dev\" or \"prod\".\n// +required\nName string `json:\"name\"`\n// Targets is a list of targets that are part of this environment. Each environment should have\n// at least one target.\n// +required\nTargets []Target `json:\"targets\"`\n// Promotion defines details about how the promotion is done on this environment.\n// +optional\nPromotion *Promotion `json:\"promotion,omitempty\"`\n}\n\ntype Target struct {\n// Namespace denotes the namespace of this target on the referenced cluster. This is where\n// the app pointed to by the environment's `appRef` is searched.\n// +required\nNamespace string `json:\"namespace\"`\n// ClusterRef points to the cluster that's targeted by this target. If this field is not set, then the target is assumed\n// to point to a Namespace on the cluster that the Pipeline resources resides on (i.e. a local target).\n// +optional\nClusterRef *CrossNamespaceClusterReference `json:\"clusterRef,omitempty\"`\n}\n\n// Promotion define promotion configuration for the pipeline.\ntype Promotion struct {\n// Manual option to allow promotion between to require manual approval before proceeding.\n// +optional\nManual bool `json:\"manual,omitempty\"`\n// Strategy defines which strategy the promotion should use.\nStrategy Strategy `json:\"strategy\"`\n}\n\n// Strategy defines all the available promotion strategies. All of the fields in here are mutually exclusive, i.e. you can only select one\n// promotion strategy per Pipeline. Failure to do so will result in undefined behaviour.\ntype Strategy struct {\n// PullRequest defines a promotion through a Pull Request.\n// +optional\nPullRequest *PullRequestPromotion `json:\"pull-request,omitempty\"`\n// Notification defines a promotion where an event is emitted through Flux's notification-controller each time an app is to be promoted.\n// +optional\nNotification *NotificationPromotion `json:\"notification,omitempty\"`\n// SecrefRef reference the secret that contains a 'hmac-key' field with HMAC key used to authenticate webhook calls.\n// +optional\nSecretRef *meta.LocalObjectReference `json:\"secretRef,omitempty\"`\n}\ntype GitProviderType string\n\nconst (\nGithub          GitProviderType = \"github\"\nGitlab          GitProviderType = \"gitlab\"\nBitBucketServer GitProviderType = \"bitbucket-server\"\n)\n\ntype PullRequestPromotion struct {\n// Indicates the git provider type to manage pull requests.\n// +required\n// +kubebuilder:validation:Enum=github;gitlab;bitbucket-server\nType GitProviderType `json:\"type\"`\n// The git repository HTTPS URL used to patch the manifests for promotion.\n// +required\nURL string `json:\"url\"`\n// The branch to checkout after cloning. Note: This is just the base\n// branch that will eventually receive the PR changes upon merge and does\n// not denote the branch used to create a PR from. The latter is generated\n// automatically and cannot be provided.\n// +required\nBaseBranch string `json:\"baseBranch\"`\n// SecretRef specifies the Secret containing authentication credentials for\n// the git repository and for the Git provider API.\n// For HTTPS repositories the Secret must contain 'username' and 'password'\n// fields.\n// For Git Provider API to manage pull requests, it must contain a 'token' field.\n// +required\nSecretRef meta.LocalObjectReference `json:\"secretRef\"`\n}\n\ntype NotificationPromotion struct{}\n</code></pre>"},{"location":"pipelines/spec/v1alpha1/pipeline/#references","title":"References","text":"<pre><code>// LocalAppReference is used together with a Target to find a single instance of an application on a certain cluster.\ntype LocalAppReference struct {\n// API version of the referent.\n// +required\nAPIVersion string `json:\"apiVersion\"`\n\n// Kind of the referent.\n// +required\nKind string `json:\"kind\"`\n\n// Name of the referent.\n// +required\nName string `json:\"name\"`\n}\n\n// CrossNamespaceClusterReference contains enough information to let you locate the\n// typed Kubernetes resource object at cluster level.\ntype CrossNamespaceClusterReference struct {\n// API version of the referent.\n// +optional\nAPIVersion string `json:\"apiVersion,omitempty\"`\n\n// Kind of the referent.\n// +required\nKind string `json:\"kind\"`\n\n// Name of the referent.\n// +required\nName string `json:\"name\"`\n\n// Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.\n// +optional\nNamespace string `json:\"namespace,omitempty\"`\n}\n</code></pre>"},{"location":"pipelines/spec/v1alpha1/pipeline/#status","title":"Status","text":"<pre><code>type PipelineStatus struct {\n// ObservedGeneration is the last observed generation.\n// +optional\nObservedGeneration int64 `json:\"observedGeneration,omitempty\"`\n\n// Conditions holds the conditions for the Pipeline.\n// +optional\nConditions []metav1.Condition `json:\"conditions,omitempty\"`\n}\n</code></pre>"},{"location":"pipelines/spec/v1alpha1/pipeline/#condition-reasons","title":"Condition Reasons","text":"<pre><code>// Reasons are provided as utility, and are not part of the declarative API.\nconst (\n// TargetClusterNotFoundReason signals a failure to locate a cluster resource on the management cluster.\nTargetClusterNotFoundReason string = \"TargetClusterNotFound\"\n// TargetClusterNotReadyReason signals that a cluster pointed to by a Pipeline is not ready.\nTargetClusterNotReadyReason string = \"TargetClusterNotReady\"\n// ReconciliationSucceededReason signals that a Pipeline has been successfully reconciled.\nReconciliationSucceededReason string = \"ReconciliationSucceeded\"\n)\n</code></pre>"},{"location":"policy/","title":"Introduction ENTERPRISE","text":""},{"location":"policy/#policy","title":"Policy","text":"<p>Weave Policy Engine helps users have continuous security and compliance checks across their software delivery pipeline. The engine utilizes policy-as-code to guarantee security, resilience, and coding standards across applications and infrastructure. The engine comes with 100+ policies covering numerous security and compliance benchmarks like SOC2, GDPR, PCI-DSS, HIPAA, Mitre Attack and more.</p> <p>The policy engine provides the following functionality:</p>"},{"location":"policy/#admission-controller","title":"Admission Controller","text":"<p>An out-of-the-box admission controller that monitors any changes happening to the clusters' deployments and resources, and prevents violating changes at deployment time from being deployed to clusters.</p>"},{"location":"policy/#audit","title":"Audit","text":"<p>Daily scans of your clusters' deployments and resources, then report back any policy violations. The audit results can be published to different data analytics tools to provide compliance posture analysis of your clusters runtime.</p>"},{"location":"policy/#commitbuild-time-checks","title":"Commit/Build Time Checks","text":"<p>Early feedback on policy violations at the commit or build time, by reporting policy violations right inside git or other CI tools. This helps developers and operators detect policy violations and fix them before they deploy their changes to the clusters.</p>"},{"location":"policy/authorization/","title":"Authorization ENTERPRISE","text":"<p>This section provides a recommended way to configure RBAC in the context of policies. It is oriented to the journey that you expect your users to have.</p>"},{"location":"policy/authorization/#view-resources","title":"View Resources","text":"<p>The policy journey in the UI involves several resources. We have the Policies that are used by the agent, the resulting Violations when the agent enforces those policies, and the PolicyConfigs that the user can configure to override policy parameters. The violations are essentially kubernetes events that contain the Validation object.</p> <p>In order to view those resources, users would need to have read access to the <code>policies</code>, <code>policysconfigs</code>, and <code>events</code> resource.</p> <p>An example of a configuration to achieve this purpose could be seen below with <code>policies-reader</code> role and <code>developer-policies-reader</code> cluster role binding, to allow a group <code>developer</code> to access all the policy-related resources.</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: policies-reader\nrules:\n- apiGroups: [\"pac.weave.works\"]\nresources: [\"policies\", \"policyconfigs\"]\nverbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"\"]\nresources: [\"events\"]\nverbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: developer-policies-reader\nsubjects:\n- kind: Group\nname: developer\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: ClusterRole\nname: policies-reader\napiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"policy/commit-time-checks/","title":"Commit/Build Time Checks  ENTERPRISE","text":""},{"location":"policy/commit-time-checks/#overview","title":"Overview","text":"<p>Weave GitOps Enterprise enables developers and operators to check policy violations early in their software development life cycle, specifically at commit and build time. Developers and operators can have Weave Policy Validator integrated in their CI tools to validate whether their code changes are violating any policies or not.</p> <p>Weave GitOps Enterprise offer a policy engine image that can be used to perform commit/build time checks.The image can be found on Docker Hub under the name: <code>weaveworks/weave-iac-validator:v1.1</code>.</p> Expand to view of the usage options <pre><code>USAGE:\n    app [global options] command [command options] [arguments...]\n\nVERSION:\n    0.0.1\n\nCOMMANDS:\n    help, h  Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n    --path value                       path to scan resources from\n    --helm-values-file value           path to resources helm values file\n    --policies-path value              path to policies kustomization directory\n    --policies-helm-values-file value  path to policies helm values file\n    --git-repo-provider value          git repository provider\n    --git-repo-host value              git repository host\n    --git-repo-url value               git repository url\n    --git-repo-branch value            git repository branch\n    --git-repo-sha value               git repository commit sha\n    --git-repo-token value             git repository toke\n    --azure-project value              azure project name\n    --sast value                       save result as gitlab sast format\n    --sarif value                      save result as sarif format\n    --json value                       save result as json format\n    --generate-git-report              generate git report if supported (default: false)\n--remediate                        auto remediate resources if possible (default: false)\n--no-exit-error                    exit with no error (default: false)\n--help, -h                         show help (default: false)\n--version, -v                      print the version (default: false)\n</code></pre>"},{"location":"policy/commit-time-checks/#setup-policies","title":"Setup policies","text":"<p>Policies can be a helm chart, kustomize directory or just plain kubernetes yaml files.</p> <p>Example of policies kustomize directory</p> <pre><code>\u2514\u2500\u2500 policies\n    \u251c\u2500\u2500 kustomization.yaml\n    \u251c\u2500\u2500 minimum-replica-count.yaml\n    \u251c\u2500\u2500 privileged-mode.yaml\n    \u2514\u2500\u2500 privilege-escalation.yaml\n</code></pre> <pre><code>    # kustomization.yaml\nkind: Kustomization\napiVersion: kustomize.config.k8s.io/v1beta1\nresources:\n- minimum-replica-count.yaml\n- privilege-escalation.yaml\n- privileged-mode.yaml\n</code></pre>"},{"location":"policy/commit-time-checks/#supported-cicd","title":"Supported CI/CD","text":"<ul> <li> Github</li> <li> Github Enterprise</li> <li> Gitlab</li> <li> Bitbucket</li> <li> Circle CI</li> <li> Azure Devops</li> </ul>"},{"location":"policy/commit-time-checks/#auto-remediation","title":"Auto-Remediation","text":"<p>Weave validator supports auto-remediation functionality which creates a pull request with suggested fixes to remediate the reported violations.</p> <p>Supported in:</p> <ul> <li> Helm</li> <li> Kustomize</li> <li> Plain kubernetes files</li> </ul> <p>To enable it you need to provide <code>--remediate</code> flag and <code>--git-repo-token</code>.</p> <p>The token must have the permission to create a pull request.</p>"},{"location":"policy/commit-time-checks/#usecase-github","title":"UseCase: Github","text":"<p>See how to setup the Github Action</p>"},{"location":"policy/commit-time-checks/#usecase-gitlab","title":"UseCase: Gitlab","text":"<pre><code>    weave:\nimage:\nname: weaveworks/weave-iac-validator:v1.1\nscript:\n- weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt;\n</code></pre>"},{"location":"policy/commit-time-checks/#enable-auto-remediation","title":"Enable Auto Remediation","text":"<pre><code>  script:\n- weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --git-repo-token $GITLAB_TOKEN --remediate\n</code></pre>"},{"location":"policy/commit-time-checks/#enable-static-application-security-testing","title":"Enable Static Application Security Testing","text":"<pre><code>    stages:\n- weave\n- sast\n\nweave:\nstage: weave\nimage:\nname: weaveworks/weave-iac-validator:v1.1\nscript:\n- weave-validator &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --sast sast.json\nartifacts:\nwhen: on_failure\npaths:\n- sast.json\n\nupload_sast:\nstage: sast\nwhen: always\nscript:\n- echo \"creating sast report\"\nartifacts:\nreports:\nsast: sast.json\n</code></pre>"},{"location":"policy/commit-time-checks/#usecase-bitbucket","title":"UseCase: Bitbucket","text":"<pre><code>pipelines:\ndefault:\n- step:\nname: 'Weaveworks'\nimage: weaveworks/weave-iac-validator:v1.1\nscript:\n- weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt;\n</code></pre>"},{"location":"policy/commit-time-checks/#enable-auto-remediation_1","title":"Enable Auto Remediation","text":"<pre><code>  script:\n- weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --git-repo-token $TOKEN --remediate\n</code></pre>"},{"location":"policy/commit-time-checks/#create-pipeline-report","title":"Create Pipeline Report","text":"<pre><code>  script:\n- weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --git-repo-token $TOKEN -generate-git-report\n</code></pre>"},{"location":"policy/commit-time-checks/#usecase-circleci","title":"UseCase: CircleCI","text":"<pre><code>jobs:\nweave:\ndocker:\n- image: weaveworks/weave-iac-validator:v1.1\nsteps:\n- checkout\n- run:\ncommand: weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt;\n</code></pre>"},{"location":"policy/commit-time-checks/#enable-auto-remediation_2","title":"Enable Auto Remediation","text":"<pre><code>    - run:\ncommand: weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --git-repo-token ${GITHUB_TOKEN} --remediate\n</code></pre>"},{"location":"policy/commit-time-checks/#usecase-azure-devops","title":"UseCase: Azure DevOps","text":"<pre><code>trigger:\n- &lt;list of branches to trigger the pipeline on&gt;\n\npool:\nvmImage: ubuntu-latest\n\ncontainer:\nimage: weaveworks/weave-iac-validator:v1.1-azure\n\nsteps:\n- script: weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --git-repo-token $(TOKEN)\n</code></pre>"},{"location":"policy/commit-time-checks/#enable-auto-remediation_3","title":"Enable Auto Remediation","text":"<pre><code>steps:\n- script: weave-validator --path &lt;path to resources&gt; --policies-path &lt;path to policies&gt; --git-repo-token $(TOKEN) --remediate\n</code></pre>"},{"location":"policy/getting-started/","title":"Getting Started ENTERPRISE","text":"<p>Enabling the Weave Policy Engine features in Weave GitOps is done by running the policy agent on the cluster. This section gives an overview of the policy ecosystem and the steps required for installing and running the policy agent on leaf clusters.</p>"},{"location":"policy/getting-started/#the-policy-ecosystem","title":"The Policy Ecosystem","text":"<p>The policy ecosystem consists of several moving parts. The two primary components are the Policy Agent and the Policy CRs. The agent runs in several modes, and uses the Policy CRs to perform validations on different resources. The results of those validations can be written to different sinks.</p> <p>There are two other optional components: the PolicySet, and the PolicyConfig. The PolicySet can be used to filter policies for a specific mode, while the PolicyConfig can be used to override policy parameters during the validation of a certain resource.</p> <p></p>"},{"location":"policy/getting-started/#installation-pre-requisites","title":"Installation Pre-requisites","text":""},{"location":"policy/getting-started/#weave-gitops","title":"Weave GitOps","text":"<p>You need to have a running instance of Weave GitOps with at least one CAPI provider installed to provision Kubernetes clusters. See Weave GitOps Installation page for more details about installing Weave GitOps.</p>"},{"location":"policy/getting-started/#policy-library","title":"Policy Library","text":"<p>For the policy agent to work, it will need a source for the policies that it will enforce in the cluster. Enterprise customers should request access to fork our policy library into their local repositories. Our policy library includes an extensive list of policy CRs that cover a multitude of security and compliance benchmarks.</p>"},{"location":"policy/getting-started/#install-the-policy-agent","title":"Install the Policy Agent","text":"<p>To install the policy agent on a leaf cluster, you should select the <code>weave-policy-agent</code> from the profiles dropdown in the <code>Create Cluster</code> page.</p> <p></p> <p>You should then configure the <code>values.yaml</code> to pull the policies from your repo into the cluster. This is done by configuring the <code>policySource</code> section. If your policy library repo is private, you will also need to reference the <code>Secret</code> that contains the repo credentials. This is usually the secret you created while bootstrapping Flux on the management cluster and is copied to your leaf cluster during creation.</p> Expand to see an example that creates a new git source <pre><code>policySource:\nenabled: true\nurl: ssh://git@github.com/weaveworks/policy-library # This should be the url of the forked repo\ntag: v1.0.0\npath: ./  # Could be a path to the policies dir or a kustomization.yaml file\nsecretRef: my-pat # the name of the secret containing the repo credentials\n</code></pre> Expand to see an example that uses an existing git source <pre><code>policySource:\nenabled: true\nsourceRef: # Specify the name for an existing GitSource reference\nkind: GitRepository\nname: policy-library\nnamespace: flux-system\n</code></pre> <p>You can find more about other policy profile configurations here.</p>"},{"location":"policy/getting-started/#policies-in-ui","title":"Policies in UI","text":"<p>After the leaf cluster is provisioned and the profile is installed, you should now see the policies listed in the Policies tab in Weave GitOps UI.</p> <p></p> <p>Now you have a provisioned cluster with these policies enforced by the policy agent.</p> <p>By default, the policy profile is set up to enforce policies at deployment time using admission controller, which results in blocking any deployment that violates the enforced policies.</p>"},{"location":"policy/getting-started/#prevent-violating-changes","title":"Prevent Violating Changes","text":"<p>Now let's try to deploy a Kubernetes deployment that violates the <code>Container Image Pull Policy</code> which is one of the enforced policies. This policy is violated when the container's <code>imagePullPolicy</code> is not set to <code>Always</code>.</p> Expand for an example of a violating deployment <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: nginx-deployment\nlabels:\napp: nginx\nspec:\nreplicas: 3\nselector:\nmatchLabels:\napp: nginx\ntemplate:\nmetadata:\nlabels:\napp: nginx\nspec:\ncontainers:\n- name: nginx\nimage: nginx:1.14.2\nimagePullPolicy: IfNotPresent\nports:\n- containerPort: 80\n</code></pre> <p>Once you apply it, the policy agent will deny this request and show a violation message, and accordingly the deployment will not be created.</p>"},{"location":"policy/getting-started/#violations-logs-in-ui","title":"Violations Logs in UI","text":"<p>You can go to the <code>Violations Log</code> in Weave GitOps UI to view the policy violations of all the connected clusters, and dive into the details of each violation.</p> <p>This view shows only the violations resulting from the admission mode by configuring the events sink.</p> <p>Violations Log</p> <p></p> <p>Violations Log Details</p> <p></p>"},{"location":"policy/policy-configuration/","title":"PolicyConfig ENTERPRISE","text":""},{"location":"policy/policy-configuration/#goal","title":"Goal","text":"<p>Users sometimes need to enforce the same policy(s) with different configurations (parameters) for different targets (workspaces, namespaces, applications, or resources). The <code>PolicyConfig</code> CRD allows us to do that without duplicating policies by overriding policy parameters of multiple policies for a specific target.</p>"},{"location":"policy/policy-configuration/#schema","title":"Schema","text":"<p>The PolicyConfig CRD consists of two sections 1) <code>match</code> used to specify the target of this PolicyConfig and 2) <code>config</code> used to specify the policy parameters that will override the orginal policy parameters.</p> Expand to see a PolicyConfig example <pre><code>apiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig      # policy config resource kind\nmetadata:\nname: my-config       # policy config name\nspec:\nmatch:                # matches (targets of the policy config)\nworkspaces:         # add one or more name workspaces\n- team-a\n- team-b\nconfig:               # config for policies [one or more]\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 3\n</code></pre> <p>Each PolicyConfig CR can target either workspaces, namespaces, applications or resources. Targeting the same target explicitly in multiple PolicyConfigs is not allowed, ie: you can't use the same namespace in several PolicyConfigs which target namespaces.</p> <p>To target workspaces:</p> <pre><code>match:\nworkspaces:\n- team-a\n- team-b\n</code></pre> <p>To target namespaces:</p> <pre><code>match:\nnamespaces:\n- dev\n- prod\n</code></pre> <p>To target applications:</p> <pre><code>match:\napps:            # add one or more apps [HelmRelease, Kustomization]\n- kind: HelmRelease\nname: my-app            # app name\nnamespace: flux-system  # app namespace [if empty will match in any namespace]\n</code></pre> <p>To target resources:</p> <pre><code>match:\nresources:       # add one or more resources [Deployment, ReplicaSet, ..]\n- kind: Deployment\nname: my-deployment     # resource name\nnamespace: default      # resource namespace [if empty will match in any namespace]\n</code></pre> <p>Each PolicyConfig can override the parameters of one or more policies:</p> <pre><code>config:               # config for policies [one or more]\nweave.policies.containers-minimum-replica-count: # the id of the policy\nparameters:\nreplica_count: 3\nowner: owner-4\nweave.policies.containers-running-in-privileged-mode:\nparameters:\nprivilege: true\n</code></pre>"},{"location":"policy/policy-configuration/#overlapping-targets","title":"Overlapping Targets","text":"<p>While it's not possible to create PolicyConfigs that explicitly target the same targets, it can happen implicitly ex: by targeting a namespace in a PolicyConfig and targeting an application that exists in this namespace in another. Whenever targets overlap, the narrower the scope of the PolicyConfig, the more precedence it has. Accordingly in the previous example, the configuration of the PolicyConfig targeting the application will have precedence over the PolicyConfig targeting the namespace.</p> <p>Those are the possible targets from lowest to highest precedence:</p> <ul> <li>PolicyConfig which targets a workspace.</li> <li>PolicyConfig which targets a namespace.</li> <li>PolicyConfig which targets an application in all namespaces.</li> <li>PolicyConfig which targets an application in a certain namespace.</li> <li>PolicyConfig which targets a kubernetes resource in all namespaces.</li> <li>PolicyConfig which targets a kubernetes resource in a specific namespace.</li> </ul> <p>Note:</p> <ul> <li>All configs are applied from low priority to high priority while taking into consideration the common parameters between configs.</li> <li>Each config only affects the parameters defined in it.</li> </ul>"},{"location":"policy/policy-configuration/#example","title":"Example","text":"<p>We have a Kustomization application <code>app-a</code> and deployment <code>deployment-1</code> which is part of this application.</p> Expand to see manifests <pre><code>apiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: my-config-1\nspec:\nmatch:\nnamespaces:\n- flux-system\nconfig:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 2\nowner: owner-1\n---\napiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: my-config-2\nspec:\nmatch:\napps:\n- kind: Kustomization\nname: app-a\nconfig:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 3\n---\napiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: my-config-3\nspec:\nmatch:\napps:\n- kind: Kustomization\nname: app-a\nnamespace: flux-system\nconfig:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 4\n---\napiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: my-config-4\nspec:\nmatch:\nresources:\n- kind: Deployment\nname: deployment-1\nconfig:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 5\nowner: owner-4\n---\n\napiVersion: pac.weave.works/v2beta2\nkind: PolicyConfig\nmetadata:\nname: my-config-5\nspec:\nmatch:\nresources:\n- kind: Deployment\nname: deployment-1\nnamespace: flux-system\nconfig:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 6\n</code></pre> <p>In the above example when you apply the 5 configurations...</p> <ul> <li><code>app-a</code> will be affected by <code>my-config-5</code>. It will be applied on the policies defined in it, which will affect deployment <code>deployment-1</code> in namespace <code>flux-system</code> as it matches the kind, name and namespace.</li> </ul> <p>Note</p> <p>Deploying <code>deployment-1</code> in another namespace other than <code>flux-system</code> won't be affected by this configuration</p> <p>Final config values will be as follows:</p> <pre><code>    config:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 6 # from my-config-5\nowner: owner-4   # from my-config-4\n</code></pre> <ul> <li>Deployment <code>deployment-1</code> in namespace <code>flux-system</code>, <code>replica_count</code> must be <code>&gt;= 6</code></li> <li>Also it will be affected by <code>my-config-4</code> for <code>owner</code> configuration parameter <code>owner: owner-4</code></li> </ul> <p>In the above example when you apply <code>my-config-1</code>, <code>my-config-2</code>, <code>my-config-3</code> and <code>my-config-4</code></p> <ul> <li><code>my-config-4</code> will be applied on the policies defined in it which will affect deployment <code>deployment-1</code> in all namespaces as it matches the kind and name only.</li> </ul> <p>Final config values will be as follows:</p> <pre><code>    config:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 5  # from my-config-4\nowner: owner-4    # from my-config-4\n</code></pre> <ul> <li>Deployment <code>deployment-1</code> in all namespaces <code>replica_count</code> must be <code>&gt;= 5</code></li> <li>Also it will be affected by <code>my-config-4</code> for <code>owner</code> configuration parameter <code>owner: owner-4</code></li> </ul> <p>In the previous example when you apply <code>my-config-1</code>, <code>my-config-2</code> and <code>my-config-3</code></p> <ul> <li><code>my-config-3</code> will be applied on the policies defined in it which will affect application <code>app-a</code> and all the resources in it in namespace <code>flux-system</code> as it matches the kind, name and namespace.</li> </ul> <p>Note</p> <p>Deploying <code>app-a</code> in another namespace other than <code>flux-system</code> won't be affected by this configuration</p> <p>Final config values will be the follows:</p> <pre><code>    config:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 4    # from my-config-3\nowner: owner-1      # from my-config-1\n</code></pre> <ul> <li>Application <code>app-a</code> and all the resources in it in namespaces <code>flux-system</code>, <code>replica_count</code> must be <code>&gt;= 4</code></li> <li>Also it will be affected by <code>my-config-1</code> for <code>owner</code> configuration parameter <code>owner: owner-1</code></li> </ul> <p>In the above example when you apply <code>my-config-1</code> and <code>my-config-2</code></p> <ul> <li><code>my-config-2</code> will be applied on the policies defined in it which will affect application <code>app-a</code> and all the resources in it in all namespaces as it matches the kind and name only.</li> </ul> <p>Final config values will be as follows:</p> <pre><code>    config:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 3   # from my-config-2\nowner: owner-1     # from my-config-1\n</code></pre> <ul> <li>Application <code>app-a</code> and all the resources in all namespaces, <code>replica_count</code> must be <code>&gt;= 3</code></li> <li>Also it will be affected by <code>my-config-1</code> for <code>owner</code> configuration parameter <code>owner: owner-1</code></li> </ul> <p>In the above example when you apply <code>my-config-1</code></p> <ul> <li><code>my-config-1</code> will be applied on the policies defined in it. which will affect the namespace <code>flux-system</code> with all applications and resources in it as it matches by namespace only.</li> </ul> <p>Final config values will be as follows:</p> <pre><code>    config:\nweave.policies.containers-minimum-replica-count:\nparameters:\nreplica_count: 2  # from my-config-1\nowner: owner-1    # from my-config-1\n</code></pre> <ul> <li>Any application or resource in namespace <code>flux-system</code>, <code>replica_count</code> must be <code>&gt;= 2</code></li> <li>Also it will be affected by <code>my-config-1</code> for <code>owner</code> configuration parameter <code>owner: owner-1</code></li> </ul>"},{"location":"policy/policy-set/","title":"PolicySet ENTERPRISE","text":"<p>This is an optional custom resource that is used to select a group of policies to work in specific modes.</p> <p>In each mode, the agent will list all the PolicySets of this mode and check which policies match any of those policysets, then validate the resources against them.</p> <p>If there are no PolicySets found for a certain mode, all policies will be applied during this mode.</p> <p>Note: Tenant Policies is always active in the Admission mode, event if it is not selected in the <code>admission</code> policysets</p> <p>Example <pre><code>apiVersion: pac.weave.works/v2beta2\nkind: PolicySet\nmetadata:\nname: my-policy-set\nspec:\nmode: admission\nfilters:\nids:\n- weave.policies.containers-minimum-replica-count\ncategories:\n- security\nseverities:\n- high\n- medium\nstandards:\n- pci-dss\ntags:\n- tag-1\n</code></pre></p> <p>PolicySets can be created for any of the three modes supported by the agent: <code>admission</code>, <code>audit</code>, and <code>tfAdmission</code>.</p>"},{"location":"policy/policy-set/#grouping-policies","title":"Grouping Policies","text":"<p>Policies can be grouped by their ids, categories, severities, standards and tags</p> <p>The policy will be applied if any of the filters are matched.</p>"},{"location":"policy/policy-set/#migration-from-v2beta1-to-v2beta2","title":"Migration from v2beta1 to v2beta2","text":""},{"location":"policy/policy-set/#new-fields","title":"New fields","text":"<ul> <li>New required field <code>spec.mode</code> is added. PolicySets should be updated to set the mode</li> </ul> <p>Previously the agent was configured with which policysets to use in each mode. Now we removed this argument from the agent's configuration and add the mode to the Policyset itself.</p>"},{"location":"policy/policy-set/#example-of-the-agent-configuration-in-versions-older-than-v200","title":"Example of the agent configuration in versions older than v2.0.0","text":"<pre><code># config.yaml\nadmission:\nenabled: true\npolicySet: admission-policy-set\nsinks:\nfilesystemSink:\nfileName: admission.txt\n</code></pre>"},{"location":"policy/policy-set/#example-of-current-policyset-with-mode-field","title":"Example of current PolicySet with mode field","text":"<pre><code>apiVersion: pac.weave.works/v2beta2\nkind: PolicySet\nmetadata:\nname: admission-policy-set\nspec:\nmode: admission\nfilters:\nids:\n- weave.policies.containers-minimum-replica-count\n</code></pre>"},{"location":"policy/policy-set/#updated-fields","title":"Updated fields","text":"<ul> <li>Field <code>spec.name</code> became optional.</li> </ul>"},{"location":"policy/policy-set/#deprecate-fields","title":"Deprecate fields","text":"<ul> <li>Field <code>spec.id</code> is deprecated.</li> </ul>"},{"location":"policy/policy/","title":"Policy ENTERPRISE","text":""},{"location":"policy/policy/#policy-crd","title":"Policy CRD","text":"<p>The Policy CRD is used to define policies which are then consumed and used by the agent to validate entities.</p> <p>It uses OPA Rego Language to evaluate the entities.</p>"},{"location":"policy/policy/#policy-library","title":"Policy Library","text":"<p>You should have a policy library repo set up which includes your policies resources as CRDs.</p> <p>Info</p> <p>Enterprise customers should have access to fork policy library repo into their local repositories.</p>"},{"location":"policy/policy/#tenant-policy","title":"Tenant Policy","text":"<p>Tenant policies are special policies that are used by the Multi Tenancy feature in Weave GitOps Enterprise</p> <p>Tenant policies have a special tag <code>tenancy</code>.</p>"},{"location":"policy/policy/#mutating-resources","title":"Mutating Resources","text":"<p>Starting from version <code>v2.2.0</code>, the policy agent will support mutating resources.</p> <p>To enable mutating resources, policies must have field <code>mutate</code> set to <code>true</code> and the rego code should return the <code>violating_key</code> and the <code>recommended_value</code> in the violation response. The mutation webhook will use the <code>violating_key</code> and <code>recommended_value</code> to mutate the resource and return the new mutated resource.</p> <p>Example</p> <pre><code>result = {\n    \"issue_detected\": true,\n    \"msg\": sprintf(\"Replica count must be greater than or equal to '%v'; found '%v'.\", [min_replica_count, replicas]),\n    \"violating_key\": \"spec.replicas\",\n    \"recommended_value\": min_replica_count\n}\n</code></pre>"},{"location":"policy/policy/#policy-validation","title":"Policy Validation","text":"<p>The policy validation object is the result of validating an entity against a policy. It contains all the necessary information to give the user a clear idea on what caused this violation or compliance.</p> <pre><code>id: string # identifier for the violation\naccount_id: string # organization identifier\ncluster_id: string # cluster identifier\npolicy: object # contains related policy data\nentity: object # contains related resource data\nstatus: string # Violation or Compliance\nmessage: string # message that summarizes the policy validation\ntype: string # the mode that produced this object. one of: Admission, Audit, TFAdmission\ntrigger: string # what triggered the validation, create request or initial audit,..\ncreated_at: string # time that the validation occurred in\n</code></pre>"},{"location":"policy/releases/","title":"Profile Releases ENTERPRISE","text":""},{"location":"policy/releases/#v065","title":"v0.6.5","text":""},{"location":"policy/releases/#highlights","title":"Highlights","text":"<ul> <li>Agent</li> <li>Add support for mutating violating resource.</li> </ul>"},{"location":"policy/releases/#dependency-versions","title":"Dependency Versions","text":"<ul> <li>Policy Agent v2.2.0</li> </ul>"},{"location":"policy/releases/#policy-library-compatibility","title":"Policy Library Compatibility","text":"<p>Compatible with Policy Library versions:</p> <ul> <li>v1.2.0</li> </ul> <p>Needs this migration steps to be compatible with the following versions:</p> <ul> <li>v1.1.0</li> <li>v1.0.0</li> <li>v0.4.0</li> </ul>"},{"location":"policy/releases/#v064","title":"v0.6.4","text":""},{"location":"policy/releases/#highlights_1","title":"Highlights","text":"<ul> <li>Agent</li> <li>Add PolicyConfig CRD to make it possible to customize policy configuration per namespaces, applications or resources</li> <li>Add mode field to policy set and add policy modes to its status</li> <li>Add policy modes to labels to support filtering</li> <li>Support backward compatibility for policy version v2beta1</li> </ul>"},{"location":"policy/releases/#dependency-versions_1","title":"Dependency Versions","text":"<ul> <li>Policy Agent v2.0.0</li> </ul>"},{"location":"policy/releases/#policy-library-compatibility_1","title":"Policy Library Compatibility","text":"<p>Compatible with Policy Library versions:</p> <ul> <li>v1.2.0</li> </ul> <p>Needs this migration steps to be compatible with the following versions:</p> <ul> <li>v1.1.0</li> <li>v1.0.0</li> <li>v0.4.0</li> </ul>"},{"location":"policy/releases/#v063","title":"v0.6.3","text":""},{"location":"policy/releases/#highlights_2","title":"Highlights","text":"<ul> <li>Agent</li> <li>Reference flux objects in violations events instead of the original resource object to be able to list specific flux application violations</li> </ul>"},{"location":"policy/releases/#dependency-versions_2","title":"Dependency Versions","text":"<ul> <li>policy-agent 1.2.1</li> </ul>"},{"location":"policy/releases/#policy-library-compatibility_2","title":"Policy Library Compatibility","text":"<ul> <li>v0.4.0</li> <li>v1.0.0</li> <li>v1.1.0</li> </ul>"},{"location":"policy/releases/#v062","title":"v0.6.2","text":""},{"location":"policy/releases/#highlights_3","title":"Highlights","text":"<ul> <li>Agent</li> <li>Add Terraform mode to allow validating terraform plans</li> <li>Support targeting kubernetes HPA resources</li> </ul>"},{"location":"policy/releases/#dependency-versions_3","title":"Dependency Versions","text":"<ul> <li>policy-agent 1.2.0</li> </ul>"},{"location":"policy/releases/#policy-library-compatibility_3","title":"Policy Library Compatibility","text":"<ul> <li>v0.4.0</li> <li>v1.0.0</li> <li>v1.1.0</li> </ul> <p>While both v.0.4.0 and v1.0.0 are compatible with the agent. Only v1.1.0 includes the modification needed to make Controller Minimum Replica Count policy with with <code>horizontalpodautoscalers</code></p>"},{"location":"policy/releases/#v061","title":"v0.6.1","text":""},{"location":"policy/releases/#highlights_4","title":"Highlights","text":"<ul> <li>Agent</li> <li>Make the audit interval configurable through <code>config.audit.interval</code>. It defaults to 24 hours.</li> <li>Add support for targeting certain flux resources (kustomizations, helmreleases and ocirepositories) in the admission mode.</li> <li>Profile</li> <li>Add the ability to use an existing GitSource instead of creating a new one.</li> </ul>"},{"location":"policy/releases/#dependency-versions_4","title":"Dependency Versions","text":"<ul> <li>policy-agent 1.1.0</li> </ul>"},{"location":"policy/releases/#policy-library-compatibility_4","title":"Policy Library Compatibility","text":"<ul> <li>v0.4.0</li> <li>v1.0.0</li> </ul>"},{"location":"policy/releases/#v060","title":"v0.6.0","text":""},{"location":"policy/releases/#highlights_5","title":"Highlights","text":"<ul> <li>Agent</li> <li>Configure the agent through a configuration file instead of arguments.</li> <li>Allow defining different validation sinks for audit and admission modes.</li> <li>Add the PolicySet CRD to the hem chart.</li> <li>Profile</li> <li>Disable the default policy source.</li> </ul>"},{"location":"policy/releases/#dependency-versions_5","title":"Dependency Versions","text":"<ul> <li>policy-agent 1.0.0</li> </ul>"},{"location":"policy/releases/#policy-library-compatibility_5","title":"Policy Library Compatibility","text":"<ul> <li>v0.4.0</li> <li>v1.0.0</li> </ul>"},{"location":"policy/weave-policy-profile/","title":"Policy Profile ENTERPRISE","text":""},{"location":"policy/weave-policy-profile/#overview","title":"Overview","text":"<p>Weave policy profile provides policies to automate the enforcement of best practices and conventions. It ensures the compliance of workloads through the use of a policy agent that provides an admission controller webhook that stops violating resources from deploying to a cluster and runs a daily audit that reports violating resources already deployed.</p> <p>The profile configuration contains two main sections <code>policySource</code> to configure the source for deploying policies and <code>policy-agent</code> to configure the policy agent.</p> Expand for an example of the profile values file <pre><code>policy-agent:\nfailurePolicy: Ignore\n\n# If you don't want to use cert-manager, set useCertManager to false and provide your own certs\nuseCertManager: true\ncertificate: \"\"\nkey: \"\"\ncaCertificate: \"\"\n\npersistence:\nenabled: false\n# claimStorage: 1Gi\n# sinkDir: /tmp\n# storageClassName: standard\n\nconfig:\naccountId: \"\"\nclusterId: \"\"\n\naudit:\n# Enable audit functionality\nenabled: false\n# sinks:\n#   # Enable writing violations as K8s events\n#   k8sEventsSink:\n#     enabled: true\n\nadmission:\n# Enable admission functionality\nenabled: true\n# mutate: true # enable mutating violating resources\nsinks:\n# Enable writing violations as K8s events\nk8sEventsSink:\nenabled: true\n\n\npolicySource:\nenabled: false\n# url: ssh://git@github.com/weaveworks/policy-library\n# tag: v1.0.0\n# branch:\n# path: ./  # Could be a path to the policies dir or a kustomization.yaml file\n# secretRef: policy-library-auth  # (Optional): Name of the K8s secret with private repo auth credentials\n# sourceRef: # Could specify a name for an existing GitSource reference instead of creating a new one\n#   kind: GitRepository\n#   name: policy-library\n#   namespace: flux-system\n</code></pre>"},{"location":"policy/weave-policy-profile/#policy-sources","title":"Policy Sources","text":"<p>Policies are provided in the profile as Custom Resources. The agent reads from the policies deployed on the cluster and runs them during each admission request or when auditing a resource.</p> <p>Policies are hosted in a policy library which is usually a git repository. They are fetched in the profile through the use of <code>kustomize.toolkit.fluxcd.io.Kustomization</code>, that deploys the policies to the cluster.</p> <p>By default all policies in the specified path would be deployed in order to specify which policies should be deployed in a library, a <code>kustomize.config.k8s.io.Kustomization</code> file should be defined in the repository.</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources: # specifies the path to each required policy\n- policies/ControllerContainerAllowingPrivilegeEscalation/policy.yaml\n- policies/ControllerContainerRunningAsRoot/policy.yaml\n- policies/ControllerReadOnlyFileSystem/policy.yaml\n</code></pre> <p>The profile then needs to be configured with the necessary config to be able to reach the repository that is acting as a policy library.</p> <pre><code>policySource:\nenabled: true\nurl: URL of the repo where your policies exist\ntag: tag name on the policies repo\npath: Path to the policies dir - or a kustomization.yaml that selects some policies - in the repo\nsecretRef (if the repo is private): Name of the K8s secret with private repo credentials (leave empty if the repo is public)\n</code></pre> <p>There is the option of referencing an existing policy library source instead of creating a new one. <pre><code>policySource:\nenabled: true\nsourceRef:\nkind: Kind of the existing source\nname: Name of the policy library source\nnamespace: Namespace where the source exists\n</code></pre></p>"},{"location":"policy/weave-policy-profile/#policy-agent-configuration","title":"Policy Agent Configuration","text":"<p>The <code>config</code> section is the single entry point for configuring the agent.</p> <p>The agent needs the following parameters to be provided in the configuration yaml file:</p> <ul> <li><code>accountId</code>: unique identifier that signifies the owner of that agent</li> <li><code>clusterId</code>: unique identifier for the cluster that the agent will run against</li> </ul> <p>The following optional parameters can also be provided:</p> <ul> <li><code>logLevel</code>: app log level (default: \"info\")</li> <li><code>probesListen</code>: address for the probes server to run on (default: \":9000\")</li> <li><code>metricsAddress</code>: address the metric endpoint binds to (default: \":8080\")</li> </ul>"},{"location":"policy/weave-policy-profile/#agent-modes","title":"Agent Modes","text":""},{"location":"policy/weave-policy-profile/#admission","title":"Admission","text":"<p>This contains the admission module that enforces policies. It uses the <code>controller-runtime</code> Kubernetes package to register a callback that will be called when the agent receives an admission request. Once called, the agent will validate the received resource against the admission and tenant policies and k8s will use the result of this validation to either allow or reject the creation/update of said resource.</p> <p>Works with policies of provider <code>kubernetes</code></p> <p>To enable admission control:</p> <pre><code>policy-agent:\nconfig:\nadmission:\nenabled: true\n</code></pre> <p>Enabling admission controller requires certificates for secure communication with the webhook client and the admission server. The best way to achieve this is by installing cert manager and then configuring the profile as follows:</p> <pre><code>policy-agent:\nuseCertManager: true\n</code></pre> <p>The cert manager can also be installed by installing the cert manager profile while creating the cluster.</p> <p>There is the option of providing previously generated certificates although it is not recommended and it is up to the user to manage it:</p> <pre><code>policy-agent:\ncertificate: \"---\" # admission server certificate\nkey: \"---\" # admission server private key\ncaCertificate: \"---\" # CA bundle to validate the webhook server, used by the client\n</code></pre> <p>If the agent webhook could not be reached or the request failed to complete, the corresponding request would be refused. To change that behavior and accepts the request in cases of failure, this needs to be set:</p> <pre><code>policy-agent:\nfailurePolicy: Ignore\n</code></pre>"},{"location":"policy/weave-policy-profile/#audit","title":"Audit","text":"<p>The audit functionality provides a full scan of the cluster(s) and reports back policy violations. This usually is used for policy violations reporting, and compliance posture analysis against known benchmarks like PCI DSS, CIS, .etc.</p> <p>Works with policies of provider <code>kubernetes</code></p> <p>To enable the audit functionality:</p> <pre><code>policy-agent:\nconfig:\naudit:\nenabled: true\ninterval: 24 # configuring the frequent of audit operations running in hours (default is 24 hours)\n</code></pre> <p>The audit will be performed when the agent starts and then again periodically at an interval of your choice in hours (default is 24 hours). The results of the audit will be published to the configured sink(s).</p>"},{"location":"policy/weave-policy-profile/#terraform-admission","title":"Terraform Admission","text":"<p>This is a webhook used to validate terraform plans. It is mainly used by the TF-Controller to enforce policies on terraform plans</p> <p>Works with policies of provider <code>terraform</code></p> <p>To enable the terraform admission control:</p> <pre><code>policy-agent:\nconfig:\ntfAdmission:\nenabled: true\n</code></pre>"},{"location":"policy/weave-policy-profile/#policy-validation-sinks","title":"Policy Validation Sinks","text":"<p>When validating a resource, a validation object is generated that contains information about the status of that validation and metadata about the resource and policy involved. These objects can be exported to be visible for users as a critical part of the audit flow, but can also be useful as logs for the admission scenario.</p> <p>By default, the agent only writes policy validations that are violating a certain policy when performing an audit. To write compliance results as well, the following needs to be specified in the profile:</p> <pre><code>policy-agent:\nconfig:\naudit:\nwriteCompliance: true\n</code></pre> <p>The agent profile supports storing the validations in different sinks. Multiple sinks can be used at the same time:</p> Text fileKubernetes EventsNotification ControllerElasticsearch <p>The results will be dumped into a text file in the <code>logs</code> directory, in the agent container as a json string. It is important to note that this file will not be persisted and will be deleted upon pod restart, so generally this approach is not recommended for a production environment.</p> <p>To enable writing to a text file in audit scenario:</p> <pre><code>policy-agent:\nconfig:\naudit:\nsinks:\nfileSystemSink:\nfileName: \"file.json\"\n</code></pre> <p>To enable writing to a text file in admission scenario:</p> <pre><code>policy-agent:\nconfig:\nadmission:\nsinks:\nfileSystemSink:\nfileName: \"file.json\"\n</code></pre> <p>It is possible to make the file persistent using the following configuration. This assumes that there is a PersistentVolume already configured on the cluster.</p> <pre><code>policy-agent:\npersistence:\nenabled: false # specifies whether to use persistence or not\nclaimStorage: 1Gi # claim size\nstorageClassName: standard # k8s StorageClass name\n</code></pre> <p>The results will be written as Kubernetes events. This means that they are accessible through the kubernetes API and can be consumed by custom exporters.</p> <p>To enable writing Kubernetes events in audit scenario:</p> <pre><code>policy-agent:\nconfig:\naudit:\nsinks:\nk8sEventsSink:\nenabled: true\n</code></pre> <p>To enable writing Kubernetes events in admission scenario:</p> <pre><code>policy-agent:\nconfig:\nadmission:\nsinks:\nk8sEventsSink:\nenabled: true\n</code></pre> <p>This requires the cluster to be managed using flux. It makes use of the flux notification controller to send events to multiple sources, depending on the controller configuration. The agent writes the events to the controller and it proceeds to publish it to the configured listeners.</p> <p>To enable writing to flux notification controller in audit scenario:</p> <pre><code>policy-agent:\nconfig:\naudit:\nsinks:\nfluxNotificationSink:\naddress: \"\"\n</code></pre> <p>To enable writing to flux notification controller in admission scenario:</p> <pre><code>policy-agent:\nconfig:\nadmission:\nsinks:\nfluxNotificationSink:\naddress: \"\"\n</code></pre> <p>The results of validating entities against policies will be written to an Elasticsearch index.</p> <p>To enable writing to elasticsearch in audit scenario:</p> <pre><code>policy-agent:\nconfig:\naudit:\nsinks:\nelasticSink:\naddress: \"\"\nusername: \"\"\npassword: \"\"\nindexName: \"\"\ninsertionMode: \"upsert\"\n</code></pre> <p>To enable writing to elasticsearch in admission scenario:</p> <pre><code>policy-agent:\nconfig:\nadmission:\nsinks:\nelasticSink:\naddress: \"\"\nusername: \"\"\npassword: \"\"\nindexName: \"\"\ninsertionMode: \"insert\"\n</code></pre> <p>We support the following insertion modes:</p> <ul> <li><code>insert</code>: doesn't update or delete any old records. The index will contain a log for all validation objects and give an insight of all the historical data.</li> <li><code>upsert</code>: updates the old result of validating an entity against a policy that happened on the same day. So the index will only contain the latest validation results for a policy and entity combination per day.</li> </ul>"},{"location":"progressive-delivery/flagger-manual-gating/","title":"Manual Approval for Progressive Delivery Deployments ENTERPRISE","text":"<p>To help you understand the state of progressive delivery updates to your applications, Weave GitOps Enterprise uses Flagger\u2014part of the Flux family of open source projects. WGE's Delivery view shows all of your deployed <code>Canary</code> objects and rollout progress.</p> <p>By default, Flagger automatically promotes a new version of an application whenever it passes the defined checks of an analysis phase. However, you can also configure webhooks to enable manual approvals of rollout stages.</p> <p>This guide shows you how to manually gate a progressive delivery promotion with Flagger by using the in-built load tester.</p>"},{"location":"progressive-delivery/flagger-manual-gating/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Flagger</li> <li>An existing <code>Canary</code> object and target deployment</li> <li>Flagger's load tester installed</li> </ul>"},{"location":"progressive-delivery/flagger-manual-gating/#basic-introduction-to-webhooks-and-gating","title":"Basic Introduction to Webhooks and Gating","text":"<p>You can configure Flagger to work with several types of hooks that will be called at  given stages during a progressive delivery rollout. Some of these hooks allow you to manually  gate whether a rollout proceeds at certain points: - Before scaling up a new deployment and canary analysis begins with <code>confirm-rollout</code>.  - Before increasing traffic weight with <code>confirm-traffic-increase</code>. - Before promoting a new version after successful canary analysis with <code>confirm-promotion</code>.</p> <p>Any URL can serve as a webhook target. It will approve if a <code>200 OK</code> status code is returned, and halt if <code>403 Forbidden</code>.</p> <p>The webhook will receive a JSON payload that can be unmarshaled as <code>CanaryWebhookPayload</code>:</p> <pre><code>type CanaryWebhookPayload struct {\n// Name of the canary\nName string `json:\"name\"`\n\n// Namespace of the canary\nNamespace string `json:\"namespace\"`\n\n// Phase of the canary analysis\nPhase CanaryPhase `json:\"phase\"`\n\n// Metadata (key-value pairs) for this webhook\nMetadata map[string]string `json:\"metadata,omitempty\"`\n}\n</code></pre> <p>The Flagger documentation provides more information about webhooks.</p>"},{"location":"progressive-delivery/flagger-manual-gating/#use-flaggers-load-tester-to-manually-gate-a-promotion","title":"Use Flagger's Load Tester to Manually Gate a Promotion","text":"<p>To enable manual approval of a promotion, configure the  <code>confirm-promotion</code> webhook. This will call a particular gate provided through  Flagger's load tester, and is an easy way to experiment using Flagger's included components. </p> <p>Tip</p> <p>We strongly recommend that you DO NOT USE the load tester for manual gating in a production environment. It lacks auth, so anyone with cluster access could open and close it. It also lacks storage, so all gates would close upon a restart. Instead, configure these webhooks for appropriate integration with a tool of your choice, such Jira, Slack, Jenkins, etc.</p>"},{"location":"progressive-delivery/flagger-manual-gating/#configure-the-confirm-promotion-webhook","title":"Configure the <code>confirm-promotion</code> Webhook","text":"<p>In your canary object, add the following in the <code>analysis</code> section:</p> <pre><code>  analysis:\nwebhooks:\n- name: \"ask for confirmation\"\ntype: confirm-promotion\nurl: http://flagger-loadtester.test/gate/check\n</code></pre> <p>This gate is closed by default.</p>"},{"location":"progressive-delivery/flagger-manual-gating/#deploy-a-new-version-of-your-application","title":"Deploy a New Version of Your Application","text":"<p>Trigger a Canary rollout by updating your target deployment/daemonset\u2014for  example, by bumping the container image tag. A full list of ways to trigger  a rollout is available here.</p> <p>Weave GitOps Enterprise (WGE)'s Applications &gt; Delivery view enables you to watch the progression of a canary:</p> <p></p>"},{"location":"progressive-delivery/flagger-manual-gating/#wait-for-the-canary-analysis-to-complete","title":"Wait for the Canary Analysis to Complete","text":"<p>Once the canary analysis has successfully completed, Flagger will call the  <code>confirm-promotion</code> webhook and change status to <code>WaitingPromotion</code>:</p> <p></p> <p></p>"},{"location":"progressive-delivery/flagger-manual-gating/#open-the-gate","title":"Open the Gate","text":"<p>To open the gate and confirm that you approve promotion of the new  version of your application, exec into the load tester  container:</p> <pre><code>$ kubectl -n test exec -it flagger-loadtester-xxxx-xxxx sh\n\n# to open\n&gt; curl -d '{\"name\": \"app\",\"namespace\":\"test\"}' http://localhost:8080/gate/open\n</code></pre> <p>Flagger will now promote the canary version to the primary and  complete the progressive delivery rollout. </p> <p></p> <p></p> <p></p> <p>To manually close the gate again, issue this command:</p> <pre><code>&gt; curl -d '{\"name\": \"app\",\"namespace\":\"test\"}' http://localhost:8080/gate/close\n</code></pre> <p>References:</p> <ul> <li>The Official Flagger documentation informs this guide.</li> </ul>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/","title":"Progressive Delivery Using Flagger ENTERPRISE","text":"<p>Built upon the core tenets of continuous integration and continuous delivery (CI/CD), progressive delivery involves gradually rolling out features to small groups of select users to balance performance with speed. Developers and DevOps teams use fine-grained controls to minimize the risks of pushing new features to the production environment. If the newly released feature proves to be stable and performant, it can then be released to all users.</p> <p>Flagger is a progressive delivery operator for Kubernetes and part of the Flux family of open source projects. It reduces the risk of introducing new software versions and automates production releases to improve your time to delivery. Flagger implements deployment strategies\u2014canary releases, A/B testing, Blue/Green mirroring\u2014using a service mesh (App Mesh, Istio, Linkerd, Kuma, Open Service Mesh) or an ingress controller (Contour, Gloo, NGINX, Skipper, Traefik, APISIX) for traffic routing. For release analysis, Flagger can query Prometheus, InfluxDB, Datadog, New Relic, CloudWatch, Stackdriver, or Graphite. For alerting it uses Slack, MS Teams, Discord, and Rocket. Using Flux allows us to manage our cluster applications in a declarative way through changes in a Git repository.</p> <p>Weave GitOps Enterprise integrates with Flagger in order to provide a view on progressive delivery deployments. This includes the ability to view all the resources that Flagger manages during its operation. The default ClusterRole <code>gitops-canaries-reader</code> includes the minimum permissions necessary for a user to be able to view canary object details, metric template object details and canary related events. </p> <p>The WGE UI's Applications &gt; Delivery view provides an \"at a glance\" view so that you can understand the status of your progressive delivery rollouts across a fleet of connected clusters. This removes the cognitive overhead of having to know which objects to query and where they are located. You can also drill down into each rollout to understand its status and configuration, and view near-to-realtime data on any summary or details page.</p> <p></p> <p>How to use WGE's progressive delivery offering: - if you don\u2019t have Flagger installed on any clusters, you'll receive an onboarding message about installing it - click on the delivery tab on the menu bar to retrieve a table view of canaries with key summary information regarding their location and state - click on a canary to see more detailed information about status, gates, and other elements - click on the events tab on the detail page to see the most recent Kubernetes events for that canary and learn more about deployment history - click on the yaml tab on the detail page to see the raw yaml of the canary - view objects from any cluster/namespace that you have the appropriate permissions for, and nothing else</p> <p>Supported deployment strategies include:</p> <p> Canary Release: the system gradually shifts traffic to a new version of an application and assesses performance\u2014either promoting the release or abandoning it, based on performance.</p> <p> A/B Testing: uses HTTP headers or cookies to ensure users remain on the same version of an application during a canary analysis.</p> <p> Blue/Green: Traffic is switched from the current application to a new version based on the success of testing.</p> <p> Blue/Green with Traffic Mirroring: sends copies of incoming requests to the new version of an application. The user receives the response from the current application and the other is discarded. The new version is promoted only if metrics are healthy.</p> <p>This guide uses Flux manifests to install Flagger and Linkerd, a CNCF project and service mesh for Kubernetes and beyond. We will walk you through a full end-to-end scenario where you will: - Install the Linkerd service mesh - Install Flagger - Deploy a sample application using a canary release strategy based on metrics provided through   Linkerd's in-built Prometheus instance</p>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#prerequisites","title":"Prerequisites","text":"<ul> <li>This guide assumes you already have a Kubernetes cluster running and have bootstrapped Flux. To apply the manifests listed here, you will need to commit them to a repository being reconciled with Flux.</li> <li>Flagger requires the <code>autoscaling/v2</code> or <code>autoscaling/v2beta2</code> API to be installed on your cluster. You can use <code>kubectl api-resources</code> to check which API versions are supported.</li> <li>The step CLI installed to generate certificates that support mTLS connections.</li> </ul>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#installing-linkerd-using-flux","title":"Installing Linkerd Using Flux","text":"<p>To install Linkerd we'll use a Kustomization file. It will allow us to specify the order and default namespace for the installed resources, and to generate Secrets from certificate files via the use of a <code>secretGenerator</code>.</p> <p>To support mTLS connections between meshed pods, Linkerd requires a trust anchor certificate and an issuer certificate with its corresponding key. These certificates are automatically created via the <code>linkerd install</code> command. However, when using a Helm chart to install Linkerd, you must provide these certificates deliberately. The <code>step</code> CLI, listed above, allows us to generate these certificates.</p> <p>To generate the trust anchor certificate, run: <pre><code>step certificate create root.linkerd.cluster.local ca.crt ca.key \\\n--profile root-ca --no-password --insecure\n</code></pre></p> <p>To generate the issuer certificate, run: <pre><code>step certificate create identity.linkerd.cluster.local issuer.crt issuer.key \\\n--profile intermediate-ca --not-after 8760h --no-password --insecure \\\n--ca ca.crt --ca-key ca.key\n</code></pre></p> <p>Add the <code>ca.crt</code>, <code>issuer.crt</code>, and <code>issuer.key</code> files to the cluster repository under a <code>linkerd</code> directory.</p> <p>Let's add the three manifests for Linkerd components under the <code>./linkerd</code> directory: - A <code>Namespace</code> resource to control where the components are installed - A <code>HelmRepository</code> resource to make the Linkerd Helm repo available on the     cluster - A <code>HelmRelease</code> resource to install the latest version of Linkerd from the     <code>HelmRepository</code></p> Expand to see and copy-paste the three Linkerd manifests to add linkerd/namespace.yaml<pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\nname: linkerd\nlabels:\nconfig.linkerd.io/admission-webhooks: disabled\n</code></pre> linkerd/source.yaml<pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: linkerd\nspec:\ninterval: 1h\nurl: https://helm.linkerd.io/stable\n</code></pre> <p>Note: The value for the <code>spec.values.identity.issuer.crtExpiry</code> field below depends on the parameter value used during the creation of the issuer certificate. In this example, it should be set to one year from the certificate creation.</p> linkerd/releases.yaml<pre><code>---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: linkerd\nspec:\ninterval: 10m\nchart:\nspec:\nchart: linkerd2\nreconcileStrategy: ChartVersion\nsourceRef:\nkind: HelmRepository\nname: linkerd\ninstall:\ncrds: Create\nupgrade:\ncrds: CreateReplace\nvaluesFrom:\n- kind: Secret\nname: linkerd-certs\nvaluesKey: ca.crt\ntargetPath: identityTrustAnchorsPEM\n- kind: Secret\nname: linkerd-certs\nvaluesKey: issuer.crt\ntargetPath: identity.issuer.tls.crtPEM\n- kind: Secret\nname: linkerd-certs\nvaluesKey: issuer.key\ntargetPath: identity.issuer.tls.keyPEM\nvalues:\ninstallNamespace: false\nidentity:\nissuer:\ncrtExpiry: \"2023-07-18T20:00:00Z\" # Change this to match generated certificate expiry date\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: linkerd-viz\nspec:\ninterval: 10m\ndependsOn:\n- name: linkerd\nchart:\nspec:\nchart: linkerd-viz\nreconcileStrategy: ChartVersion\nsourceRef:\nkind: HelmRepository\nname: linkerd\n</code></pre> <p>Next, add the following manifests. The first file instructs Kustomize to patch any <code>Secrets</code> that are referenced in <code>HelmRelease</code> manifests. The second file is a <code>Kustomization</code> that references all the other <code>linkerd</code> resource files.</p> Expand to see the Linkerd Kustomization manifests linkerd/kustomizeconfig.yaml<pre><code>nameReference:\n- kind: Secret\nversion: v1\nfieldSpecs:\n- path: spec/valuesFrom/name\nkind: HelmRelease\n</code></pre> linkerd/kustomization.yaml<pre><code>---\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: linkerd\nconfigurations:\n- kustomizeconfig.yaml\nresources:\n- namespace.yaml\n- source.yaml\n- releases.yaml\nsecretGenerator:\n- name: linkerd-certs\nfiles:\n- ca.crt\n- issuer.crt\n- issuer.key\n</code></pre> <p>Note: The <code>secretGenerator</code> generates Secrets from the files you've just created.</p> <p>At this point the <code>linkerd</code> directory in your cluster repository should look like this:</p> <pre><code>&gt; tree linkerd\nlinkerd\n\u251c\u2500\u2500 ca.crt\n\u251c\u2500\u2500 issuer.crt\n\u251c\u2500\u2500 issuer.key\n\u251c\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 kustomizeconfig.yaml\n\u251c\u2500\u2500 namespace.yaml\n\u251c\u2500\u2500 releases.yaml\n\u2514\u2500\u2500 source.yaml\n</code></pre> <p>Once Flux reconciles this directory to the cluster, Linkerd should be installed.</p> <p>Before proceeding to the next step, check that all the Linkerd pods have started successfully:</p> <pre><code>&gt; kubectl get pods -n linkerd \nNAME                                      READY   STATUS    RESTARTS   AGE\nlinkerd-destination-66d5668b-4mw49        4/4     Running   0          10m\nlinkerd-identity-6b4658c74b-6nc97         2/2     Running   0          10m\nlinkerd-proxy-injector-6b76789cb4-8vqj4   2/2     Running   0          10m\n\n&gt; kubectl get pods -n linkerd-viz \nNAME                            READY   STATUS    RESTARTS   AGE\ngrafana-db56d7cb4-xlnn4         2/2     Running   0          10m\nmetrics-api-595c7b564-724ps     2/2     Running   0          10m\nprometheus-5d4dffff55-8fscd     2/2     Running   0          10m\ntap-6dcb89d487-5ns8n            2/2     Running   0          10m\ntap-injector-54895654bb-9xn7k   2/2     Running   0          10m\nweb-6b6f65dbc7-wltdg            2/2     Running   0          10m\n</code></pre> <p>Note</p> <p>Any new directories that you add to the cluster repository while following this guide must  be included in a path that Flux reconciles.</p>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#installing-flagger-using-flux","title":"Installing Flagger Using Flux","text":"<p>To install Flagger, you'll use a Kustomization file that will define the installation order and provide a default namespace for the installed resources.</p> <p>Create a new <code>flagger</code> directory. Make sure to locate it under a repository path that Flux reconciles. </p> <p>Now add under this directory the three resource manifests for Flagger: - A <code>Namespace</code> resource to control where the components are installed - A <code>HelmRepository</code> resource to make the Flagger Helm repo available on the     cluster - A <code>HelmRelease</code> resource to install the latest version of Flagger and the load     tester app (which generates synthetic traffic during the     analysis phase), from that <code>HelmRepository</code></p> Expand to see the three Flagger resource manifests flagger/namespace.yaml<pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\nname: flagger\n</code></pre> flagger/source.yaml<pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\nname: flagger\nspec:\ninterval: 1h\nurl: https://flagger.app\n</code></pre> flagger/releases.yaml<pre><code>---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: flagger\nspec:\nreleaseName: flagger\ninstall:\ncrds: Create\nupgrade:\ncrds: CreateReplace\ninterval: 10m\nchart:\nspec:\nchart: flagger\nreconcileStrategy: ChartVersion\nsourceRef:\nkind: HelmRepository\nname: flagger\nvalues:\nmetricsServer: http://prometheus.linkerd-viz:9090\nmeshProvider: linkerd\n---\napiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\nname: loadtester\nspec:\ninterval: 10m\nchart:\nspec:\nchart: loadtester\nreconcileStrategy: ChartVersion\nsourceRef:\nkind: HelmRepository\nname: flagger\n</code></pre> <p>Now add the following Kustomization file. It references all of the previous files that you've added:</p> Expand to see the Flagger Kustomization manifest flagger/kustomization.yaml<pre><code>---\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: flagger\nresources:\n- namespace.yaml\n- source.yaml\n- releases.yaml\n</code></pre> <p>The <code>flagger</code> directory in the cluster repository should look like this:</p> <pre><code>&gt; tree flagger\nflagger\n\u251c\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 namespace.yaml\n\u251c\u2500\u2500 releases.yaml\n\u2514\u2500\u2500 source.yaml\n</code></pre> <p>Once Flux reconciles this directory to the cluster, Flagger and the load tester app should be installed.</p> <p>Before proceeding to the next step, check that all of your Flagger pods have started successfully:</p> <pre><code>&gt; kubectl get pods -n flagger\nNAME                          READY   STATUS    RESTARTS   AGE\nflagger-7d456d4fc7-knf2g      1/1     Running   0          4m\nloadtester-855b4d77f6-scl6r   1/1     Running   0          4m\n</code></pre>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#custom-resources-generated-by-flagger","title":"Custom Resources Generated by Flagger","text":"<p>When Flagger is configured to integrate with a service mesh such as Linkerd or Istio for the rollout, this ClusterRole needs to be extended so that it can read the additional service mesh resources that Flagger generates. To display service mesh- or ingress-related resources, we require <code>spec.provider</code> to be set in each canary resource. </p> <p>The following table provides a list of all the custom resources that Flagger generates grouped by provider:</p> Provider API Group Resource AppMesh appmesh.k8s.aws virtualnode appmesh.k8s.aws virtualrouter appmesh.k8s.aws virtualservice Linkerd split.smi-spec.io trafficsplit Istio networking.istio.io destinationrule networking.istio.io virtualservice Contour projectcontour.io httpproxy Gloo gateway.solo.io routetable gloo.solo.io upstream Nginx networking.k8s.io ingress Skipper networking.k8s.io ingress Traefik traefik.containo.us traefikservice Open Service Mesh split.smi-spec.io trafficsplit Kuma kuma.io trafficroute GatewayAPI gateway.networking.k8s.io httproute <p>For example, the following manifest shows how <code>gitops-canaries-reader</code> has been extended to allow the user for viewing TrafficSplit resources when Linkerd is used:</p> Expand to see example canary reader RBAC gitops-canaries-reader.yaml<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: gitops-canaries-reader\nrules:\n- apiGroups:\n- flagger.app\nresources:\n- canaries\n- metrictemplates\nverbs:\n- get\n- list\n- apiGroups:\n- \"\"\nresources:\n- events\nverbs:\n- get\n- watch\n- list\n# Additional permissions for Linkerd resources are added below\n- apiGroups:\n- split.smi-spec.io\nresources:\n- trafficsplits\nverbs:\n- get\n- list\n</code></pre>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#setting-up-remote-cluster-permissions","title":"Setting up Remote Cluster Permissions","text":"<p>In order to view canaries in a remote cluster from the management cluster, you need to consider the following: - The service account used to access the remote cluster needs to be able to list namespaces and custom resource definitions in the given cluster. It additionally needs to be able to impersonate users and groups. - The user or group that logs in to the management cluster, needs appropriate permissions to certain resources of the remote cluster.</p> <p>For example, applying the following manifest on remote clusters, ensures that the <code>wego-admin</code> user will be able to view canary information from within the Weave GitOps Enterprise UI on the management cluster:</p> Expand to see example of remote cluster canary reader remote-cluster-service-user-rbac.yaml<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: user-groups-impersonator\nrules:\n- apiGroups: [\"\"]\nresources: [\"users\", \"groups\"]\nverbs: [\"impersonate\"]\n- apiGroups: [\"\"]\nresources: [\"namespaces\"]\nverbs: [\"get\", \"list\"]\n- apiGroups: [\"apiextensions.k8s.io\"]\nresources: [\"customresourcedefinitions\"]\nverbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: impersonate-user-groups\nsubjects:\n- kind: ServiceAccount\nname: remote-cluster-01  # Service account created in remote cluster\nnamespace: default\nroleRef:\nkind: ClusterRole\nname: user-groups-impersonator\napiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: canary-reader\nrules:\n- apiGroups: [\"\"]\nresources: [ \"events\", \"services\" ]\nverbs: [ \"get\", \"list\", \"watch\" ]\n- apiGroups: [ \"apps\" ]\nresources: [ \"*\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [ \"autoscaling\" ]\nresources: [ \"*\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [ \"flagger.app\" ]\nresources: [ \"canaries\", \"metrictemplates\"]\nverbs: [ \"get\", \"list\", \"watch\" ]\n- apiGroups: [ \"helm.toolkit.fluxcd.io\" ]\nresources: [ \"helmreleases\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [ \"kustomize.toolkit.fluxcd.io\" ]\nresources: [ \"kustomizations\" ]\nverbs: [ \"get\", \"list\" ]\n- apiGroups: [ \"source.toolkit.fluxcd.io\" ]\nresources: [ \"buckets\", \"helmcharts\", \"gitrepositories\", \"helmrepositories\", \"ocirepositories\" ]\nverbs: [ \"get\", \"list\" ]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: read-canaries\nsubjects:\n- kind: User\nname: wego-admin    # User logged in management cluster, impersonated via service account\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: ClusterRole\nname: canary-reader\napiGroup: rbac.authorization.k8s.io\n</code></pre> <p>You may need to add more users/groups to the <code>read-canaries</code> ClusterRoleBinding to ensure additional users can view canary information from within the Weave GitOps Enterprise UI.</p>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#deploy-a-canary-release","title":"Deploy a Canary Release","text":"<p>To demonstrate the progressive rollout of an application, we'll use a tiny sample web app called podinfo and configure a canary release strategy. </p> <p>In our example, Flagger will scale up a new version of podinfo (the canary) alongside the existing version (the primary). It will gradually increase traffic to the new version in increments of 5%, up to a maximum of 50%. Flagger will continuously monitor the new version for an acceptable request response rate and average request duration. Based on this analysis, Flagger will either update the primary to the new version or abandon the promotion, then scale the canary back down to zero.</p> <p>Create a new <code>test</code> directory and add these three canary resource manifests under it: - A <code>Namespace</code> resource to control where the components are installed - A <code>Deployment</code> and <code>HorizontalPodAutoscaler</code> for the <code>podinfo</code> application - A <code>Canary</code> resource which references the <code>Deployment</code> and <code>HorizontalPodAutoscaler</code> resources</p> <p>We don't need to define a service resource. This is specified within the canary definition and created by Flagger.</p> Expand to see the three canary resource manifests test/namespace.yaml<pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\nname: test\nannotations:\nlinkerd.io/inject: enabled\n</code></pre> test/deployment.yaml<pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: podinfo\nlabels:\napp: podinfo\nspec:\nminReadySeconds: 5\nrevisionHistoryLimit: 5\nprogressDeadlineSeconds: 60\nstrategy:\nrollingUpdate:\nmaxUnavailable: 1\ntype: RollingUpdate\nselector:\nmatchLabels:\napp: podinfo\ntemplate:\nmetadata:\nannotations:\nprometheus.io/scrape: \"true\"\nprometheus.io/port: \"9797\"\nlabels:\napp: podinfo\nspec:\ncontainers:\n- name: podinfod\nimage: ghcr.io/stefanprodan/podinfo:6.1.8\nimagePullPolicy: IfNotPresent\nports:\n- name: http\ncontainerPort: 9898\nprotocol: TCP\n- name: http-metrics\ncontainerPort: 9797\nprotocol: TCP\n- name: grpc\ncontainerPort: 9999\nprotocol: TCP\ncommand:\n- ./podinfo\n- --port=9898\n- --port-metrics=9797\n- --grpc-port=9999\n- --grpc-service-name=podinfo\n- --level=info\n- --random-delay=false\n- --random-error=false\nenv:\n- name: PODINFO_UI_COLOR\nvalue: \"#34577c\"\nlivenessProbe:\nexec:\ncommand:\n- podcli\n- check\n- http\n- localhost:9898/healthz\ninitialDelaySeconds: 5\ntimeoutSeconds: 5\nreadinessProbe:\nexec:\ncommand:\n- podcli\n- check\n- http\n- localhost:9898/readyz\ninitialDelaySeconds: 5\ntimeoutSeconds: 5\nresources:\nlimits:\ncpu: 2000m\nmemory: 512Mi\nrequests:\ncpu: 100m\nmemory: 64Mi\n\n---\napiVersion: autoscaling/v2beta2\nkind: HorizontalPodAutoscaler\nmetadata:\nname: podinfo\nspec:\nscaleTargetRef:\napiVersion: apps/v1\nkind: Deployment\nname: podinfo\nminReplicas: 2\nmaxReplicas: 4\nmetrics:\n- type: Resource\nresource:\nname: cpu\ntarget:\ntype: Utilization\n# scale up if usage is above\n# 99% of the requested CPU (100m)\naverageUtilization: 99\n</code></pre> test/canary.yaml<pre><code>---\napiVersion: flagger.app/v1beta1\nkind: Canary\nmetadata:\nname: podinfo\nspec:\n# deployment reference\ntargetRef:\napiVersion: apps/v1\nkind: Deployment\nname: podinfo\n# HPA reference (optional)\nautoscalerRef:\napiVersion: autoscaling/v2beta2\nkind: HorizontalPodAutoscaler\nname: podinfo\n# the maximum time in seconds for the canary deployment\n# to make progress before it is rollback (default 600s)\nprogressDeadlineSeconds: 60\nservice:\n# ClusterIP port number\nport: 9898\n# container port number or name (optional)\ntargetPort: 9898\nanalysis:\n# schedule interval (default 60s)\ninterval: 30s\n# max number of failed metric checks before rollback\nthreshold: 5\n# max traffic percentage routed to canary\n# percentage (0-100)\nmaxWeight: 50\n# canary increment step\n# percentage (0-100)\nstepWeight: 5\n# Linkerd Prometheus checks\nmetrics:\n- name: request-success-rate\n# minimum req success rate (non 5xx responses)\n# percentage (0-100)\nthresholdRange:\nmin: 99\ninterval: 1m\n- name: request-duration\n# maximum req duration P99\n# milliseconds\nthresholdRange:\nmax: 500\ninterval: 30s\n# testing (optional)\nwebhooks:\n- name: acceptance-test\ntype: pre-rollout\nurl: http://loadtester.flagger/\ntimeout: 30s\nmetadata:\ntype: bash\ncmd: \"curl -sd 'test' http://podinfo-canary.test:9898/token | grep token\"\n- name: load-test\ntype: rollout\nurl: http://loadtester.flagger/\nmetadata:\ncmd: \"hey -z 2m -q 10 -c 2 http://podinfo-canary.test:9898/\"\n</code></pre> <p>Add a Kustomization file to apply all resources to the <code>test</code> namespace:</p> Expand to see the Canary Kustomization manifest test/kustomization.yaml<pre><code>---\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: test\nresources:\n- namespace.yaml\n- deployment.yaml\n- canary.yaml\n</code></pre> <p>At this point, the <code>test</code> directory in the cluster repository should look like this:</p> <pre><code>&gt; tree test\ntest\n\u251c\u2500\u2500 canary.yaml\n\u251c\u2500\u2500 deployment.yaml\n\u251c\u2500\u2500 kustomization.yaml\n\u2514\u2500\u2500 namespace.yaml\n</code></pre> <p>After a short time, the status of the canary object should be set to <code>Initialized</code>:</p> <p></p> <pre><code>&gt; kubectl get canary podinfo -n test\nNAME      STATUS        WEIGHT   LASTTRANSITIONTIME\npodinfo   Initialized   0        2022-07-22T12:37:58Z\n</code></pre> <p>Trigger a new rollout by bumping the version of <code>podinfo</code>:</p> <pre><code>&gt; kubectl set image deployment/podinfo podinfod=ghcr.io/stefanprodan/podinfo:6.0.1 -n test\n</code></pre> <p>During the progressive rollout, the canary object reports on its current status:</p> <p></p> <pre><code>&gt; kubectl get canary podinfo -n test\nNAME      STATUS        WEIGHT   LASTTRANSITIONTIME\npodinfo   Progressing   5       2022-07-22T12:41:57Z\n</code></pre> <p>After a short time the rollout is completed and the status of the canary object is set to <code>Succeeded</code>:</p> <p></p> <pre><code>&gt; kubectl get canary podinfo -n test\nNAME      STATUS      WEIGHT   LASTTRANSITIONTIME\npodinfo   Succeeded   0        2022-07-22T12:47:58Z\n</code></pre>"},{"location":"progressive-delivery/progressive-delivery-flagger-install/#summary","title":"Summary","text":"<p>Congratulations, you have now completed a progressive delivery rollout with Flagger and Linkerd! </p> <p>Next steps: - Explore more of what Flagger offers - Configure manual approvals for progressive delivery deployments</p>"},{"location":"references/helm-reference/","title":"Helm chart reference","text":"<p>This is a reference of all the configurable values in Weave GitOps's Helm chart. This is intended for customizing your installation after you've gone through the getting started guide.</p> <p>This reference was generated for the chart version 4.0.34 which installs weave gitops v0.36.0.</p>"},{"location":"references/helm-reference/#values","title":"Values","text":"Key Type Default Description additionalArgs list <code>[]</code> Additional arguments to pass in to the gitops-server adminUser.create bool <code>false</code> Whether the local admin user should be created. If you use this make sure you add it to <code>rbac.impersonationResourceNames</code>. adminUser.createClusterRole bool <code>true</code> Specifies whether the clusterRole &amp; binding to the admin user should be created. Will be created only if <code>adminUser.create</code> is enabled. Without this, the adminUser will only be able to see resources in the target namespace. adminUser.createSecret bool <code>true</code> Whether we should create the secret for the local adminUser. Will be created only if <code>adminUser.create</code> is enabled. Without this, we'll still set up the roles and permissions, but the secret with username and password has to be provided separately. adminUser.passwordHash string <code>nil</code> Set the password for local admin user. Requires <code>adminUser.create</code> and <code>adminUser.createSecret</code> This needs to have been hashed using bcrypt. You can do this via our CLI with <code>gitops get bcrypt-hash</code>. adminUser.username string <code>\"gitops-test-user\"</code> Set username for local admin user, this should match the value in the secret <code>cluster-user-auth</code> which can be created with <code>adminUser.createSecret</code>. Requires <code>adminUser.create</code>. affinity object <code>{}</code> annotations object <code>{}</code> Annotations to add to the deployment envVars[0].name string <code>\"WEAVE_GITOPS_FEATURE_TENANCY\"</code> envVars[0].value string <code>\"true\"</code> envVars[1].name string <code>\"WEAVE_GITOPS_FEATURE_CLUSTER\"</code> envVars[1].value string <code>\"false\"</code> extraVolumeMounts list <code>[]</code> extraVolumes list <code>[]</code> fullnameOverride string <code>\"\"</code> image.pullPolicy string <code>\"IfNotPresent\"</code> image.repository string <code>\"ghcr.io/weaveworks/wego-app\"</code> image.tag string <code>\"v0.36.0\"</code> imagePullSecrets list <code>[]</code> ingress.annotations object <code>{}</code> ingress.className string <code>\"\"</code> ingress.enabled bool <code>false</code> ingress.hosts string <code>nil</code> ingress.tls list <code>[]</code> logLevel string <code>\"info\"</code> What log level to output. Valid levels are 'debug', 'info', 'warn' and 'error' metrics.enabled bool <code>false</code> Start the metrics exporter metrics.service.annotations object <code>{\"prometheus.io/path\":\"/metrics\",\"prometheus.io/port\":\"{{ .Values.metrics.service.port }}\",\"prometheus.io/scrape\":\"true\"}</code> Annotations to set on the service metrics.service.port int <code>2112</code> Port to start the metrics exporter on nameOverride string <code>\"\"</code> networkPolicy.create bool <code>true</code> Specifies whether default network policies should be created. nodeSelector object <code>{}</code> oidcSecret.create bool <code>false</code> podAnnotations object <code>{}</code> podLabels object <code>{}</code> podSecurityContext object <code>{}</code> rbac.additionalRules list <code>[]</code> If non-empty, these additional rules will be appended to the RBAC role and the cluster role. for example, additionalRules: - apiGroups: [\"infra.contrib.fluxcd.io\"]   resources: [\"terraforms\"]   verbs: [ \"get\", \"list\", \"patch\" ] rbac.create bool <code>true</code> Specifies whether the clusterRole &amp; binding to the service account should be created rbac.impersonationResourceNames list <code>[]</code> If non-empty, this limits the resources that the service account can impersonate. This applies to both users and groups, e.g. <code>['user1@corporation.com', 'user2@corporation.com', 'operations']</code> rbac.impersonationResources list <code>[\"users\",\"groups\"]</code> Limit the type of principal that can be impersonated rbac.viewSecretsResourceNames list <code>[\"cluster-user-auth\",\"oidc-auth\"]</code> If non-empty, this limits the secrets that can be accessed by the service account to the specified ones, e.g. <code>['weave-gitops-enterprise-credentials']</code> replicaCount int <code>1</code> resources object <code>{}</code> securityContext.allowPrivilegeEscalation bool <code>false</code> securityContext.capabilities.drop[0] string <code>\"ALL\"</code> securityContext.readOnlyRootFilesystem bool <code>true</code> securityContext.runAsNonRoot bool <code>true</code> securityContext.runAsUser int <code>1000</code> securityContext.seccompProfile.type string <code>\"RuntimeDefault\"</code> serverTLS.enable bool <code>false</code> Enable TLS termination in gitops itself. If you enable this, you need to create a secret, and specify the secretName. Another option is to create an ingress. serverTLS.secretName string <code>\"my-secret-tls\"</code> Specify the tls secret name. This type of secrets have a key called <code>tls.crt</code> and <code>tls.key</code> containing their corresponding values in  base64 format. See https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets for more details and examples service.annotations object <code>{}</code> service.create bool <code>true</code> service.port int <code>9001</code> service.type string <code>\"ClusterIP\"</code> serviceAccount.annotations object <code>{}</code> Annotations to add to the service account serviceAccount.create bool <code>true</code> Specifies whether a service account should be created serviceAccount.name string <code>\"\"</code> The name of the service account to use. If not set and create is true, a name is generated using the fullname template tolerations list <code>[]</code>"},{"location":"references/cli-reference/gitops/","title":"Gitops","text":""},{"location":"references/cli-reference/gitops/#gitops","title":"gitops","text":"<p>Weave GitOps</p>"},{"location":"references/cli-reference/gitops/#synopsis","title":"Synopsis","text":"<p>Command line utility for managing Kubernetes applications via GitOps.</p>"},{"location":"references/cli-reference/gitops/#examples","title":"Examples","text":"<pre><code>  # Get help for gitops create dashboard command\n  gitops create dashboard -h\n  gitops help create dashboard\n\n  # Get the version of gitops along with commit, branch, and flux version\n  gitops version\n\n  To learn more, you can find our documentation at https://docs.gitops.weave.works/\n</code></pre>"},{"location":"references/cli-reference/gitops/#options","title":"Options","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n  -h, --help                                       help for gitops\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops check    - Validates flux compatibility</li> <li>gitops completion  - Generate the autocompletion script for the specified shell</li> <li>gitops create  - Creates a resource</li> <li>gitops delete  - Delete a resource</li> <li>gitops get    - Display one or many Weave GitOps resources</li> <li>gitops logs  - Get logs for a resource</li> <li>gitops replan  - Replan a resource</li> <li>gitops resume  - Resume a resource</li> <li>gitops set    - Sets one or many Weave GitOps CLI configs or resources</li> <li>gitops suspend    - Suspend a resource</li> <li>gitops version    - Display gitops version</li> </ul>"},{"location":"references/cli-reference/gitops/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_check/","title":"Gitops check","text":""},{"location":"references/cli-reference/gitops_check/#gitops-check","title":"gitops check","text":"<p>Validates flux compatibility</p> <pre><code>gitops check [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_check/#examples","title":"Examples","text":"<pre><code># Validate flux and kubernetes compatibility\ngitops check\n</code></pre>"},{"location":"references/cli-reference/gitops_check/#options","title":"Options","text":"<pre><code>  -h, --help   help for check\n</code></pre>"},{"location":"references/cli-reference/gitops_check/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_check/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> </ul>"},{"location":"references/cli-reference/gitops_check/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_completion/","title":"Gitops completion","text":""},{"location":"references/cli-reference/gitops_completion/#gitops-completion","title":"gitops completion","text":"<p>Generate the autocompletion script for the specified shell</p>"},{"location":"references/cli-reference/gitops_completion/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for gitops for the specified shell. See each sub-command's help for details on how to use the generated script.</p>"},{"location":"references/cli-reference/gitops_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"references/cli-reference/gitops_completion/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_completion/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops completion bash    - Generate the autocompletion script for bash</li> <li>gitops completion fish    - Generate the autocompletion script for fish</li> <li>gitops completion powershell    - Generate the autocompletion script for powershell</li> <li>gitops completion zsh  - Generate the autocompletion script for zsh</li> </ul>"},{"location":"references/cli-reference/gitops_completion/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_completion_bash/","title":"Gitops completion bash","text":""},{"location":"references/cli-reference/gitops_completion_bash/#gitops-completion-bash","title":"gitops completion bash","text":"<p>Generate the autocompletion script for bash</p>"},{"location":"references/cli-reference/gitops_completion_bash/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the bash shell.</p> <p>This script depends on the 'bash-completion' package. If it is not installed already, you can install it via your OS's package manager.</p> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(gitops completion bash)\n</code></pre> <p>To load completions for every new session, execute once:</p>"},{"location":"references/cli-reference/gitops_completion_bash/#linux","title":"Linux:","text":"<pre><code>gitops completion bash &gt; /etc/bash_completion.d/gitops\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_bash/#macos","title":"macOS:","text":"<pre><code>gitops completion bash &gt; $(brew --prefix)/etc/bash_completion.d/gitops\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>gitops completion bash\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_bash/#options","title":"Options","text":"<pre><code>  -h, --help              help for bash\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_bash/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_bash/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"references/cli-reference/gitops_completion_bash/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_completion_fish/","title":"Gitops completion fish","text":""},{"location":"references/cli-reference/gitops_completion_fish/#gitops-completion-fish","title":"gitops completion fish","text":"<p>Generate the autocompletion script for fish</p>"},{"location":"references/cli-reference/gitops_completion_fish/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the fish shell.</p> <p>To load completions in your current shell session:</p> <pre><code>gitops completion fish | source\n</code></pre> <p>To load completions for every new session, execute once:</p> <pre><code>gitops completion fish &gt; ~/.config/fish/completions/gitops.fish\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>gitops completion fish [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_fish/#options","title":"Options","text":"<pre><code>  -h, --help              help for fish\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_fish/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_fish/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"references/cli-reference/gitops_completion_fish/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_completion_powershell/","title":"Gitops completion powershell","text":""},{"location":"references/cli-reference/gitops_completion_powershell/#gitops-completion-powershell","title":"gitops completion powershell","text":"<p>Generate the autocompletion script for powershell</p>"},{"location":"references/cli-reference/gitops_completion_powershell/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for powershell.</p> <p>To load completions in your current shell session:</p> <pre><code>gitops completion powershell | Out-String | Invoke-Expression\n</code></pre> <p>To load completions for every new session, add the output of the above command to your powershell profile.</p> <pre><code>gitops completion powershell [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_powershell/#options","title":"Options","text":"<pre><code>  -h, --help              help for powershell\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_powershell/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_powershell/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"references/cli-reference/gitops_completion_powershell/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_completion_zsh/","title":"Gitops completion zsh","text":""},{"location":"references/cli-reference/gitops_completion_zsh/#gitops-completion-zsh","title":"gitops completion zsh","text":"<p>Generate the autocompletion script for zsh</p>"},{"location":"references/cli-reference/gitops_completion_zsh/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the zsh shell.</p> <p>If shell completion is not already enabled in your environment you will need to enable it.  You can execute the following once:</p> <pre><code>echo \"autoload -U compinit; compinit\" &gt;&gt; ~/.zshrc\n</code></pre> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(gitops completion zsh)\n</code></pre> <p>To load completions for every new session, execute once:</p>"},{"location":"references/cli-reference/gitops_completion_zsh/#linux","title":"Linux:","text":"<pre><code>gitops completion zsh &gt; \"${fpath[1]}/_gitops\"\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_zsh/#macos","title":"macOS:","text":"<pre><code>gitops completion zsh &gt; $(brew --prefix)/share/zsh/site-functions/_gitops\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>gitops completion zsh [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_zsh/#options","title":"Options","text":"<pre><code>  -h, --help              help for zsh\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_zsh/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_completion_zsh/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"references/cli-reference/gitops_completion_zsh/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_create/","title":"Gitops create","text":""},{"location":"references/cli-reference/gitops_create/#gitops-create","title":"gitops create","text":"<p>Creates a resource</p>"},{"location":"references/cli-reference/gitops_create/#examples","title":"Examples","text":"<pre><code># Create a HelmRepository and HelmRelease to deploy Weave GitOps\ngitops create dashboard ww-gitops \\\n  --password=$PASSWORD \\\n  --export &gt; ./clusters/my-cluster/weave-gitops-dashboard.yaml\n\n# Create a Terraform object\ngitops create terraform my-resource \\\n  -n my-namespace \\\n  --source GitRepository/my-project \\\n  --path ./terraform \\\n  --interval 1m \\\n  --export &gt; ./clusters/my-cluster/infra/terraform-my-resource.yaml\n</code></pre>"},{"location":"references/cli-reference/gitops_create/#options","title":"Options","text":"<pre><code>      --export             Export in YAML format to stdout.\n  -h, --help               help for create\n      --timeout duration   The timeout for operations during resource creation. (default 3m0s)\n</code></pre>"},{"location":"references/cli-reference/gitops_create/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_create/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops create dashboard  - Create a HelmRepository and HelmRelease to deploy Weave GitOps</li> <li>gitops create terraform  - Create a Terraform object</li> </ul>"},{"location":"references/cli-reference/gitops_create/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_create_dashboard/","title":"Gitops create dashboard","text":""},{"location":"references/cli-reference/gitops_create_dashboard/#gitops-create-dashboard","title":"gitops create dashboard","text":"<p>Create a HelmRepository and HelmRelease to deploy Weave GitOps</p>"},{"location":"references/cli-reference/gitops_create_dashboard/#synopsis","title":"Synopsis","text":"<p>Create a HelmRepository and HelmRelease to deploy Weave GitOps</p> <pre><code>gitops create dashboard [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_create_dashboard/#examples","title":"Examples","text":"<pre><code># Create a HelmRepository and HelmRelease to deploy Weave GitOps\ngitops create dashboard ww-gitops \\\n  --password=$PASSWORD \\\n  --export &gt; ./clusters/my-cluster/weave-gitops-dashboard.yaml\n</code></pre>"},{"location":"references/cli-reference/gitops_create_dashboard/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for dashboard\n      --password string       The password of the dashboard admin user.\n      --username string       The username of the dashboard admin user. (default \"admin\")\n      --values strings        Local path to values.yaml files for HelmRelease, also accepts comma-separated values.\n</code></pre>"},{"location":"references/cli-reference/gitops_create_dashboard/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --export                                     Export in YAML format to stdout.\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n      --timeout duration                           The timeout for operations during resource creation. (default 3m0s)\n</code></pre>"},{"location":"references/cli-reference/gitops_create_dashboard/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops create  - Creates a resource</li> </ul>"},{"location":"references/cli-reference/gitops_create_terraform/","title":"Gitops create terraform","text":""},{"location":"references/cli-reference/gitops_create_terraform/#gitops-create-terraform","title":"gitops create terraform","text":"<p>Create a Terraform object</p>"},{"location":"references/cli-reference/gitops_create_terraform/#synopsis","title":"Synopsis","text":"<p>Create a Terraform object</p> <pre><code>gitops create terraform [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_create_terraform/#examples","title":"Examples","text":"<pre><code># Create a Terraform resource in the default namespace\ngitops create terraform -n default my-resource --source GitRepository/my-project --path ./terraform --interval 15m\n\n# Create and export a Terraform resource manifest to the standard output\ngitops create terraform -n default my-resource --source GitRepository/my-project --path ./terraform --interval 15m --export\n</code></pre>"},{"location":"references/cli-reference/gitops_create_terraform/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for terraform\n      --interval string       Interval at which the Terraform configuration should be applied\n      --path string           Path to the Terraform configuration\n      --source string         Source of the Terraform configuration\n</code></pre>"},{"location":"references/cli-reference/gitops_create_terraform/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --export                                     Export in YAML format to stdout.\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n      --timeout duration                           The timeout for operations during resource creation. (default 3m0s)\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_create_terraform/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops create  - Creates a resource</li> </ul>"},{"location":"references/cli-reference/gitops_create_terraform/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_delete/","title":"Gitops delete","text":""},{"location":"references/cli-reference/gitops_delete/#gitops-delete","title":"gitops delete","text":"<p>Delete a resource</p>"},{"location":"references/cli-reference/gitops_delete/#options","title":"Options","text":"<pre><code>  -h, --help   help for delete\n</code></pre>"},{"location":"references/cli-reference/gitops_delete/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_delete/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops delete terraform  - Delete a Terraform object</li> </ul>"},{"location":"references/cli-reference/gitops_delete/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_delete_terraform/","title":"Gitops delete terraform","text":""},{"location":"references/cli-reference/gitops_delete_terraform/#gitops-delete-terraform","title":"gitops delete terraform","text":"<p>Delete a Terraform object</p> <pre><code>gitops delete terraform [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_delete_terraform/#examples","title":"Examples","text":"<pre><code># Delete a Terraform resource in the default namespace\ngitops delete terraform -n default my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_delete_terraform/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for terraform\n</code></pre>"},{"location":"references/cli-reference/gitops_delete_terraform/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_delete_terraform/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops delete  - Delete a resource</li> </ul>"},{"location":"references/cli-reference/gitops_delete_terraform/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_get/","title":"Gitops get","text":""},{"location":"references/cli-reference/gitops_get/#gitops-get","title":"gitops get","text":"<p>Display one or many Weave GitOps resources</p>"},{"location":"references/cli-reference/gitops_get/#examples","title":"Examples","text":"<pre><code># Get the CLI configuration for Weave GitOps\ngitops get config\n\n# Generate a hashed secret\nPASSWORD=\"&lt;your password&gt;\"\necho -n $PASSWORD | gitops get bcrypt-hash\n</code></pre>"},{"location":"references/cli-reference/gitops_get/#options","title":"Options","text":"<pre><code>  -h, --help   help for get\n</code></pre>"},{"location":"references/cli-reference/gitops_get/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_get/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops get bcrypt-hash    - Generates a hashed secret</li> <li>gitops get config  - Prints out the CLI configuration for Weave GitOps</li> </ul>"},{"location":"references/cli-reference/gitops_get/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_get_bcrypt-hash/","title":"Gitops get bcrypt hash","text":""},{"location":"references/cli-reference/gitops_get_bcrypt-hash/#gitops-get-bcrypt-hash","title":"gitops get bcrypt-hash","text":"<p>Generates a hashed secret</p> <pre><code>gitops get bcrypt-hash [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_get_bcrypt-hash/#examples","title":"Examples","text":"<pre><code>PASSWORD=\"&lt;your password&gt;\"\necho -n $PASSWORD | gitops get bcrypt-hash\n</code></pre>"},{"location":"references/cli-reference/gitops_get_bcrypt-hash/#options","title":"Options","text":"<pre><code>  -h, --help   help for bcrypt-hash\n</code></pre>"},{"location":"references/cli-reference/gitops_get_bcrypt-hash/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_get_bcrypt-hash/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops get    - Display one or many Weave GitOps resources</li> </ul>"},{"location":"references/cli-reference/gitops_get_bcrypt-hash/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_get_config/","title":"Gitops get config","text":""},{"location":"references/cli-reference/gitops_get_config/#gitops-get-config","title":"gitops get config","text":"<p>Prints out the CLI configuration for Weave GitOps</p> <pre><code>gitops get config [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_get_config/#examples","title":"Examples","text":"<pre><code># Prints out the CLI configuration for Weave GitOps\ngitops get config\n</code></pre>"},{"location":"references/cli-reference/gitops_get_config/#options","title":"Options","text":"<pre><code>  -h, --help   help for config\n</code></pre>"},{"location":"references/cli-reference/gitops_get_config/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_get_config/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops get    - Display one or many Weave GitOps resources</li> </ul>"},{"location":"references/cli-reference/gitops_logs/","title":"Gitops logs","text":""},{"location":"references/cli-reference/gitops_logs/#gitops-logs","title":"gitops logs","text":"<p>Get logs for a resource</p>"},{"location":"references/cli-reference/gitops_logs/#options","title":"Options","text":"<pre><code>  -h, --help   help for logs\n</code></pre>"},{"location":"references/cli-reference/gitops_logs/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_logs/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops logs terraform  - Get the runner logs of a Terraform object</li> </ul>"},{"location":"references/cli-reference/gitops_logs/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_logs_terraform/","title":"Gitops logs terraform","text":""},{"location":"references/cli-reference/gitops_logs_terraform/#gitops-logs-terraform","title":"gitops logs terraform","text":"<p>Get the runner logs of a Terraform object</p> <pre><code>gitops logs terraform [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_logs_terraform/#examples","title":"Examples","text":"<pre><code># Get the runner logs of a Terraform object in the \"flux-system\" namespace\ngitops logs terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_logs_terraform/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for terraform\n</code></pre>"},{"location":"references/cli-reference/gitops_logs_terraform/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_logs_terraform/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops logs  - Get logs for a resource</li> </ul>"},{"location":"references/cli-reference/gitops_logs_terraform/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_replan/","title":"Gitops replan","text":""},{"location":"references/cli-reference/gitops_replan/#gitops-replan","title":"gitops replan","text":"<p>Replan a resource</p>"},{"location":"references/cli-reference/gitops_replan/#examples","title":"Examples","text":"<pre><code># Replan the Terraform plan of a Terraform object from the \"flux-system\" namespace\ngitops replan terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_replan/#options","title":"Options","text":"<pre><code>  -h, --help   help for replan\n</code></pre>"},{"location":"references/cli-reference/gitops_replan/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_replan/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops replan terraform  - Trigger replan for a Terraform object</li> </ul>"},{"location":"references/cli-reference/gitops_replan/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_replan_terraform/","title":"Gitops replan terraform","text":""},{"location":"references/cli-reference/gitops_replan_terraform/#gitops-replan-terraform","title":"gitops replan terraform","text":"<p>Trigger replan for a Terraform object</p> <pre><code>gitops replan terraform [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_replan_terraform/#examples","title":"Examples","text":"<pre><code># Replan the Terraform plan of a Terraform object from the \"flux-system\" namespace\ngitops replan terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_replan_terraform/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for terraform\n</code></pre>"},{"location":"references/cli-reference/gitops_replan_terraform/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_replan_terraform/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops replan  - Replan a resource</li> </ul>"},{"location":"references/cli-reference/gitops_replan_terraform/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_resume/","title":"Gitops resume","text":""},{"location":"references/cli-reference/gitops_resume/#gitops-resume","title":"gitops resume","text":"<p>Resume a resource</p>"},{"location":"references/cli-reference/gitops_resume/#examples","title":"Examples","text":"<pre><code># Suspend a Terraform object from the \"flux-system\" namespace\ngitops resume terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_resume/#options","title":"Options","text":"<pre><code>  -h, --help   help for resume\n</code></pre>"},{"location":"references/cli-reference/gitops_resume/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_resume/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops resume terraform  - Resume a Terraform object</li> </ul>"},{"location":"references/cli-reference/gitops_resume/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_resume_terraform/","title":"Gitops resume terraform","text":""},{"location":"references/cli-reference/gitops_resume_terraform/#gitops-resume-terraform","title":"gitops resume terraform","text":"<p>Resume a Terraform object</p> <pre><code>gitops resume terraform [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_resume_terraform/#examples","title":"Examples","text":"<pre><code># Resume a Terraform object in the \"flux-system\" namespace\ngitops resume terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_resume_terraform/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for terraform\n</code></pre>"},{"location":"references/cli-reference/gitops_resume_terraform/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_resume_terraform/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops resume  - Resume a resource</li> </ul>"},{"location":"references/cli-reference/gitops_resume_terraform/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_set/","title":"Gitops set","text":""},{"location":"references/cli-reference/gitops_set/#gitops-set","title":"gitops set","text":"<p>Sets one or many Weave GitOps CLI configs or resources</p>"},{"location":"references/cli-reference/gitops_set/#examples","title":"Examples","text":"<pre><code># Enables analytics in the current user's CLI configuration for Weave GitOps\ngitops set config analytics true\n</code></pre>"},{"location":"references/cli-reference/gitops_set/#options","title":"Options","text":"<pre><code>  -h, --help   help for set\n</code></pre>"},{"location":"references/cli-reference/gitops_set/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_set/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops set config  - Set the CLI configuration for Weave GitOps</li> </ul>"},{"location":"references/cli-reference/gitops_set/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_set_config/","title":"Gitops set config","text":""},{"location":"references/cli-reference/gitops_set_config/#gitops-set-config","title":"gitops set config","text":"<p>Set the CLI configuration for Weave GitOps</p> <pre><code>gitops set config [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_set_config/#examples","title":"Examples","text":"<pre><code># Enables analytics in the current user's CLI configuration for Weave GitOps\ngitops set config analytics true\n</code></pre>"},{"location":"references/cli-reference/gitops_set_config/#options","title":"Options","text":"<pre><code>  -h, --help   help for config\n</code></pre>"},{"location":"references/cli-reference/gitops_set_config/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_set_config/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops set    - Sets one or many Weave GitOps CLI configs or resources</li> </ul>"},{"location":"references/cli-reference/gitops_suspend/","title":"Gitops suspend","text":""},{"location":"references/cli-reference/gitops_suspend/#gitops-suspend","title":"gitops suspend","text":"<p>Suspend a resource</p>"},{"location":"references/cli-reference/gitops_suspend/#examples","title":"Examples","text":"<pre><code># Suspend a Terraform object in the \"flux-system\" namespace\ngitops resume terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend/#options","title":"Options","text":"<pre><code>  -h, --help   help for suspend\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> <li>gitops suspend terraform    - Suspend a Terraform object</li> </ul>"},{"location":"references/cli-reference/gitops_suspend/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_suspend_terraform/","title":"Gitops suspend terraform","text":""},{"location":"references/cli-reference/gitops_suspend_terraform/#gitops-suspend-terraform","title":"gitops suspend terraform","text":"<p>Suspend a Terraform object</p> <pre><code>gitops suspend terraform [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend_terraform/#examples","title":"Examples","text":"<pre><code># Suspend a Terraform object in the \"flux-system\" namespace\ngitops suspend terraform --namespace flux-system my-resource\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend_terraform/#options","title":"Options","text":"<pre><code>      --context string        The name of the kubeconfig context to use\n      --disable-compression   If true, opt-out of response compression for all requests to the server\n  -h, --help                  help for terraform\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend_terraform/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_suspend_terraform/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops suspend    - Suspend a resource</li> </ul>"},{"location":"references/cli-reference/gitops_suspend_terraform/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"references/cli-reference/gitops_version/","title":"Gitops version","text":""},{"location":"references/cli-reference/gitops_version/#gitops-version","title":"gitops version","text":"<p>Display gitops version</p> <pre><code>gitops version [flags]\n</code></pre>"},{"location":"references/cli-reference/gitops_version/#options","title":"Options","text":"<pre><code>  -h, --help   help for version\n</code></pre>"},{"location":"references/cli-reference/gitops_version/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -e, --endpoint WEAVE_GITOPS_ENTERPRISE_API_URL   The Weave GitOps Enterprise HTTP API endpoint can be set with WEAVE_GITOPS_ENTERPRISE_API_URL environment variable\n      --insecure-skip-tls-verify                   If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                          Paths to a kubeconfig. Only required if out-of-cluster.\n  -n, --namespace string                           The namespace scope for this operation (default \"flux-system\")\n  -p, --password WEAVE_GITOPS_PASSWORD             The Weave GitOps Enterprise password for authentication can be set with WEAVE_GITOPS_PASSWORD environment variable\n  -u, --username WEAVE_GITOPS_USERNAME             The Weave GitOps Enterprise username for authentication can be set with WEAVE_GITOPS_USERNAME environment variable\n</code></pre>"},{"location":"references/cli-reference/gitops_version/#see-also","title":"SEE ALSO","text":"<ul> <li>gitops    - Weave GitOps</li> </ul>"},{"location":"references/cli-reference/gitops_version/#auto-generated-by-spf13cobra-on-9-nov-2023","title":"Auto generated by spf13/cobra on 9-Nov-2023","text":""},{"location":"secrets/","title":"Overview ENTERPRISE","text":""},{"location":"secrets/#secrets-management","title":"Secrets Management","text":"<p>Secrets are sensitive information such as passwords, access keys, and other credentials that should not be exposed publicly. In cloud-native applications, secrets are often used to authenticate and authorize access to various resources, such as databases, APIs, and other services.</p> <p>In a GitOps environment, secrets are typically stored either encrypted in Git, or using Custom Resources that reference the secret in an external secret store. Secrets are then synced into the clusters and securely passed to the application containers or workloads.</p> <p>Effective secrets management in cloud-native applications and GitOps environments is critical for maintaining the security and compliance of the overall system. Best practices include regularly rotating secrets, using strong encryption and access controls, and implementing robust auditing and monitoring processes.</p>"},{"location":"secrets/#weave-gitops-secrets-management","title":"Weave Gitops Secrets Management","text":"<p>Weave GitOps Secrets Management is a set of features that makes it easier for teams to manage secrets in a GitOps environment across multiple clusers. These features provide an automated way to manage secrets effectively, and make it easier for different personas to work with secrets.</p> <p>For Developers, they can use Weave GitOps Secrets Management to securely create and track application secrets such as API keys, passwords, and other credentials. They can do that using Weave GitOps UI in a self-serve manner.</p> <p>For Operation Teams, they can use Weave GitOps Secrets Management to help set up secure and reliable flows for developers to create and consume secrets for their applications.</p> <p>Weave GitOps Secrets Management supports integrations with SOPS and External Secrets Operator (ESO) to provide a secure and automated way to manage secrets in a GitOps environment, while giving the option for customers to choose any of these secrets operators or working with both of them.</p> <p>For SOPS and ESO operators, Weave GitOps is providing different ways to do the following: * Setup Secrets Operators (SOPS | ESO) * Bootstrap Secrets into clusters * Manage Secrets through Weave GitOps UI</p> <p>In order to get started with WeaveGitOps Secrets Management, please follow this guide here.</p>"},{"location":"secrets/bootstrapping-secrets/","title":"Bootstrapping Secrets ENTERPRISE","text":"<p>When accessing protected resources there is a need for a client to authenticate before the access is granted and the resource is consumed. For authentication, a client presents credentials that are either created manually or available through infrastructure. A common scenario is to have a secrets store.</p> <p>Weave Gitops allows you to provision the secret management infrastructure as part of its capabilities. However, in order to provision, as any other application that has secrets, we need to create the secret needed for installing it. This is known as a chicken-egg scenario that get addressed by providing an initial secret. This secret we call it bootstrapping secret.</p> <p>Bootstrapping secrets comes in handy, not only while provisioning your secrets management solution, but also in any platform provisioning task where the existence of the secret is a prerequisite. Another common example could be provisioning platform capabilities via profiles that are stored in private repositories.</p> <p>Weave Gitops provides SecretSync as a solution to managing your bootstrapping secrets.</p>"},{"location":"secrets/bootstrapping-secrets/#secretsync","title":"SecretSync","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p><code>SecretSync</code> is a Kubernetes Custom Resource that provides semantics to sync Kuberentes Secrets from management cluster to leaf clusters.</p> <p>An example could be seen below:</p> <p><pre><code>apiVersion: capi.weave.works/v1alpha1\nkind: SecretSync\nmetadata:\nname: my-dev-secret-syncer\nnamespace: default\nspec:\nclusterSelector:\nmatchLabels:\nenvironment: dev\nsecretRef:\nname: my-dev-secret\ntargetNamespace: my-namespace\n</code></pre> Where you could find the following configuration sections:</p> <p>1) Select the secret to sync:</p> <pre><code>  secretRef:\nname: my-dev-secret\n</code></pre> <p>2) Specify the GitopsClusters that the secret will be synced to via labels:</p> <pre><code>  clusterSelector:\nmatchLabels:\nenvironment: dev\n</code></pre> <p><code>Secretsync</code> reconciles secrets on clusters: any cluster at a future time matching the label selector will have the secret reconciled too.</p> <p>More info about the CRD spec here</p>"},{"location":"secrets/bootstrapping-secrets/#working-with-secretsync","title":"Working with SecretSync","text":""},{"location":"secrets/bootstrapping-secrets/#pre-requisites","title":"Pre-requisites","text":"<ol> <li>You are using Weave Gitops Enterprise version &gt; v0.19.0</li> <li>You have a set of GitopsClusters representing the clusters that you want to sync the secret to. They have a set of labels to allow matching.</li> </ol> Expand to see example <pre><code>apiVersion: gitops.weave.works/v1alpha1\nkind: GitopsCluster\nmetadata:\nnamespace: flux-system\nlabels:\nenvironment: dev\n</code></pre> <ol> <li>You have created a secret that you want to sync from the management cluster.</li> </ol> Expand to see example <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: my-dev-secret\nnamespace: flux-system\ntype: Opaque\n</code></pre> <p>Info</p> <p>Some restriction apply to the current version: - Resources should be in the same namespace - Leaf cluster nodes should be annotated with <code>node-role.kubernetes.io/control-plane</code></p>"},{"location":"secrets/bootstrapping-secrets/#syncing-secrets-via-secretsync","title":"Syncing secrets via SecretSync","text":"<ol> <li>Create SecretSync manifests that points to your secret. For example:</li> </ol> <pre><code>apiVersion: capi.weave.works/v1alpha1\nkind: SecretSync\nmetadata:\nname: my-dev-secret-syncer\nnamespace: default\nspec:\nclusterSelector:\nmatchLabels:\nenvironment: dev\nsecretRef:\nname: my-dev-secret\ntargetNamespace: my-namespace\n</code></pre> <ol> <li> <p>Check-in to your configuration repo within your management cluster</p> </li> <li> <p>Create a PR, review and merge</p> </li> <li> <p>See the progress</p> </li> </ol> <p>Once reconciled, the status section would show created secret resource version</p> <pre><code>status:\n  versions:\n    leaf-cluster-1: \"211496\"\n</code></pre> <ol> <li>See the secret created in your leaf cluster</li> </ol> <p>Your secret has been created in the target leaf cluster</p> <pre><code>\u279c  kubectl get secret -n default\nNAME               TYPE                                  DATA\nmy-dev-secret      Opaque                                1\n</code></pre>"},{"location":"secrets/getting-started/","title":"Getting started with secrets management ENTERPRISE","text":"<p>Warning</p> <p>This feature is in alpha and certain aspects will change We're very excited for people to use this feature. However, please note that changes in the API, behaviour and security will evolve. The feature is suitable to use in controlled testing environments.</p> <p>This guide shows you a basic experience to get started with Weave Gitops Secrets. It covers the scenario of setting up the capability in a test environment and how to use it for your applications.</p>"},{"location":"secrets/getting-started/#requirements","title":"Requirements","text":"<ul> <li>You have a test Weave Gitops Enterprise environment with Flux installed.</li> <li>You have a secret in AWS secrets manager.</li> </ul>"},{"location":"secrets/getting-started/#add-the-secrets-infra","title":"Add the secrets infra","text":"<p>In order to be able to manage external secrets stores and secrets, add <code>external-secrets</code> application from <code>weaveworks-charts</code> profiles repository.</p> <p></p> <p>Include via <code>values.yaml</code> the configuration to deploy the SecretStore connecting to AWS Secrets Manager.</p> <p><pre><code>  values:\nsecretStores:\nenabled: true\npath: ./clusters/bases/secrets\nsourceRef:\nkind: GitRepository\nname: flux-system\nnamespace: flux-system\n</code></pre> This example points to the path <code>clusters/bases/secrets</code> in our configuration repo where a kustomization exists</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n- aws-secrets-manager.yaml\n</code></pre> <p>With the AWS Secrets Manager secret store</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\nname: aws-secrets-manager\nnamespace: flux-system\nspec:\nprovider:\naws:\nauth:\nsecretRef:\naccessKeyIDSecretRef:\nkey: access-key\nname: awssm-secret\nsecretAccessKeySecretRef:\nkey: secret-access-key\nname: awssm-secret\nregion: eu-north-1\nservice: SecretsManager\n</code></pre> <p>Review and merge the PR and see it available in your cluster</p> <p></p>"},{"location":"secrets/getting-started/#create-the-secret","title":"Create the secret","text":"<p>Given you have a secret in AWS Secrets Manager for example <code>test/search/db</code>.</p> <p></p> <p>Create the External Secret manifest via Secrets UI to pull the secret from your store into your environment.</p> <p></p> <p>See it available in your cluster.</p> <p></p>"},{"location":"secrets/getting-started/#use-the-secret","title":"Use the secret","text":"<p>At this stage you have everything you need for your application to consume the secret. Add it to your application as usual.</p> Expand to see example <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nname: secret-dotfiles-pod\nspec:\nvolumes:\n- name: database-secrets\nsecret:\nsecretName: search-database\ncontainers:\n- name: dotfile-test-container\nimage: registry.k8s.io/busybox\ncommand:\n- ls\n- \"-l\"\n- \"/etc/database-secrets\"\nvolumeMounts:\n- name: database-secrets\nreadOnly: true\nmountPath: \"/etc/database-secrets\"\n</code></pre> <p>You could see the expected secret available</p> <pre><code>kubectl logs -f secret-dotfiles-pod\n\ntotal 0\nlrwxrwxrwx    1 root     root            15 Apr  5 17:26 password -&gt; ..data/password\n</code></pre>"},{"location":"secrets/getting-started/#next-steps","title":"Next steps?","text":"<ul> <li>For other setup scenarios using external secrets, see setup ESO</li> <li>For SOPS secrets, see setup SOPS</li> <li>To discover the UI capabilities to manage secrets, see here</li> </ul>"},{"location":"secrets/manage-secrets-ui/","title":"Manage Secrets UI ENTERPRISE","text":"<p>At Weave GitOps Enterprise (WGE), we support two approaches for creating and managing secrets: External Secrets Operator and Mozilla SOPS. In this guide, we will provide an overview of both approaches and explain how to use the UI to create and manage secrets.</p> <p>Clicking on the Secrets under the Platform section in the left hand menu will bring you to the secrets page where you can create external secrets, sops secrets, and view the external secrets list.</p>"},{"location":"secrets/manage-secrets-ui/#external-secrets","title":"External Secrets","text":""},{"location":"secrets/manage-secrets-ui/#prerequisites","title":"Prerequisites","text":"<p>Setup the External Secrets Operator by following this guide.</p>"},{"location":"secrets/manage-secrets-ui/#create-external-secret-cr","title":"Create External Secret CR","text":"<p>To create a new <code>ExternalSecret</code> CR, start by clicking on to the <code>Create External Secret</code> button to navigate to the creation page.</p> <p></p> <p></p> <p>Here, you will be prompted to enter the <code>External Secret Name</code> and the <code>Target K8s Secret Name</code>. Once you choose the <code>Target Cluster</code>, you will find a new list of all the <code>Secret Stores</code> on this cluster to choose from.</p> <p>It's important to note that the chosen <code>SecretStore</code> may be a cluster-scoped <code>SecretStore</code> ie: <code>ClusterSecretStore</code> or a namespace-scoped <code>SecretStore</code>.</p> <p>If you choose a namespace scoped <code>SecretStore</code>, the new secret will be created on the same namespace as the <code>SecretStore</code>.</p> <p></p> <p>If you choose a cluster-scoped <code>ClusterSecretStore</code>, the new secret will be created in a namespace of your choice.</p> <p></p> <p>Then you need to add the <code>SecretPath</code>, which is the path to the external secret within the secret store.</p>"},{"location":"secrets/manage-secrets-ui/#adding-secret-properties","title":"Adding Secret Properties","text":"<p>After you have chosen your desired <code>SecretStore</code> &amp; <code>SecretPath</code> the UI allows you to add secret properties in two differen scenarios:</p>"},{"location":"secrets/manage-secrets-ui/#1-adding-specific-properties","title":"1. Adding specific properties","text":"<p>The first scenario allows you to add specific property fields. Each added <code>property</code> also has an optional <code>SecretKey</code> field. Here's how to do it:</p> <p>In the <code>Properties</code> section, click the <code>Add</code> button to create a new property field.</p> <p></p> <p>Enter the name of the <code>property</code> you want to create. You can add as many properties as you need.</p> <p></p> <p>If you wish to specify a <code>SecretKey</code> for the property, enter it in the <code>SecretKey</code> field. If this field is left blank, the <code>property</code> name will be used as the <code>SecretKey</code>.</p> <p></p> <p>To remove a property, click the <code>Remove</code> sign next to the property you wish to delete.</p> <p>Remember, this option allows you to have fine-grained control over which properties are included in your <code>ExternalSecret</code>.</p>"},{"location":"secrets/manage-secrets-ui/#2-including-all-properties","title":"2. Including All Properties","text":"<p>The second scenario is to include all properties in your <code>ExternalSecret</code>. If the <code>Include all properties</code> checkbox is checked, all property inputs will be disabled and ignored, and all secrets including all keys under the specified <code>SecretPath</code> will be added. Here's how:</p> <p>Check the <code>Include all properties</code> checkbox. This will automatically disable the property input fields.</p> <p></p> <p>Using this option allows you to quickly create an <code>ExternalSecret</code> that includes all secrets under a specific <code>SecretPath</code>, without the need to specify each one individually.</p> <p>Warning</p> <p>Remember to use this option with caution. You may not need to expose all your secret properties to be on the cluster.</p> <p>This process allows you to easily create new <code>ExternalSecret</code> CRs without needing to manually create them through YAML files or command line tools.</p>"},{"location":"secrets/manage-secrets-ui/#list-external-secrets","title":"List External Secrets","text":"<p>The ExternalSecrets List section of the UI allows you to view all the external secrets that are currently stored in your Kubernetes clusters. This section provides an overview of each external secret, including its name, namespace, cluster, k8s-secret, secret-store and the age. From this page, you can also navigate to the details page to view more information about a specific secret.</p>"},{"location":"secrets/manage-secrets-ui/#external-secret-details","title":"External Secret Details","text":"<p>The details page displays the details of a specific external secret, including its name, namespace, data, and creation date. Below are the details that you can expect to see on this page:</p> <ul> <li>Status: This indicates the current status of the external secret, which can be \"Ready\" or \"Not Ready\" depending on whether the external secret has been successfully created and is ready for use.</li> <li>Last Updated: This shows the date and time when the external secret was last updated.</li> <li>External Secret: This is the name of the external secret that you are viewing.</li> <li>K8s Secret: This is the name of the Kubernetes secret that is associated with the external secret.</li> <li>Cluster: This indicates which cluster the external secret exists on.</li> <li>Secret Store: This shows the name of the secret store provider that is being used to store the external secret.</li> <li>Secret Store Type: This indicates the type of secret store that is being used to store the external secret. In this case, the type is \"AWS Secrets Manager\".</li> <li>Secret path: This is the path to the external secret within the secret store.</li> <li> <p>Version: This shows the version of the external secret, which may be blank if no version has been specified.</p> </li> <li> </li> </ul> <p>Based on the configuration of the external secret, this section will vary:</p> <ul> <li> <p>If the \"Include all properties\" option was selected during the creation of the external secret, this section will display the text \"All properties are included\". </p> </li> <li> <p>If specific properties were manually added during creation, this section will display a table with two columns: \"Property\" and \"SecretKey\". This table lists all the property and secret key pairs added to the external secret. </p> </li> </ul> <p>Understanding the information provided on the details page can help you to manage and troubleshoot your external secrets as needed.</p>"},{"location":"secrets/manage-secrets-ui/#properties","title":"Properties","text":""},{"location":"secrets/manage-secrets-ui/#understanding-events","title":"Understanding Events","text":"<p>The following events can be expected when using the UI to manage external secrets:</p> <ul> <li>Updated: This event indicates that an existing external secret has been successfully updated with new data.</li> <li>Not Ready: This event indicates that there was an issue with the secret store when trying to access or synchronize external secrets. This includes situations such as the secret store being unavailable or not ready to handle requests, or issues with authentication when trying to access the secret store.</li> </ul> <p>Understanding these events can help you to troubleshoot issues that may arise when managing external secrets using the UI. In particular, if you encounter a <code>Not Ready</code> event, you may need to check your secret store credentials and ensure that the secret store is operational before proceeding with any further actions.</p>"},{"location":"secrets/manage-secrets-ui/#sops","title":"SOPS","text":""},{"location":"secrets/manage-secrets-ui/#getting-started-with-sops","title":"Getting Started with SOPS","text":"<p>Creating a SOPS secret involves using the SOPS tool to encrypt a file containing sensitive information, such as credentials or API keys. This encrypted file can then be stored securely in version control or another location, with only authorized users able to decrypt it using their own private key. This adds an additional layer of security to sensitive data, reducing the risk of unauthorized access or accidental exposure.</p>"},{"location":"secrets/manage-secrets-ui/#prerequisites_1","title":"Prerequisites","text":"<p>For more information about how to generate OpenPGP/age keys and configure your cluster to work with Weave GitOps Enterprise secrets management follow this guide.</p>"},{"location":"secrets/manage-secrets-ui/#create-sops-secret","title":"Create SOPS Secret","text":"<p>To create a new SOPS secret, start by clicking on the <code>Create Sops Secret</code> button.</p> <p></p> <p>This will open the create form where you can specify the details of your new secret. First, choose the <code>Cluster</code> where you want to create the secret. Then, enter a <code>name</code> for your secret and select the <code>namespace</code> where it will be created.</p> <p></p> <p>Next, select the <code>encryption method</code> that you want to use - currently, only GPG/AGE encryption is supported. Finally, choose the <code>kustomization</code> that will be used by SOPS to decrypt the secret, as well as, having the public key info that will be used to encrypt the secret data. Afterwards, add your <code>key-value</code> pairs of your secrets. It's important to note that the <code>value</code> input will be encoded to base64.</p> <p>The generated secret should be something like below.</p> <p></p> <p>After approving the pull request, Flux will reconcile it to your cluster. To verify that the secret has been successfully created, you can use the following command to retrieve it as YAML:</p> <pre><code>kubectl get secret secretTest-default-sops-secret -n default -o yaml\n</code></pre> <p>which will give the following output:</p> <pre><code>apiVersion: v1\ndata:\nsecret-1: dmFsCg==\nkind: Secret\nmetadata:\nname: secretTest-default-sops-secret\nnamespace: default\ntype: Opaque\n</code></pre>"},{"location":"secrets/setup-eso/","title":"Setup ESO ENTERPRISE","text":"<p>Weave GitOps Enterprise now supports managing secrets using External Secrets Operator from the UI. External Secrets Operator is a Kubernetes operator that allows users to use secrets from external secrets management systems by reading their information using external APIs and injecting their values into Kubernetes secrets. To be able to use this functionality, users need to configure their External Secrets Operator and SecretStores using one of the guides below.</p>"},{"location":"secrets/setup-eso/#prerequisites","title":"Prerequisites","text":""},{"location":"secrets/setup-eso/#secretstores","title":"SecretStores","text":"<p>You should have your SecretStore CRs defined in a git repository. Those CRs will be installed to your cluster in the following steps and used by the creation UI.</p>"},{"location":"secrets/setup-eso/#eso-profile","title":"ESO Profile","text":"<p>The ESO profile is packaged with the weaveworks-charts. If you have the usual profiles setup, you will not need to do anything extra. This profile installs the ESO controller, all the required CRDs, and the SecretStore CRs defined in the previous step.</p>"},{"location":"secrets/setup-eso/#secrets","title":"Secrets","text":"<p>There are several Kubernetes Secrets that need to exist on your management cluster for the whole flow to work.</p> <p>If your SecretStores repository is private then you'll need a Secret, that contains the repo credentials, to access the repository. This is usually the Secret you created while bootstrapping Flux on the management cluster and is copied to your leaf cluster during creation.</p> <p>For each SecretStore CR, you'll need to add a Secret, that follows the format expected by this CR, to allow the operator to access the defined External Secret Store.</p> <p>Follow this guide for bootstrapping those secrets on leaf clusters.</p>"},{"location":"secrets/setup-eso/#installation-steps","title":"Installation Steps","text":""},{"location":"secrets/setup-eso/#install-eso-on-management-cluster-or-existing-leaf-cluster","title":"Install ESO on management cluster or existing leaf cluster","text":"<p>To install the ESO profile on an exisitng cluster, use <code>Add an application</code> from the <code>Applications</code> page and select <code>external-secrets</code> from <code>weaveworks-charts</code>. Check the Profile values section for more info about configuring the <code>values.yaml</code>.</p>"},{"location":"secrets/setup-eso/#install-eso-on-leaf-cluster","title":"Install ESO on leaf cluster","text":"<p>To bootstrap the ESO profile on a leaf cluster, select <code>external-secrets</code> from the profiles dropdown in the <code>Create Cluster</code> page. Check the Profile values section for more info about configuring the <code>values.yaml</code>.</p>"},{"location":"secrets/setup-eso/#profile-values","title":"Profile values","text":"<p>You should then configure the <code>values.yaml</code> to install the <code>SecretStores</code> on the cluster from a <code>GitRepository</code>. This is done by configuring the <code>secretStores</code> section.</p> Expand to see an example that creates a new git source from a specific tag <pre><code>secretStores:\nenabled: true\nurl: ssh://git@github.com/github-owner/repo-name   # url for the git repository that contains the SecretStores\ntag: v1.0.0\npath: ./    # could be a path to the secrets dir or a kustomization.yaml file for the SecretStore in the GitRepository\nsecretRef: my-pat   # the name of the Secret containing the repo credentials for private repositories\n</code></pre> Expand to see an example that uses an existing git source <pre><code>secretStores:\nenabled: true\nsourceRef: # Specify the name for an existing GitSource reference\nkind: GitRepository\nname: flux-system\nnamespace: flux-system\n</code></pre>"},{"location":"secrets/setup-sops/","title":"Setup SOPS","text":"<p>import CodeBlock from \"@theme/CodeBlock\";</p> <p>import SopsBootstrapJob from \"!!raw-loader!./assets/sops-bootstrap-job.yaml\"; import TemplateParams from \"!!raw-loader!./assets/template-params.yaml\"; import TemplateAnnotations from \"!!raw-loader!./assets/template-annotations.yaml\";</p>"},{"location":"secrets/setup-sops/#setup-sops-enterprise","title":"Setup SOPS ENTERPRISE","text":"<p>Weave GitOps Enterprise now supports managing secrets using SOPS, a tool that encrypts and decrypts secrets using various key management services, from the UI. To be able to use this functionality, users need to configure their private and public key-pairs using one of the guides below.</p>"},{"location":"secrets/setup-sops/#setup-sops-on-management-cluster-or-existing-leaf-cluster","title":"Setup SOPS on management cluster or existing leaf cluster","text":"<p>In this section, we will cover the prerequisites for using SOPS with Weave GitOps Enterprise, and how to configure SOPS for your existing Kubernetes cluster to work with GPG and age keys.</p> <p>For a more advanced setup for SOPS with flux, please refer to this guide.</p>"},{"location":"secrets/setup-sops/#encrypting-secrets-using-gpgopenpgp","title":"Encrypting secrets using GPG/OpenPGP","text":"<p>OpenPGP is a way of using SOPS to encrypt and decrypt secrets with Weave GitOps Enterprise.</p> <p>Here are the steps to generate an OpenPGP key and configure your cluster to work with Weave GitOps Enterprise secrets management.</p> <p>1- Generate a gpg key pairs</p> Expand for instructions <pre><code>export KEY_NAME=\"gpg-key\"\nexport KEY_COMMENT=\"gpg key\"\n\ngpg --batch --full-generate-key &lt;&lt;EOF\n%no-protection\nKey-Type: 1\nKey-Length: 4096\nSubkey-Type: 1\nSubkey-Length: 4096\nExpire-Date: 0\nName-Comment: ${KEY_COMMENT}\nName-Real: ${KEY_NAME}\nEOF\n</code></pre> <p>2- Export the key pairs fingerprint in the shell</p> <pre><code>gpg --list-secret-keys \"${KEY_NAME}\"\n\nsec   rsa4096 2020-09-06 [SC]\n710DC0DB6C1662F707095FC30233CB21E656A3CB\n\nexport KEY_FP=\"710DC0DB6C1662F707095FC30233CB21E656A3CB\"\n</code></pre> <p>3- Export the generated private key to a kubernetes secret <code>sops-gpg-private-key</code> which will be used by flux's kustomize-controller to decrypt the secrets using sops.</p> <pre><code>gpg --export-secret-keys --armor \"${KEY_FP}\" |\nkubectl create secret generic sops-gpg-private-key \\\n--namespace=flux-system \\\n--from-file=sops.asc=/dev/stdin\n</code></pre> <p>4- Export the generated public key to a kubernetes secret <code>sops-gpg-public-key</code> which will be used by Weave GitOps Enterprise to encrypt the secrets created from the UI.</p> <pre><code>gpg --export --armor \"${KEY_FP}\" |\nkubectl create secret generic sops-gpg-public-key \\\n--namespace=flux-system \\\n--from-file=sops.asc=/dev/stdin\n</code></pre> <p>Tip</p> <p>It's recommended to remove the secret from your machine</p> <pre><code>gpg --delete-secret-keys \"${KEY_FP}\"\n</code></pre> <p>5- Create a kustomization for reconciling the secrets on the cluster and set the <code>--decryption-secret</code> flag to the name of the private key created in step 3.</p> <pre><code>flux create kustomization gpg-secrets \\\n--source=secrets \\ # the git source to reconcile the secrets from\n--path=./secrets/gpg \\\n--prune=true \\\n--interval=10m \\\n--decryption-provider=sops \\\n--decryption-secret=sops-gpg-private-key\n</code></pre> <p>6- Annotate the kustomization object created in the previous step with the name and namespace of the public key created in step 4.</p> <pre><code>kubectl annotate kustomization gpg-secrets \\\nsops-public-key/name=sops-gpg-public-key \\\nsops-public-key/namespace=flux-system \\\n-n flux-system\n</code></pre> Expand to see the expected kustomization object <pre><code>apiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\nname: gpg-secrets\nnamespace: flux-system\nannotations:\nsops-public-key/name: sops-gpg-public-key\nsops-public-key/namespace: flux-system\nspec:\ninterval: 10m\nsourceRef:\nkind: GitRepository\nname: secrets\npath: ./secrets/gpg\ndecryption:\nprovider: sops\nsecretRef:\nname: sops-gpg-private-key\nprune: true\nvalidation: server\n</code></pre> <p>Note</p> <p>This is an essential step in order to allow other operators and developers to utilize WeaveGitOps UI to encrypt SOPS secrets using the public key secret in the cluster.</p>"},{"location":"secrets/setup-sops/#encrypting-secrets-using-age","title":"Encrypting secrets using age","text":"<p>age is a simple, modern and secure file encryption tool, that can be used to encrypt secrets using Weave GitOps Enterprise.</p> <p>Here are the steps to generate an age key and configure your cluster to work with Weave GitOps Enterprise secrets management.</p> <p>1- Generate an age key with age-keygen</p> <pre><code>age-keygen -o age.agekey\n\nPublic key: &lt;public key&gt;\n</code></pre> <p>2- Export the generated private key to a kubernetes secret <code>sops-age-private-key</code> which will be used by flux's kustomize-controller to decrypt the secrets using sops.</p> <pre><code>cat age.agekey |\nkubectl create secret generic sops-age-private-key \\\n--namespace=flux-system \\\n--from-file=age.agekey=/dev/stdin\n</code></pre> <p>4- Export the generated public key to a kubernetes secret <code>sops-age-public-key</code> which will be used by Weave GitOps Enterprise to encrypt the secrets created from the UI.</p> <pre><code>echo \"&lt;public key&gt;\" |\nkubectl create secret generic sops-age-public-key \\\n--namespace=flux-system \\\n--from-file=age.agekey=/dev/stdin\n</code></pre> <p>Tip</p> <p>It's recommended to remove the secret from your machine</p> <pre><code>rm -f age.ageKey\n</code></pre> <p>5- Create a kustomization for reconciling the secrets on the cluster and set the <code>--decryption-secret</code> flag to the name of the private key created in step 2.</p> <pre><code>flux create kustomization age-secrets \\\n--source=secrets \\ # the git source to reconcile the secrets from\n--path=./secrets/age \\\n--prune=true \\\n--interval=10m \\\n--decryption-provider=sops \\\n--decryption-secret=sops-age-private-key\n</code></pre> <p>6- Annotate the kustomization object created in the previous step with the name and namespace of the public key created in step 4.</p> <pre><code>kubectl annotate kustomization age-secrets \\\nsops-public-key/name=sops-age-public-key \\\nsops-public-key/namespace=flux-system \\\n-n flux-system\n</code></pre> Expand to see the expected kustomization object <pre><code>apiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\nname: age-secrets\nnamespace: flux-system\nannotations:\nsops-public-key/name: sops-age-public-key\nsops-public-key/namespace: flux-system\nspec:\ninterval: 10m\nsourceRef:\nkind: GitRepository\nname: secrets\npath: ./secrets/age\ndecryption:\nprovider: sops\nsecretRef:\nname: sops-age-private-key\nprune: true\nvalidation: server\n</code></pre> <p>Note</p> <p>This is an essential step in order to allow other operators and developers to utilize WeaveGitOps UI to encrypt SOPS secrets using the public key secret in the cluster.</p> <p>Tip</p> <p>In case of using OpenPGP and age in the same cluster, you need to make the kustomizations point to different directories. This is because flux's kustomize-controller expects that all the secrets in the kustomization's path are encrypted with the same key.</p>"},{"location":"secrets/setup-sops/#bootstrapping-sops-to-leaf-clusters","title":"Bootstrapping SOPS to leaf clusters","text":"<p>Bootstrapping SOPS to leaf clusters in WGE can be done by utilizing <code>ClusterBootstrapConfig</code> job to bootstrap Flux and SOPS. The job is a container which generates SOPS secrets key pair, creates a kubernetes secret with the private key, creates a kubernetes secret with the public key (to be used in self-serve flow) and the proper rbac for it. As well as an option to push the public key to the git repository via a PR (to be distributed).</p>"},{"location":"secrets/setup-sops/#prerequisites","title":"Prerequisites","text":""},{"location":"secrets/setup-sops/#clusterbootstrapconfig-job","title":"ClusterBootstrapConfig job","text":"<p>The following example is using GPG encryption to install SOPS and generate keys when bootstrapping leaf clusters. Create the following <code>ClusterBootstrapConfig</code> CR and push it to your fleet repo.</p> Expand to view  <p>&lt;CodeBlock title=\"clusters/management/capi/boostrap/sops-bootstrap-job.yaml\" className=\"language-yaml\"</p> <p>{SopsBootstrapJob} </p>"},{"location":"secrets/setup-sops/#cluster-template-updates","title":"Cluster template updates","text":"<p>In order to bootstrap SOPS to leaf clusters, we need some modifications to the cluster template to allow creating a Kustomization for reconciling the secrets on the cluster using SOPS and to run the <code>ClusterBootstrapConfig</code> job during cluster creation.</p> <p>The template metadata should have annotation, it will be used by WGE to create the Kustomization with the cluster files.</p> <pre><code>templates.weave.works/sops-enabled: \"true\"\n</code></pre> <p>The template should have the following parameters that are needed for the Kustomization</p> Expand to view  <p>&lt;CodeBlock title=\"clusters/management/capi/templates/template.yaml\" className=\"language-yaml\"</p> <p>{TemplateParams} </p> <p>The template should have the following annotations under <code>GitOpsCluster</code> to be used in the bootstrap job</p> Expand to view  <p>&lt;CodeBlock title=\"clusters/management/capi/templates/template.yaml\" className=\"language-yaml\"</p> <p>{TemplateAnnotations} </p>"},{"location":"secrets/setup-sops/#installation-steps","title":"Installation Steps","text":"<p>To bootstrap SOPS on a leaf cluster, create a new cluster using the SOPS template from the <code>Create Cluster</code> page and fill in the following SOPS-related values in the form:</p> <ul> <li><code>SOPS_KUSTOMIZATION_NAME</code>: This Kustomization will be used to decrypt SOPS secrets from this path <code>clusters/default/leaf-cluster/sops/</code> after reconciling on the cluster. example (<code>my-secrets</code>)</li> <li><code>SOPS_SECRET_REF</code>: The private key secret name that will be generated by SOPS in the bootstrap job. example (<code>sops-gpg</code>)</li> <li><code>SOPS_SECRET_REF_NAMESPACE</code>: The private key secret namespace this secret will be generated by SOPS in the bootstrap job. example (<code>flux-system</code>)</li> <li><code>SOPS_KEY_NAME</code>: SOPS key name. This will be used to generate SOPS keys. example (<code>test.yourdomain.com</code>)</li> <li><code>SOPS_KEY_COMMENT</code>: SOPS key comment. This will be used to generate SOPS keys. example (<code>sops secret comment</code>)</li> <li><code>SOPS_PUSH_TO_GIT</code>: Option to push the public key to the git repository. expected values (<code>true</code>, <code>false</code>)</li> </ul> <p></p>"},{"location":"secrets/setup-sops/#what-to-expect","title":"What to expect","text":"<ul> <li>A leaf cluster created with Flux &amp; SOPS bootstrapped</li> <li>A secret created on leaf cluster <code>sops-gpg</code> to decrypt secrets</li> <li>A secret created on leaf cluster <code>sops-gpg-pub</code> to encrypt secrets</li> <li>A Kustomization with <code>decryption</code> defined in it to <code>SOPS</code> location in the cluster repo location</li> <li>Added Role for the public key to be accessed through management cluster</li> <li>A PR is created to the cluster repo with the public key and SOPS creation rules (optional)</li> <li>Visit the Secrets Page and start managing your secrets via the UI</li> </ul>"},{"location":"secrets/setup-sops/#security-recommendations","title":"Security Recommendations","text":"<p>Access to sops decryption secrets should be restricted and allowed only to be read by flux's kustomize controller. This can be done using Kubernetes RBAC.</p> <p>Here's an example of how you can use RBAC to restrict access to sops decryption secrets:</p> <ol> <li>Create a new Kubernetes role that grants read access to sops decryption secrets</li> </ol> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: sops-secrets-role\nrules:\n- apiGroups: [\"\"]\nresources: [\"secrets\"]\nresourceNames: [\"sops-gpg-private-key\", \"sops-age-private-key\"]\nverbs: [\"get\", \"watch\", \"list\"]\n</code></pre> <ol> <li>Bind the role to the service account of the flux's kustomize-controller</li> </ol> Expand to view the RoleBinding  <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: sops-secrets-rolebinding\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: sops-secrets-role\nsubjects:\n- kind: ServiceAccount\nname: kustomize-controller\n</code></pre> <p>Warning</p> <p>You would need to ensure that no other rolebindings or clusterrolebndings would allow reading the the decryption secret at any time. This could be achieved by leveraging policy capabilities to detect existing and prevent future creation of roles that would grant read secrets permissions.</p>"},{"location":"secrets/spec/","title":"Secret versions","text":""},{"location":"secrets/spec/#versions","title":"Versions","text":"<ul> <li>v1alpha1</li> </ul>"},{"location":"secrets/spec/v1alpha1/secretSync/","title":"SecretSync ENTERPRISE","text":"<p>It provides semantics to sync Kuberentes Secrets from management cluster to leaf clusters.</p> <pre><code>apiVersion: capi.weave.works/v1alpha1\nkind: SecretSync\nmetadata:\nname: my-dev-secret-syncer\nnamespace: default\nspec:\nclusterSelector:\nmatchLabels:\nenvironment: dev\nsecretRef:\nname: my-dev-secret\ntargetNamespace: my-namespace\n</code></pre>"},{"location":"secrets/spec/v1alpha1/secretSync/#specification","title":"Specification","text":"<p>The documentation for the api version <code>capi.weave.works/v1alpha1</code></p> <pre><code>type SecretSync struct {\nmetav1.TypeMeta   `json:\",inline\"`\nmetav1.ObjectMeta `json:\"metadata,omitempty\"`\nSpec              SecretSyncSpec   `json:\"spec,omitempty\"`\nStatus            SecretSyncStatus `json:\"status,omitempty\"`\n}\n\n// SecretSyncSpec\ntype SecretSyncSpec struct {\n// Label selector for Clusters. The Clusters that are\n// selected by this will be the ones affected by this SecretSync.\n// It must match the Cluster labels. This field is immutable.\n// Label selector cannot be empty.\nClusterSelector metav1.LabelSelector `json:\"clusterSelector\"`\n// SecretRef specifies the Secret to be bootstrapped to the matched clusters\n// Secret must be in the same namespace of the SecretSync object\nSecretRef v1.LocalObjectReference `json:\"secretRef\"`\n// TargetNamespace specifies the namespace which the secret should be bootstrapped in\n// The default value is the namespace of the referenced secret\n//+optional\nTargetNamespace string `json:\"targetNamespace,omitempty\"`\n}\n\n// SecretSyncStatus secretsync object status\ntype SecretSyncStatus struct {\n// SecretVersions a map contains the ResourceVersion of the secret of each cluster\n// Cluster name is the key and secret's ResourceVersion is the value\nSecretVersions map[string]string `json:\"versions\"`\n}\n</code></pre>"},{"location":"terraform/","title":"Overview","text":"<p>Terraform Controller (TF-Controller) is a reliable tool for managing your infrastructure and application resources using the GitOps approach, all at your own pace. An open source project created by Weaveworks, the makers of Flux, TF-Controller follows patterns established by Flux and integrates with Weave GitOps. </p> <p>TF-Controller makes the following GitOps models available to suit your specific needs:</p> <ul> <li>Drift Detection: Use GitOps for drift detection so that you can decide which actions to take when drift occurs.</li> <li>GitOps Automation: Fully automate the GitOps process, including provisioning and enforcement, for all of your Terraform resources.</li> <li>Hybrid GitOps Automation: GitOps-ify certain parts of your existing infrastructure resources, such as a nodegroup or security group in an existing EKS cluster.</li> <li>State Enforcement: Use GitOps to enforce an existing <code>tfstate</code> without making any other changes.</li> </ul> <p>To get started with TF-controller, simply follow the provided getting started guide. You can also find extensive documentation here\u2014it covers API references, CLI references, and how-to's for common situations.</p> <p>With Weave GitOps Enterprise, you can manage <code>Terraform</code> objects the same way you can with <code>Kustomization</code> and <code>HelmReleases</code>:</p> <p></p>"},{"location":"terraform/#features","title":"Features","text":"<ul> <li>Multi-Tenancy: TF-controller supports multi-tenancy by running Terraform <code>plan</code> and <code>apply</code> inside Runner Pods.     When specifying <code>.metadata.namespace</code> and <code>.spec.serviceAccountName</code>, the Runner Pod uses the specified ServiceAccount     and runs inside the specified Namespace. These settings enable the soft multi-tenancy model, usable within     the Flux multi-tenancy setup.</li> <li>GitOps Automation for Terraform: Setting <code>.spec.approvePlan=auto</code> allows a <code>Terraform</code> object     to be reconciled and act as the representation of your Terraform resources. TF-controller uses the spec of     the <code>Terraform</code> object to <code>plan</code> and <code>apply</code> its associated Terraform resources. It then stores     the <code>TFSTATE</code> of the applied resources as a <code>Secret</code> inside the Kubernetes cluster. After <code>.spec.interval</code> passes,     TF-Controller checks for drift between your live system and your Terraform resources and, if affirmative, automatically generates and applies a plan to correct it.</li> <li>Drift detection: Enabled by default, and part of the GitOps automation feature, the controller detects and fixes infrastructure drift based on the Terraform resources and their <code>TFSTATE</code>. You can use the field <code>.spec.disableDriftDetection</code> to disable this behaviour. Drift detection-only mode, without <code>plan</code> or <code>apply</code> steps, allows you to perform read-only drift detection.</li> <li>Plan and Manual Approve: Separate the <code>plan</code> from the <code>apply</code> step, just like in the Terraform workflow you are familiar with\u2014but in a GitOps way. When a plan is generated, the controller shows you a message asking if you want to apply it. Optionally create and push the change to a new branch for your team members to review and approve too.</li> <li>YAML-based Terraform: The <code>Terraform</code> object in v0.13.0+ allows you to better configure your     Terraform resources via YAMLs, but without introducing any extra CRDs to your cluster.</li> <li>First-class Terraform Cloud Support: Use <code>spec.cloud</code> to configure <code>Terraform</code> objects to use Terraform Cloud as the backend     for storing the state.</li> </ul>"},{"location":"terraform/#dependencies","title":"Dependencies","text":"<p>TF-controller has its own versioning system that is separate from the versioning system used by Weave GitOps. This means that you can install and use TF-controller independently of Weave GitOps\u2014it will not be affected by the version of Weave GitOps that you are using.</p> <p>Here is the dependency matrix:</p> Version Terraform Source Controller Flux v2 v0.14.0 v1.3.9 v0.35.1 v0.40.x v0.13.1 v1.3.1 v0.31.0 v0.38.x"},{"location":"terraform/get-started-terraform/","title":"Get Started with the Terraform Controller","text":""},{"location":"terraform/get-started-terraform/#preflight-checks","title":"Preflight Checks","text":"<p>To set up the Terraform Controller (TF-Controller), follow the steps in the preflight checks. Here is a summary of what you will need to do:</p> <ol> <li>Install Flux v0.32.0 or later on your cluster. This includes installing the Flux CLI on your local machine and installing the Flux controllers on the cluster.</li> <li>Configure the network firewall or security groups on your cluster to allow incoming connections to port 30000 on each Runner's Pod in each namespace.      This will allow the Controller to communicate with the Runner's Pod via gRPC.</li> <li>Configure the network firewall or security groups on your cluster to allow the Controller to download tar.gz BLOBs from the Source controller via port 80 and      to post events to the Notification controller via port 80.</li> </ol> <p>The exact steps for setting up the TF-controller will depend on the specific environment and infrastructure that you are using. The project's documentation provides additional information to help with setup.</p>"},{"location":"terraform/get-started-terraform/#setup","title":"Setup","text":"<p>Perform the following actions to set up TF-Controller:</p> <ol> <li> <p>Create a local cluster using a tool such as <code>kind</code> or <code>minikube</code>. This will allow you to develop and test TF-Controller in a local environment before deploying it to a production cluster. <pre><code>kind create cluster --name tf-controller\n</code></pre></p> </li> <li> <p>Install the Flux CLI on your local machine. This will allow you to interact with the Flux controllers on your cluster. <pre><code>brew install fluxcd/tap/flux\n</code></pre></p> </li> <li> <p>Prepare a Git repository to store the configuration files and manifests for Flux and TF-controller. For this example we'll use GitHub. To follow along, you'll need a GitHub account and personal access token with repo permissions. You'll also need to properly configure your Git client by setting your username and email address. </p> </li> </ol> <p>Assuming your username is <code>$GITHUB_USER</code>, you can create a new repository called <code>gitops-tf-controller</code> using the following command: <pre><code>export GITHUB_USER=&lt;your github username&gt;\nexport GITHUB_TOKEN=&lt;your github personal access token&gt;\n\ngh repo create $GITHUB_USER/gitops-tf-controller\n</code></pre></p> <ol> <li> <p>Bootstrap the cluster with Flux v2 (v0.32.0 or later) using the path (for example) <code>./cluster/my-cluster</code>. This will install Flux on the cluster and create a Flux system at <code>./cluster/my-cluster/flux-system</code>. <pre><code>git clone git@github.com:$GITHUB_USER/gitops-tf-controller.git\ncd gitops-tf-controller\n\nflux bootstrap github \\\n--owner=$GITHUB_USER \\\n--repository=gitops-tf-controller \\\n--branch=main \\\n--path=./cluster/my-cluster \\\n--personal \\\n--token-auth\n</code></pre></p> </li> <li> <p>Create a directory at <code>./cluster/my-cluster/infra/</code>:</p> </li> </ol> <pre><code>mkdir -p ./cluster/my-cluster/infra/\n</code></pre> <p>Download the TF-controller manifest from the release location  and save it to <code>./cluster/my-cluster/infra/tf-controller.yaml</code>\u2014placing the file <code>tf-controller.yaml</code> in this directory:</p> <p><pre><code>curl -s https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/release.yaml &gt; ./cluster/my-cluster/infra/tf-controller.yaml\n</code></pre> Add the manifest file to the Git repository, then push the changes to your repository.</p> <ol> <li>In the same directory, create a <code>kustomization.yaml</code> file that contains the following:</li> </ol> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n- tf-controller.yaml\n</code></pre> <p>Add the <code>kustomization.yaml</code> file to your Git repository, then push the changes to your repository.</p> <p>If you want to use TF-Controller with the Notification Controller, you will also need to modify the manifest to enable the two controllers to work together. The exact steps for doing this will depend on the specific requirements of your environment and the configuration of the Notification Controller. You may need to refer to the documentation for the TF-Controller and Notification Controller for more information on how to set this up.</p>"},{"location":"terraform/get-started-terraform/#other-installation-methods","title":"Other Installation Methods","text":"<p>Before using TF-Controller, you must install Flux by using either <code>flux install</code> or the <code>flux bootstrap</code> command. Make sure you have the latest version of Flux. After that, you can install TF-controller with Flux HelmRelease with this command:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/release.yaml\n</code></pre> <p>For the most recent TF-Controller release candidate, please use rc.yaml:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/rc.yaml\n</code></pre> <p>or manually with Helm by:</p> <pre><code># Add tf-controller helm repository\nhelm repo add tf-controller https://weaveworks.github.io/tf-controller/\n\n# Install tf-controller\nhelm upgrade -i tf-controller tf-controller/tf-controller \\\n--namespace flux-system\n</code></pre> <p>For details on configurable parameters of the TF-controller chart, please see this chart Readme.</p> <p>Alternatively, you can install TF-controller via <code>kubectl</code>:</p> <pre><code>export TF_CON_VER=v0.14.0\nkubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.crds.yaml\nkubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.rbac.yaml\nkubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.deployment.yaml\n</code></pre>"},{"location":"terraform/get-started-terraform/#quick-start","title":"Quick Start","text":"<p>Here's a simple example of how to GitOps your Terraform resources with TF-controller and Flux.</p>"},{"location":"terraform/get-started-terraform/#define-source","title":"Define Source","text":"<p>First, define a Source controller's source (<code>GitRepository</code>, <code>Bucket</code>, <code>OCIRepository</code>)\u2014for example:</p> <pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: GitRepository\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\ninterval: 30s\nurl: https://github.com/tf-controller/helloworld\nref:\nbranch: main\n</code></pre>"},{"location":"terraform/get-started-terraform/#the-gitops-automation-mode","title":"The GitOps Automation Mode","text":"<p>In this mode, Terraform resources will be planned and automatically applied for you. Enable it by setting <code>.spec.approvePlan=auto</code>: </p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha2\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\ninterval: 1m\napprovePlan: auto\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre> <p>For a full list of features and how to use them, please visit the Terraform overview.</p>"},{"location":"terraform/get-started-terraform/#troubleshooting","title":"Troubleshooting","text":""},{"location":"terraform/get-started-terraform/#getting-a-drift-detected-event-message-when-its-a-change-of-source-that-triggered-the-update","title":"Getting a <code>drift detected</code> event message when it's a change of source that triggered the update","text":"<p>Whenever you change a source, you will get a new plan. TF-controller picks up the new plan and applies it. Drift happens if, and only if, the live system changes intentionally. Then TF-controller will generate a lengthy message see an example stating that a drift has occurred. If there is drift, the icon will be red in the TF Objects &gt; Status column of the WGE UI.</p>"},{"location":"terraform/get-started-terraform/#other-examples","title":"Other Examples","text":"<ul> <li>A Terraform GitOps with Flux to automatically reconcile your AWS IAM Policies.</li> <li>GitOps an existing EKS cluster by partially importing its nodegroup and managing it with TF-controller: An EKS scaling example.</li> </ul>"},{"location":"terraform/using-terraform-templates/","title":"Using Terraform Templates ENTERPRISE","text":"<p>This guide will show you how to use a template to create a Terraform resource in Weave GitOps Enterprise.</p>"},{"location":"terraform/using-terraform-templates/#cli-guide","title":"CLI Guide","text":""},{"location":"terraform/using-terraform-templates/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Weave GitOps Enterprise and enable TLS.</li> <li>Install Terraform Controller.</li> </ul>"},{"location":"terraform/using-terraform-templates/#1-add-a-template-to-your-cluster","title":"1. Add a template to your cluster","text":"<p>Add the following template to a path in your Git repository that is synced by Flux. For example, in the Installation guide, we set the path that is synced by Flux to <code>./clusters/management</code>.</p> <p>Commit and push these changes. Once a template is available in the cluster, it can be used to create a resource, which will be shown in the next step.</p> Expand to see ./clusters/management/tf-template.yaml ./clusters/management/tf-template.yaml<pre><code>---\napiVersion: clustertemplates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: tf-template\nnamespace: default\nspec:\ndescription:\nThis is a sample WGE template that will be translated into a tf-controller specific template.\nparams:\n- name: RESOURCE_NAME\ndescription: Resource Name\nresourcetemplates:\n- content:\n- apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: ${RESOURCE_NAME}\nnamespace: flux-system\nspec:\ninterval: 1h\npath: ./\napprovePlan: auto\nalwaysCleanupRunnerPod: true\nsourceRef:\nkind: GitRepository\nname: flux-system\nnamespace: flux-system\n</code></pre> <p>Verify that your template is in the cluster: <pre><code>kubectl get gitopstemplates.clustertemplates.weave.works -A\nNAME                                AGE\nsample-wge-tf-controller-template   14m\n</code></pre></p> <p>If the template does not appear immediately, reconcile the changes with Flux: <pre><code>flux reconcile kustomization flux-system\n\u25ba annotating Kustomization flux-system in flux-system namespace\n\u2714 Kustomization annotated\n\u25ce waiting for Kustomization reconciliation\n\u2714 applied revision main/e6f5f0c3925bcfecdb50bceb12af9a87677d2213\n</code></pre></p>"},{"location":"terraform/using-terraform-templates/#2-use-the-template-to-create-a-resource","title":"2. Use the template to create a resource","text":"<p>A resource can be created from a template by specifying the template's name and supplying values to it, as well as your Weave GitOps Enterprise username, password, and HTTP API endpoint. <pre><code>gitops add terraform --from-template sample-wge-tf-controller-template \\\n--set=\"RESOURCE_NAME\"=\"name\" \\\n--username=&lt;username&gt; --password=&lt;password&gt; \\\n--endpoint https://localhost:8000 \\\n--url https://github.com/myawesomeorg/myawesomerepo\n\nCreated pull request: https://github.com/myawesomeorg/myawesomerepo/pull/5\n</code></pre></p> <p>This will create a PR in your Git repository with a TF-Controller manifest. Once the PR is merged, TF-Controller will supply the values to the Terraform manifest, apply the Terraform manifest to create the resource, and reconcile any changes that you make to the Terraform manifest!</p> <p>This template can be used to create multiple resources out of the same Terraform manifest by supplying different values to the template. Any changes to the Terraform manifest will be reconciled automatically to all resources.</p>"},{"location":"terraform/using-terraform-templates/#3-list-available-templates","title":"3. List available templates","text":"<p>Get a specific template that can be used to create a Terraform resource: <pre><code>gitops get template terraform sample-wge-tf-controller-template --endpoint https://localhost:8000 --username=&lt;username&gt; --password=&lt;password&gt;\nNAME                                PROVIDER   DESCRIPTION                                                                                     ERROR\nsample-wge-tf-controller-template              This is a sample WGE template that will be translated into a tf-controller specific template.\n</code></pre></p> <p>List all the templates available on the cluster: <pre><code>gitops get template terraform --endpoint https://localhost:8000 --username=&lt;username&gt; --password=&lt;password&gt;\nNAME                                PROVIDER   DESCRIPTION                                                                                     ERROR\nsample-aurora-tf-template                      This is a sample Aurora RDS template.\nsample-wge-tf-controller-template              This is a sample WGE template that will be translated into a tf-controller specific template.\n</code></pre></p>"},{"location":"terraform/using-terraform-templates/#4-list-the-parameters-of-a-template","title":"4. List the parameters of a template","text":"<p>List all the parameters that can be defined on a specific template: <pre><code>gitops get template terraform tf-controller-aurora --list-parameters --endpoint https://localhost:8000 --username=&lt;username&gt; --password=&lt;password&gt;\nNAME            REQUIRED   DESCRIPTION     OPTIONS\nRESOURCE_NAME   false      Resource Name\n</code></pre></p>"},{"location":"terraform/using-terraform-templates/#use-case-create-an-aurora-rds-with-wge","title":"Use Case: Create an Aurora RDS with WGE","text":"<p>BONUS</p> <p>For a more advanced example, here is a template to create an Aurora RDS cluster using WGE with Flux and the TF-Controller.</p>"},{"location":"terraform/using-terraform-templates/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Everything from the previous section</li> <li>Get (or create) an AWS Access Key ID and Secret Access Key. Check the AWS docs for details on how to do this.</li> <li>Create an AWS IAM Role for the Terraform AWS Provider. Its policy should include <code>iam:CreateRole</code>. More info here.</li> </ul>"},{"location":"terraform/using-terraform-templates/#1-configure-a-way-to-manage-secrets","title":"1. Configure a way to manage secrets","text":"<p>Configure a way to safely store Secrets. One method is to use the Mozilla SOPS CLI, but there are other ways, such as Sealed Secrets or Vaults.</p> <p>Follow the steps in the Flux docs except for the \"Configure in-cluster secrets decryption\" step! This step looks slightly different for WGE. Instead of re-creating the controllers, you can configure the <code>kustomize-controller</code> as instructed below.</p> <p>In your Git repository source, add the following to your <code>kustomize-controller</code> configuration: <pre><code>cat &lt;&lt;EOF &gt;&gt; ./clusters/&lt;cluster-name&gt;/flux-system/gotk-sync.yaml\n  decryption:\n    provider: sops\n    secretRef:\n      name: sops-gpg\nEOF\n</code></pre></p>"},{"location":"terraform/using-terraform-templates/#2-encrypt-and-store-your-credentials-in-your-git-repository","title":"2. Encrypt and store your credentials in your Git repository","text":"<p>Create a Secret to store sensitive values such as the following: - DB username - DB password - AWS Access Key ID - AWS Secret Access Key - AWS Role ARN</p> <p>Note</p> <p>If following the Flux guide, this steps corresponds to \"Encrypting secrets using OpenPGP\". You can stop following the Flux guide at this step.</p> <p>For example, here is what you would do if using the SOPS method: <pre><code>kubectl -n flux-system create secret generic tf-controller-auth \\\n--from-literal=master_username=admin \\\n--from-literal=master_password=change-me \\\n--from-literal=aws_access_key=AKIAIOSFODNN7EXAMPLE \\\n--from-literal=aws_secret_key=\"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\" \\\n--from-literal=aws_role_arn=\"arn:aws:iam::012345678910:role/wge-tf-controller-example\" \\\n--dry-run=client \\\n-o yaml &gt; tf-controller-auth.yaml\n</code></pre></p> <p>Then, encrypt the secret: <pre><code>sops --encrypt --in-place tf-controller-auth.yaml\n</code></pre></p> <p>Commit and push your changes. You can now store encrypted secrets to your Git repository.</p>"},{"location":"terraform/using-terraform-templates/#4-add-the-manifests-to-your-cluster","title":"4. Add the manifests to your cluster","text":"<p>Add the following Terraform manifest to the root of your Git repository.</p> Expand to see Terraform manifest ./rds.tf<pre><code>terraform {\nrequired_providers {\naws = {\nsource  = \"hashicorp/aws\"\nversion = \"~&gt; 3.0\"\n}\n}\n}\n\nvariable \"cluster_identifier\" {}\nvariable \"database_name\" {}\nvariable \"master_username\" {}\nvariable \"master_password\" {}\nvariable \"backup_retention_period\" {}\nvariable \"region\" {}\nvariable \"aws_access_key\" {}\nvariable \"aws_secret_key\" {}\nvariable \"aws_role_arn\" {}\n\nprovider \"aws\" {\nregion = var.region\naccess_key = var.aws_access_key\nsecret_key = var.aws_secret_key\n\nassume_role {\nrole_arn    = var.aws_role_arn\n}\n}\n\nlocals {\nengine         = \"aurora-mysql\"\nengine_version = \"5.7.mysql_aurora.2.07.5\"\nport           = 3306\n}\n\ndata \"aws_availability_zones\" \"available\" {\nstate    = \"available\"\n\nfilter {\nname   = \"group-name\"\nvalues = [var.region]\n}\n}\n\nresource \"aws_rds_cluster\" \"mycluster\" {\ncluster_identifier      = var.cluster_identifier\nengine                  = local.engine\nengine_version          = local.engine_version\nport                    = local.port\navailability_zones      = slice(data.aws_availability_zones.available.names, 0, 3)\ndatabase_name           = var.database_name\nmaster_username         = var.master_username\nmaster_password         = var.master_password\nbackup_retention_period = var.backup_retention_period\nskip_final_snapshot     = true\napply_immediately       = true\n}\n\nresource \"aws_rds_cluster_instance\" \"cluster_instance\" {\ncount              = 1\nidentifier         = \"${aws_rds_cluster.mycluster.id}-${count.index}\"\ncluster_identifier = aws_rds_cluster.mycluster.id\ninstance_class     = \"db.t3.small\"\nengine             = aws_rds_cluster.mycluster.engine\nengine_version     = aws_rds_cluster.mycluster.engine_version\n}\n</code></pre> <p>Add the following template to a path in your Git repository that is synced by Flux. In the quickstart guide, we set this path to <code>./clusters/management</code>.</p> Expand to see Terraform manifest at ./clusters/management/rds-template.yaml ./clusters/management/rds-template.yaml<pre><code>---\napiVersion: clustertemplates.weave.works/v1alpha2\nkind: GitOpsTemplate\nmetadata:\nname: rds-template\nnamespace: default\nspec:\ndescription: This is a sample Aurora RDS template.\nparams:\n- name: RESOURCE_NAME\ndescription: Resource Name\n- name: CLUSTER_IDENTIFIER\ndescription: Cluster Identifier\n- name: DATABASE_NAME\ndescription: Database Name\n- name: BACKUP_RETENTION_PERIOD\ndescription: Backup Retention Period\n- name: REGION\ndescription: Region\nresourcetemplates:\n- contents:\n- apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: ${RESOURCE_NAME}\nnamespace: flux-system\nspec:\ninterval: 1h\npath: ./\napprovePlan: auto\nalwaysCleanupRunnerPod: true\nvars:\n- name: cluster_identifier\nvalue: ${CLUSTER_IDENTIFIER}\n- name: database_name\nvalue: ${DATABASE_NAME}\n- name: backup_retention_period\nvalue: ${BACKUP_RETENTION_PERIOD}\n- name: region\nvalue: ${REGION}\nvarsFrom:\n- kind: Secret\nname: tf-controller-auth\nsourceRef:\nkind: GitRepository\nname: flux-system\nnamespace: flux-system\n</code></pre> <p>Commit and push your changes.</p> <p>Tip</p> <p>You can change the location where you keep your Terraform manifests in your Git source (which the TF-Controller will reconcile) by configuring <code>spec.resourcetemplates.spec.path</code>.</p>"},{"location":"terraform/using-terraform-templates/#5-use-the-template-to-create-the-rds","title":"5. Use the template to create the RDS","text":"<pre><code>gitops add terraform --from-template rds-template \\\n--username=&lt;username&gt; --password=&lt;password&gt; \\\n--endpoint https://localhost:8000 \\\n--url https://github.com/myawesomeorg/myawesomerepo \\\n--set \"RESOURCE_NAME\"=\"tf-controller-aurora\",\"CLUSTER_IDENTIFIER\"=\"super-awesome-aurora\",\"DATABASE_NAME\"=\"db1\",\"BACKUP_RETENTION_PERIOD\"=5,\"REGION\"=\"us-west-2\"\n\nCreated pull request: https://github.com/myawesomeorg/myawesomerepo/pull/6\n</code></pre> <p>Merge the PR in your Git repository to add the TF-Controller manifest. TF-Controller will supply the values to the Terraform manifest, apply the Terraform manifest to create the resource, and reconcile any changes that you make to the Terraform manifest.</p> <p>Any changes to your Terraform manifest will be automatically reconciled by the TF-controller with Flux.</p> <p>You can re-use this template to create multiple Terraform resources, each with a different set of values!</p> <p>Make sure to delete the newly created RDS resources to not incur additional costs.</p>"},{"location":"workspaces/","title":"Introduction ENTERPRISE","text":""},{"location":"workspaces/#workspaces","title":"Workspaces","text":"<p>Organizations working with Kubernetes have a tremendous need to manage tenancy for numerous software delivery teams. Weave GitOps Workspaces offers tenancy management for Kubernetes clusters at scale. It\u2019s built on top of Flux's powerful approach to managing tenancy, and adds policies that will help you to define finer-grain rules on your tenants.</p> <p>With WGE Workspaces, all it takes for platform operators to create workspaces is a single CLI command that generates:</p> <ul> <li>all the necessary YAML configuration files necessary for tenant setup</li> <li>a list of policies that apply to each workspace</li> <li>the list of repositories to which each workspace has access.</li> </ul>"},{"location":"workspaces/multi-tenancy/","title":"Multi Tenancy ENTERPRISE","text":"<p>Multi tenancy provides users with the ability to define boundaries to multiple engineering teams working on a single cluster. Through a simple interface it adds permissions to the necessary Kubernetes resources to make it easy for customers to manage their multiple tenants.</p> <p>WGE multi tenancy expands on the multi tenancy feature provided by <code>flux</code>. In addition to creating the necessary Kubernetes tenancy resources that <code>flux</code> adds, multi tenancy in WGE also adds the following: - Defining tenancy using a single yaml file that serves as a source of truth for the organization - Makes use of WGE policy features to enforce non Kubernetes native permissions</p>"},{"location":"workspaces/multi-tenancy/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>gitops</code> command line tool</li> <li>Tenancy File (optional)</li> <li>Policies (optional)</li> </ul>"},{"location":"workspaces/multi-tenancy/#how-it-works","title":"How it works","text":"<p><code>gitops</code> command line tool is responsible for creating the multi tenancy resources. The tool is distributed as part of WGE offering. It reads the definitions of a yaml file and can either apply the necessary changes directly to the cluster or output it to stdout so it can be saved into a file and pushed to a repo to be reconciled by <code>flux</code>.</p> <p>To make use of the policy features, policy agent needs to be installed in the necessary cluster(s). </p>"},{"location":"workspaces/multi-tenancy/#tenancy-file","title":"Tenancy file","text":"<p>Below is an example of a tenancy file:</p> Expand to view tenancy.yaml<pre><code>---\ntenants:\n- name: first-tenant\nnamespaces:\n- first-ns\n- name: second-tenant\nnamespaces:\n- second-test-ns\n- second-dev-ns\nallowedRepositories:\n- kind: GitRepository\nurl: https://github.com/testorg/testrepo\n- kind: GitRepository\nurl: https://github.com/testorg/testinfo\n- kind: Bucket\nurl: minio.example.com\n- kind: HelmRepository\nurl: https://testorg.github.io/testrepo\nallowedClusters:\n- kubeConfig: cluster-1-kubeconfig\n- kubeConfig: cluster-2-kubeconfig\nteamRBAC:\ngroupNames:\n- foo-group\n- bar-group\nrules:\n- apiGroups:\n- ''\nresources:\n- 'namespaces'\n- 'pods'\nverbs:\n- 'list'\n- 'get'\ndeploymentRBAC:\nbindRoles:\n- name: foo-role\nkind: Role\nrules:\n- apiGroups:\n- ''\nresources:\n- 'namespaces'\n- 'pods'\nverbs:\n- 'list'\n- 'get'\nserviceAccount:\nname: \"reconcilerServiceAccount\"\n</code></pre> <p>The file above defines two tenants: <code>first-tenant</code> and <code>second-tenant</code> as follows:</p> <ul> <li><code>namespaces</code>: describes which namespaces should be part of the tenant. Meaning that users who are part of the tenant would have access on those namespaces.</li> <li><code>allowedRepositories</code>: limits the <code>flux</code> repositories sources that can be used in the tenant's namespaces. This is done through policies and thus requires <code>policy-agent</code> to be deployed on the cluster which will stop these sources from being deployed if they aren't allowed as part of the tenant. IT consists of:</li> <li><code>kind</code>: the <code>flux</code> source kind. Can be: <code>GitRepository</code>, <code>Bucket</code> and <code>HelmRepository</code>.</li> <li><code>url</code>: the URL for that source.</li> <li><code>allowedClusters</code>: limits which secrets containing cluster configuraton can be used. It stops WGE <code>GitopsCluster</code> and flux <code>Kustomization</code> from being deployed if they point to a secret not in the list, essentially giving control on which cluster can be added to a multi-cluster setup. Requires <code>policy-agent</code>.</li> <li><code>kubeConfig</code>: name of the secret that can be used for this tenant.</li> <li><code>teamRBAC</code>: Generate Roles and Rolebindings for a list of <code>groupNames</code>. This allows you to easily give an OIDC group access to a tenant's resources. When the Weave Gitops Enterprise UI is configured with your OIDC provider, tenants can log in and view the status of the resources they have been granted access to.</li> <li><code>deploymentRBAC</code>: generate Roles and Rolebindings for a service account. Can additionally bind to an existing Roles/ClusterRoles. Would use the global service account if specified in the tenants file, otherwise it will use the created service account which takes the tenant name. If not specified a Rolebinding would be created that binds to <code>cluster-admin</code> ClusterRole.</li> </ul> <p>Global options:</p> <ul> <li><code>serviceAccount</code>: Override the name of the generated <code>ServiceAccount</code> for all tenants. This allows you to easily use the flux controllers' <code>--default-service-account</code> feature. Tenants do not need to make sure they correctly specify the <code>serviceAccount</code> when using <code>Kustomization</code> or <code>HelmRelease</code> resources. The kustomization-controller and helm-controller will instead look for the <code>default-service-account</code> in the namespace being reconciled to and use that. Just configure <code>serviceAccount.name</code> and <code>--default-service-account</code> to the same value.</li> </ul>"},{"location":"workspaces/multi-tenancy/#gitops-create-tenants-command","title":"Gitops create tenants command","text":"<p>The command creates the necessary resources to apply multi tenancy on the user's cluster. To use the command to apply the resources directly the user needs to have the necessary configuration to connect to the desired cluster. The command considers the tenancy file as a source of truth and will change the cluster state to match what is currently described in the file.</p> <p>For more control on a specific tenant a tenancy file should be used, the command allows the creation of the base resources that defines a tenancy through the arguments:</p> <pre><code>gitops create tenants --name test-tenant --namespace test-ns1 --namespace test-ns2\n</code></pre> Expand to view command output <pre><code>namespace/test-ns1 created\ntest-ns1/serviceaccount/test-tenant created\ntest-ns1/rolebinding.rbac.authorization.k8s.io/test-tenant-service-account-cluster-admin created\nnamespace/test-ns2 created\ntest-ns2/serviceaccount/test-tenant created\ntest-ns2/rolebinding.rbac.authorization.k8s.io/test-tenant-service-account-cluster-admin created\npolicy.pac.weave.works/weave.policies.tenancy.test-tenant-allowed-application-deploy created\n</code></pre> <p>The above will create the namespaces and permissions through a <code>ServiceAccount</code> with the same name as the tenant, <code>test-tenant</code> in the case of the above example, in each required namespace. The same can be done through a file as follows:</p> <pre><code>tenants:\n- name: test-tenant\nnamespaces:\n- test-ns1\n- test-ns2\n</code></pre> <pre><code>gitops create tenants --from-file tenants.yaml\n</code></pre> Expand to view command output <pre><code>namespace/test-ns1 created\ntest-ns1/serviceaccount/test-tenant created\ntest-ns1/rolebinding.rbac.authorization.k8s.io/test-tenant-service-account-cluster-admin created\nnamespace/test-ns2 created\ntest-ns2/serviceaccount/test-tenant created\ntest-ns2/rolebinding.rbac.authorization.k8s.io/test-tenant-service-account-cluster-admin created\npolicy.pac.weave.works/weave.policies.tenancy.test-tenant-allowed-application-deploy created\n</code></pre> <p>To check the resources that would be deployed first use the <code>export</code> flag:</p> <pre><code>gitops create tenants --from-file tenants.yaml --export\n</code></pre> Expand to view command output <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: test-ns1\nspec: {}\nstatus: {}\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: test-tenant\nnamespace: test-ns1\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: test-tenant-service-account-cluster-admin\nnamespace: test-ns1\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: cluster-admin\nsubjects:\n- kind: ServiceAccount\nname: test-tenant\nnamespace: test-ns1\n---\napiVersion: v1\nkind: Namespace\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: test-ns2\nspec: {}\nstatus: {}\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: test-tenant\nnamespace: test-ns2\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: test-tenant-service-account-cluster-admin\nnamespace: test-ns2\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: cluster-admin\nsubjects:\n- kind: ServiceAccount\nname: test-tenant\nnamespace: test-ns2\n---\napiVersion: pac.weave.works/v2beta2\nkind: Policy\nmetadata:\ncreationTimestamp: null\nlabels:\n    toolkit.fluxcd.io/tenant: test-tenant\nname: weave.policies.tenancy.test-tenant-allowed-application-deploy\nspec:\ncategory: weave.categories.tenancy\ncode: |\npackage weave.tenancy.allowed_application_deploy\n\n    controller_input := input.review.object\n    violation[result] {\nnamespaces := input.parameters.namespaces\n        targetNamespace := controller_input.spec.targetNamespace\n        not contains_array(targetNamespace, namespaces)\nresult = {\n\"issue detected\": true,\n        \"msg\": sprintf(\"using target namespace %v is not allowed\", [targetNamespace]),\n        }\n}\nviolation[result] {\nserviceAccountName := controller_input.spec.serviceAccountName\n        serviceAccountName != input.parameters.service_account_name\n        result = {\n\"issue detected\": true,\n        \"msg\": sprintf(\"using service account name %v is not allowed\", [serviceAccountName]),\n        }\n}\ncontains_array(item, items) {\nitems[_] = item\n    }\ndescription: Determines which helm release and kustomization can be used in a tenant\nhow_to_solve: \"\"\nid: weave.policies.tenancy.test-tenant-allowed-application-deploy\nname: test-tenant allowed application deploy\nparameters:\n- name: namespaces\n    required: false\ntype: array\n    value:\n    - test-ns1\n    - test-ns2\n- name: service_account_name\n    required: false\ntype: string\n    value: test-tenant\nprovider: kubernetes\nseverity: high\nstandards: []\ntags:\n- tenancy\ntargets:\n    kinds:\n    - HelmRelease\n    - Kustomization\n    labels: []\nnamespaces:\n    - test-ns1\n    - test-ns2\nstatus: {}\n---\n</code></pre> <p>Applying the resources through the command line is not usually recommended. For WGE the recommended way is to commit the result of the <code>create tenants</code> command to source control and let <code>flux</code> handle deployment. To achieve that you can save the result of the <code>export</code> to a file:</p> <pre><code>gitops create tenants --from-file tenants.yaml --export &gt; clusters/management/tenants.yaml </code></pre>"},{"location":"workspaces/view-workspaces/","title":"Workspaces List View ENTERPRISE","text":"<p>From the side menu, you can click on the Workspaces tab to go to the workspaces list view.</p> <p>This view lists workspaces across all clusters. You can filter workspaces by their clusters or their names.</p> <p></p>"},{"location":"workspaces/view-workspaces/#workspace-details-view","title":"Workspace Details View","text":"<p>You can go to this view by clicking on the name of the workspace in the Workspaces List View.</p> <p>In this view you can see all details of the workspace such as its name, namespace, and all resources related to this workspace.</p> <p></p>"}]}