// Code generated by counterfeiter. DO NOT EDIT.
package gitprovidersfakes

import (
	"context"
	"sync"

	"github.com/fluxcd/go-git-providers/gitprovider"
	"github.com/weaveworks/weave-gitops/pkg/gitproviders"
)

type FakeGitProvider struct {
	CreatePullRequestStub        func(context.Context, gitproviders.RepoURL, gitproviders.PullRequestInfo) (gitprovider.PullRequest, error)
	createPullRequestMutex       sync.RWMutex
	createPullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 gitproviders.PullRequestInfo
	}
	createPullRequestReturns struct {
		result1 gitprovider.PullRequest
		result2 error
	}
	createPullRequestReturnsOnCall map[int]struct {
		result1 gitprovider.PullRequest
		result2 error
	}
	DeployKeyExistsStub        func(context.Context, gitproviders.RepoURL) (bool, error)
	deployKeyExistsMutex       sync.RWMutex
	deployKeyExistsArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}
	deployKeyExistsReturns struct {
		result1 bool
		result2 error
	}
	deployKeyExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetCommitsStub        func(context.Context, gitproviders.RepoURL, string, int, int) ([]gitprovider.Commit, error)
	getCommitsMutex       sync.RWMutex
	getCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 string
		arg4 int
		arg5 int
	}
	getCommitsReturns struct {
		result1 []gitprovider.Commit
		result2 error
	}
	getCommitsReturnsOnCall map[int]struct {
		result1 []gitprovider.Commit
		result2 error
	}
	GetDefaultBranchStub        func(context.Context, gitproviders.RepoURL) (string, error)
	getDefaultBranchMutex       sync.RWMutex
	getDefaultBranchArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}
	getDefaultBranchReturns struct {
		result1 string
		result2 error
	}
	getDefaultBranchReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetProviderDomainStub        func() string
	getProviderDomainMutex       sync.RWMutex
	getProviderDomainArgsForCall []struct {
	}
	getProviderDomainReturns struct {
		result1 string
	}
	getProviderDomainReturnsOnCall map[int]struct {
		result1 string
	}
	GetRepoDirFilesStub        func(context.Context, gitproviders.RepoURL, string, string) ([]*gitprovider.CommitFile, error)
	getRepoDirFilesMutex       sync.RWMutex
	getRepoDirFilesArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 string
		arg4 string
	}
	getRepoDirFilesReturns struct {
		result1 []*gitprovider.CommitFile
		result2 error
	}
	getRepoDirFilesReturnsOnCall map[int]struct {
		result1 []*gitprovider.CommitFile
		result2 error
	}
	GetRepoVisibilityStub        func(context.Context, gitproviders.RepoURL) (*gitprovider.RepositoryVisibility, error)
	getRepoVisibilityMutex       sync.RWMutex
	getRepoVisibilityArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}
	getRepoVisibilityReturns struct {
		result1 *gitprovider.RepositoryVisibility
		result2 error
	}
	getRepoVisibilityReturnsOnCall map[int]struct {
		result1 *gitprovider.RepositoryVisibility
		result2 error
	}
	MergePullRequestStub        func(context.Context, gitproviders.RepoURL, int, string) error
	mergePullRequestMutex       sync.RWMutex
	mergePullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 int
		arg4 string
	}
	mergePullRequestReturns struct {
		result1 error
	}
	mergePullRequestReturnsOnCall map[int]struct {
		result1 error
	}
	RepositoryExistsStub        func(context.Context, gitproviders.RepoURL) (bool, error)
	repositoryExistsMutex       sync.RWMutex
	repositoryExistsArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}
	repositoryExistsReturns struct {
		result1 bool
		result2 error
	}
	repositoryExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UploadDeployKeyStub        func(context.Context, gitproviders.RepoURL, []byte) error
	uploadDeployKeyMutex       sync.RWMutex
	uploadDeployKeyArgsForCall []struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 []byte
	}
	uploadDeployKeyReturns struct {
		result1 error
	}
	uploadDeployKeyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitProvider) CreatePullRequest(arg1 context.Context, arg2 gitproviders.RepoURL, arg3 gitproviders.PullRequestInfo) (gitprovider.PullRequest, error) {
	fake.createPullRequestMutex.Lock()
	ret, specificReturn := fake.createPullRequestReturnsOnCall[len(fake.createPullRequestArgsForCall)]
	fake.createPullRequestArgsForCall = append(fake.createPullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 gitproviders.PullRequestInfo
	}{arg1, arg2, arg3})
	stub := fake.CreatePullRequestStub
	fakeReturns := fake.createPullRequestReturns
	fake.recordInvocation("CreatePullRequest", []interface{}{arg1, arg2, arg3})
	fake.createPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) CreatePullRequestCallCount() int {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	return len(fake.createPullRequestArgsForCall)
}

func (fake *FakeGitProvider) CreatePullRequestCalls(stub func(context.Context, gitproviders.RepoURL, gitproviders.PullRequestInfo) (gitprovider.PullRequest, error)) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = stub
}

func (fake *FakeGitProvider) CreatePullRequestArgsForCall(i int) (context.Context, gitproviders.RepoURL, gitproviders.PullRequestInfo) {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	argsForCall := fake.createPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitProvider) CreatePullRequestReturns(result1 gitprovider.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	fake.createPullRequestReturns = struct {
		result1 gitprovider.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) CreatePullRequestReturnsOnCall(i int, result1 gitprovider.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	if fake.createPullRequestReturnsOnCall == nil {
		fake.createPullRequestReturnsOnCall = make(map[int]struct {
			result1 gitprovider.PullRequest
			result2 error
		})
	}
	fake.createPullRequestReturnsOnCall[i] = struct {
		result1 gitprovider.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) DeployKeyExists(arg1 context.Context, arg2 gitproviders.RepoURL) (bool, error) {
	fake.deployKeyExistsMutex.Lock()
	ret, specificReturn := fake.deployKeyExistsReturnsOnCall[len(fake.deployKeyExistsArgsForCall)]
	fake.deployKeyExistsArgsForCall = append(fake.deployKeyExistsArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}{arg1, arg2})
	stub := fake.DeployKeyExistsStub
	fakeReturns := fake.deployKeyExistsReturns
	fake.recordInvocation("DeployKeyExists", []interface{}{arg1, arg2})
	fake.deployKeyExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) DeployKeyExistsCallCount() int {
	fake.deployKeyExistsMutex.RLock()
	defer fake.deployKeyExistsMutex.RUnlock()
	return len(fake.deployKeyExistsArgsForCall)
}

func (fake *FakeGitProvider) DeployKeyExistsCalls(stub func(context.Context, gitproviders.RepoURL) (bool, error)) {
	fake.deployKeyExistsMutex.Lock()
	defer fake.deployKeyExistsMutex.Unlock()
	fake.DeployKeyExistsStub = stub
}

func (fake *FakeGitProvider) DeployKeyExistsArgsForCall(i int) (context.Context, gitproviders.RepoURL) {
	fake.deployKeyExistsMutex.RLock()
	defer fake.deployKeyExistsMutex.RUnlock()
	argsForCall := fake.deployKeyExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitProvider) DeployKeyExistsReturns(result1 bool, result2 error) {
	fake.deployKeyExistsMutex.Lock()
	defer fake.deployKeyExistsMutex.Unlock()
	fake.DeployKeyExistsStub = nil
	fake.deployKeyExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) DeployKeyExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deployKeyExistsMutex.Lock()
	defer fake.deployKeyExistsMutex.Unlock()
	fake.DeployKeyExistsStub = nil
	if fake.deployKeyExistsReturnsOnCall == nil {
		fake.deployKeyExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deployKeyExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetCommits(arg1 context.Context, arg2 gitproviders.RepoURL, arg3 string, arg4 int, arg5 int) ([]gitprovider.Commit, error) {
	fake.getCommitsMutex.Lock()
	ret, specificReturn := fake.getCommitsReturnsOnCall[len(fake.getCommitsArgsForCall)]
	fake.getCommitsArgsForCall = append(fake.getCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 string
		arg4 int
		arg5 int
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GetCommitsStub
	fakeReturns := fake.getCommitsReturns
	fake.recordInvocation("GetCommits", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.getCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) GetCommitsCallCount() int {
	fake.getCommitsMutex.RLock()
	defer fake.getCommitsMutex.RUnlock()
	return len(fake.getCommitsArgsForCall)
}

func (fake *FakeGitProvider) GetCommitsCalls(stub func(context.Context, gitproviders.RepoURL, string, int, int) ([]gitprovider.Commit, error)) {
	fake.getCommitsMutex.Lock()
	defer fake.getCommitsMutex.Unlock()
	fake.GetCommitsStub = stub
}

func (fake *FakeGitProvider) GetCommitsArgsForCall(i int) (context.Context, gitproviders.RepoURL, string, int, int) {
	fake.getCommitsMutex.RLock()
	defer fake.getCommitsMutex.RUnlock()
	argsForCall := fake.getCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeGitProvider) GetCommitsReturns(result1 []gitprovider.Commit, result2 error) {
	fake.getCommitsMutex.Lock()
	defer fake.getCommitsMutex.Unlock()
	fake.GetCommitsStub = nil
	fake.getCommitsReturns = struct {
		result1 []gitprovider.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetCommitsReturnsOnCall(i int, result1 []gitprovider.Commit, result2 error) {
	fake.getCommitsMutex.Lock()
	defer fake.getCommitsMutex.Unlock()
	fake.GetCommitsStub = nil
	if fake.getCommitsReturnsOnCall == nil {
		fake.getCommitsReturnsOnCall = make(map[int]struct {
			result1 []gitprovider.Commit
			result2 error
		})
	}
	fake.getCommitsReturnsOnCall[i] = struct {
		result1 []gitprovider.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetDefaultBranch(arg1 context.Context, arg2 gitproviders.RepoURL) (string, error) {
	fake.getDefaultBranchMutex.Lock()
	ret, specificReturn := fake.getDefaultBranchReturnsOnCall[len(fake.getDefaultBranchArgsForCall)]
	fake.getDefaultBranchArgsForCall = append(fake.getDefaultBranchArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}{arg1, arg2})
	stub := fake.GetDefaultBranchStub
	fakeReturns := fake.getDefaultBranchReturns
	fake.recordInvocation("GetDefaultBranch", []interface{}{arg1, arg2})
	fake.getDefaultBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) GetDefaultBranchCallCount() int {
	fake.getDefaultBranchMutex.RLock()
	defer fake.getDefaultBranchMutex.RUnlock()
	return len(fake.getDefaultBranchArgsForCall)
}

func (fake *FakeGitProvider) GetDefaultBranchCalls(stub func(context.Context, gitproviders.RepoURL) (string, error)) {
	fake.getDefaultBranchMutex.Lock()
	defer fake.getDefaultBranchMutex.Unlock()
	fake.GetDefaultBranchStub = stub
}

func (fake *FakeGitProvider) GetDefaultBranchArgsForCall(i int) (context.Context, gitproviders.RepoURL) {
	fake.getDefaultBranchMutex.RLock()
	defer fake.getDefaultBranchMutex.RUnlock()
	argsForCall := fake.getDefaultBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitProvider) GetDefaultBranchReturns(result1 string, result2 error) {
	fake.getDefaultBranchMutex.Lock()
	defer fake.getDefaultBranchMutex.Unlock()
	fake.GetDefaultBranchStub = nil
	fake.getDefaultBranchReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetDefaultBranchReturnsOnCall(i int, result1 string, result2 error) {
	fake.getDefaultBranchMutex.Lock()
	defer fake.getDefaultBranchMutex.Unlock()
	fake.GetDefaultBranchStub = nil
	if fake.getDefaultBranchReturnsOnCall == nil {
		fake.getDefaultBranchReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getDefaultBranchReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetProviderDomain() string {
	fake.getProviderDomainMutex.Lock()
	ret, specificReturn := fake.getProviderDomainReturnsOnCall[len(fake.getProviderDomainArgsForCall)]
	fake.getProviderDomainArgsForCall = append(fake.getProviderDomainArgsForCall, struct {
	}{})
	stub := fake.GetProviderDomainStub
	fakeReturns := fake.getProviderDomainReturns
	fake.recordInvocation("GetProviderDomain", []interface{}{})
	fake.getProviderDomainMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitProvider) GetProviderDomainCallCount() int {
	fake.getProviderDomainMutex.RLock()
	defer fake.getProviderDomainMutex.RUnlock()
	return len(fake.getProviderDomainArgsForCall)
}

func (fake *FakeGitProvider) GetProviderDomainCalls(stub func() string) {
	fake.getProviderDomainMutex.Lock()
	defer fake.getProviderDomainMutex.Unlock()
	fake.GetProviderDomainStub = stub
}

func (fake *FakeGitProvider) GetProviderDomainReturns(result1 string) {
	fake.getProviderDomainMutex.Lock()
	defer fake.getProviderDomainMutex.Unlock()
	fake.GetProviderDomainStub = nil
	fake.getProviderDomainReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGitProvider) GetProviderDomainReturnsOnCall(i int, result1 string) {
	fake.getProviderDomainMutex.Lock()
	defer fake.getProviderDomainMutex.Unlock()
	fake.GetProviderDomainStub = nil
	if fake.getProviderDomainReturnsOnCall == nil {
		fake.getProviderDomainReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getProviderDomainReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGitProvider) GetRepoDirFiles(arg1 context.Context, arg2 gitproviders.RepoURL, arg3 string, arg4 string) ([]*gitprovider.CommitFile, error) {
	fake.getRepoDirFilesMutex.Lock()
	ret, specificReturn := fake.getRepoDirFilesReturnsOnCall[len(fake.getRepoDirFilesArgsForCall)]
	fake.getRepoDirFilesArgsForCall = append(fake.getRepoDirFilesArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetRepoDirFilesStub
	fakeReturns := fake.getRepoDirFilesReturns
	fake.recordInvocation("GetRepoDirFiles", []interface{}{arg1, arg2, arg3, arg4})
	fake.getRepoDirFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) GetRepoDirFilesCallCount() int {
	fake.getRepoDirFilesMutex.RLock()
	defer fake.getRepoDirFilesMutex.RUnlock()
	return len(fake.getRepoDirFilesArgsForCall)
}

func (fake *FakeGitProvider) GetRepoDirFilesCalls(stub func(context.Context, gitproviders.RepoURL, string, string) ([]*gitprovider.CommitFile, error)) {
	fake.getRepoDirFilesMutex.Lock()
	defer fake.getRepoDirFilesMutex.Unlock()
	fake.GetRepoDirFilesStub = stub
}

func (fake *FakeGitProvider) GetRepoDirFilesArgsForCall(i int) (context.Context, gitproviders.RepoURL, string, string) {
	fake.getRepoDirFilesMutex.RLock()
	defer fake.getRepoDirFilesMutex.RUnlock()
	argsForCall := fake.getRepoDirFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitProvider) GetRepoDirFilesReturns(result1 []*gitprovider.CommitFile, result2 error) {
	fake.getRepoDirFilesMutex.Lock()
	defer fake.getRepoDirFilesMutex.Unlock()
	fake.GetRepoDirFilesStub = nil
	fake.getRepoDirFilesReturns = struct {
		result1 []*gitprovider.CommitFile
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetRepoDirFilesReturnsOnCall(i int, result1 []*gitprovider.CommitFile, result2 error) {
	fake.getRepoDirFilesMutex.Lock()
	defer fake.getRepoDirFilesMutex.Unlock()
	fake.GetRepoDirFilesStub = nil
	if fake.getRepoDirFilesReturnsOnCall == nil {
		fake.getRepoDirFilesReturnsOnCall = make(map[int]struct {
			result1 []*gitprovider.CommitFile
			result2 error
		})
	}
	fake.getRepoDirFilesReturnsOnCall[i] = struct {
		result1 []*gitprovider.CommitFile
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetRepoVisibility(arg1 context.Context, arg2 gitproviders.RepoURL) (*gitprovider.RepositoryVisibility, error) {
	fake.getRepoVisibilityMutex.Lock()
	ret, specificReturn := fake.getRepoVisibilityReturnsOnCall[len(fake.getRepoVisibilityArgsForCall)]
	fake.getRepoVisibilityArgsForCall = append(fake.getRepoVisibilityArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}{arg1, arg2})
	stub := fake.GetRepoVisibilityStub
	fakeReturns := fake.getRepoVisibilityReturns
	fake.recordInvocation("GetRepoVisibility", []interface{}{arg1, arg2})
	fake.getRepoVisibilityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) GetRepoVisibilityCallCount() int {
	fake.getRepoVisibilityMutex.RLock()
	defer fake.getRepoVisibilityMutex.RUnlock()
	return len(fake.getRepoVisibilityArgsForCall)
}

func (fake *FakeGitProvider) GetRepoVisibilityCalls(stub func(context.Context, gitproviders.RepoURL) (*gitprovider.RepositoryVisibility, error)) {
	fake.getRepoVisibilityMutex.Lock()
	defer fake.getRepoVisibilityMutex.Unlock()
	fake.GetRepoVisibilityStub = stub
}

func (fake *FakeGitProvider) GetRepoVisibilityArgsForCall(i int) (context.Context, gitproviders.RepoURL) {
	fake.getRepoVisibilityMutex.RLock()
	defer fake.getRepoVisibilityMutex.RUnlock()
	argsForCall := fake.getRepoVisibilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitProvider) GetRepoVisibilityReturns(result1 *gitprovider.RepositoryVisibility, result2 error) {
	fake.getRepoVisibilityMutex.Lock()
	defer fake.getRepoVisibilityMutex.Unlock()
	fake.GetRepoVisibilityStub = nil
	fake.getRepoVisibilityReturns = struct {
		result1 *gitprovider.RepositoryVisibility
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) GetRepoVisibilityReturnsOnCall(i int, result1 *gitprovider.RepositoryVisibility, result2 error) {
	fake.getRepoVisibilityMutex.Lock()
	defer fake.getRepoVisibilityMutex.Unlock()
	fake.GetRepoVisibilityStub = nil
	if fake.getRepoVisibilityReturnsOnCall == nil {
		fake.getRepoVisibilityReturnsOnCall = make(map[int]struct {
			result1 *gitprovider.RepositoryVisibility
			result2 error
		})
	}
	fake.getRepoVisibilityReturnsOnCall[i] = struct {
		result1 *gitprovider.RepositoryVisibility
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) MergePullRequest(arg1 context.Context, arg2 gitproviders.RepoURL, arg3 int, arg4 string) error {
	fake.mergePullRequestMutex.Lock()
	ret, specificReturn := fake.mergePullRequestReturnsOnCall[len(fake.mergePullRequestArgsForCall)]
	fake.mergePullRequestArgsForCall = append(fake.mergePullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 int
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.MergePullRequestStub
	fakeReturns := fake.mergePullRequestReturns
	fake.recordInvocation("MergePullRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.mergePullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitProvider) MergePullRequestCallCount() int {
	fake.mergePullRequestMutex.RLock()
	defer fake.mergePullRequestMutex.RUnlock()
	return len(fake.mergePullRequestArgsForCall)
}

func (fake *FakeGitProvider) MergePullRequestCalls(stub func(context.Context, gitproviders.RepoURL, int, string) error) {
	fake.mergePullRequestMutex.Lock()
	defer fake.mergePullRequestMutex.Unlock()
	fake.MergePullRequestStub = stub
}

func (fake *FakeGitProvider) MergePullRequestArgsForCall(i int) (context.Context, gitproviders.RepoURL, int, string) {
	fake.mergePullRequestMutex.RLock()
	defer fake.mergePullRequestMutex.RUnlock()
	argsForCall := fake.mergePullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitProvider) MergePullRequestReturns(result1 error) {
	fake.mergePullRequestMutex.Lock()
	defer fake.mergePullRequestMutex.Unlock()
	fake.MergePullRequestStub = nil
	fake.mergePullRequestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProvider) MergePullRequestReturnsOnCall(i int, result1 error) {
	fake.mergePullRequestMutex.Lock()
	defer fake.mergePullRequestMutex.Unlock()
	fake.MergePullRequestStub = nil
	if fake.mergePullRequestReturnsOnCall == nil {
		fake.mergePullRequestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mergePullRequestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProvider) RepositoryExists(arg1 context.Context, arg2 gitproviders.RepoURL) (bool, error) {
	fake.repositoryExistsMutex.Lock()
	ret, specificReturn := fake.repositoryExistsReturnsOnCall[len(fake.repositoryExistsArgsForCall)]
	fake.repositoryExistsArgsForCall = append(fake.repositoryExistsArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
	}{arg1, arg2})
	stub := fake.RepositoryExistsStub
	fakeReturns := fake.repositoryExistsReturns
	fake.recordInvocation("RepositoryExists", []interface{}{arg1, arg2})
	fake.repositoryExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitProvider) RepositoryExistsCallCount() int {
	fake.repositoryExistsMutex.RLock()
	defer fake.repositoryExistsMutex.RUnlock()
	return len(fake.repositoryExistsArgsForCall)
}

func (fake *FakeGitProvider) RepositoryExistsCalls(stub func(context.Context, gitproviders.RepoURL) (bool, error)) {
	fake.repositoryExistsMutex.Lock()
	defer fake.repositoryExistsMutex.Unlock()
	fake.RepositoryExistsStub = stub
}

func (fake *FakeGitProvider) RepositoryExistsArgsForCall(i int) (context.Context, gitproviders.RepoURL) {
	fake.repositoryExistsMutex.RLock()
	defer fake.repositoryExistsMutex.RUnlock()
	argsForCall := fake.repositoryExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitProvider) RepositoryExistsReturns(result1 bool, result2 error) {
	fake.repositoryExistsMutex.Lock()
	defer fake.repositoryExistsMutex.Unlock()
	fake.RepositoryExistsStub = nil
	fake.repositoryExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) RepositoryExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.repositoryExistsMutex.Lock()
	defer fake.repositoryExistsMutex.Unlock()
	fake.RepositoryExistsStub = nil
	if fake.repositoryExistsReturnsOnCall == nil {
		fake.repositoryExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.repositoryExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitProvider) UploadDeployKey(arg1 context.Context, arg2 gitproviders.RepoURL, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.uploadDeployKeyMutex.Lock()
	ret, specificReturn := fake.uploadDeployKeyReturnsOnCall[len(fake.uploadDeployKeyArgsForCall)]
	fake.uploadDeployKeyArgsForCall = append(fake.uploadDeployKeyArgsForCall, struct {
		arg1 context.Context
		arg2 gitproviders.RepoURL
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.UploadDeployKeyStub
	fakeReturns := fake.uploadDeployKeyReturns
	fake.recordInvocation("UploadDeployKey", []interface{}{arg1, arg2, arg3Copy})
	fake.uploadDeployKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitProvider) UploadDeployKeyCallCount() int {
	fake.uploadDeployKeyMutex.RLock()
	defer fake.uploadDeployKeyMutex.RUnlock()
	return len(fake.uploadDeployKeyArgsForCall)
}

func (fake *FakeGitProvider) UploadDeployKeyCalls(stub func(context.Context, gitproviders.RepoURL, []byte) error) {
	fake.uploadDeployKeyMutex.Lock()
	defer fake.uploadDeployKeyMutex.Unlock()
	fake.UploadDeployKeyStub = stub
}

func (fake *FakeGitProvider) UploadDeployKeyArgsForCall(i int) (context.Context, gitproviders.RepoURL, []byte) {
	fake.uploadDeployKeyMutex.RLock()
	defer fake.uploadDeployKeyMutex.RUnlock()
	argsForCall := fake.uploadDeployKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitProvider) UploadDeployKeyReturns(result1 error) {
	fake.uploadDeployKeyMutex.Lock()
	defer fake.uploadDeployKeyMutex.Unlock()
	fake.UploadDeployKeyStub = nil
	fake.uploadDeployKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProvider) UploadDeployKeyReturnsOnCall(i int, result1 error) {
	fake.uploadDeployKeyMutex.Lock()
	defer fake.uploadDeployKeyMutex.Unlock()
	fake.UploadDeployKeyStub = nil
	if fake.uploadDeployKeyReturnsOnCall == nil {
		fake.uploadDeployKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadDeployKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ gitproviders.GitProvider = new(FakeGitProvider)
