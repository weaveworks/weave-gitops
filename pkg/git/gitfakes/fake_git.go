// Code generated by counterfeiter. DO NOT EDIT.
package gitfakes

import (
	"context"
	"sync"

	gita "github.com/go-git/go-git/v5"
	"github.com/weaveworks/weave-gitops/pkg/git"
)

type FakeGit struct {
	CheckoutStub        func(string) error
	checkoutMutex       sync.RWMutex
	checkoutArgsForCall []struct {
		arg1 string
	}
	checkoutReturns struct {
		result1 error
	}
	checkoutReturnsOnCall map[int]struct {
		result1 error
	}
	CloneStub        func(context.Context, string, string, string) (bool, error)
	cloneMutex       sync.RWMutex
	cloneArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	cloneReturns struct {
		result1 bool
		result2 error
	}
	cloneReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CommitStub        func(git.Commit, ...func(string) bool) (string, error)
	commitMutex       sync.RWMutex
	commitArgsForCall []struct {
		arg1 git.Commit
		arg2 []func(string) bool
	}
	commitReturns struct {
		result1 string
		result2 error
	}
	commitReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetRemoteURLStub        func(string, string) (string, error)
	getRemoteURLMutex       sync.RWMutex
	getRemoteURLArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getRemoteURLReturns struct {
		result1 string
		result2 error
	}
	getRemoteURLReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HeadStub        func() (string, error)
	headMutex       sync.RWMutex
	headArgsForCall []struct {
	}
	headReturns struct {
		result1 string
		result2 error
	}
	headReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	InitStub        func(string, string, string) (bool, error)
	initMutex       sync.RWMutex
	initArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	initReturns struct {
		result1 bool
		result2 error
	}
	initReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	OpenStub        func(string) (*gita.Repository, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 string
	}
	openReturns struct {
		result1 *gita.Repository
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 *gita.Repository
		result2 error
	}
	PushStub        func(context.Context) error
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 context.Context
	}
	pushReturns struct {
		result1 error
	}
	pushReturnsOnCall map[int]struct {
		result1 error
	}
	ReadStub        func(string) ([]byte, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 string
	}
	readReturns struct {
		result1 []byte
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	StatusStub        func() (bool, error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 bool
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ValidateAccessStub        func(context.Context, string, string) error
	validateAccessMutex       sync.RWMutex
	validateAccessArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	validateAccessReturns struct {
		result1 error
	}
	validateAccessReturnsOnCall map[int]struct {
		result1 error
	}
	WriteStub        func(string, []byte) error
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	writeReturns struct {
		result1 error
	}
	writeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGit) Checkout(arg1 string) error {
	fake.checkoutMutex.Lock()
	ret, specificReturn := fake.checkoutReturnsOnCall[len(fake.checkoutArgsForCall)]
	fake.checkoutArgsForCall = append(fake.checkoutArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckoutStub
	fakeReturns := fake.checkoutReturns
	fake.recordInvocation("Checkout", []interface{}{arg1})
	fake.checkoutMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) CheckoutCallCount() int {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	return len(fake.checkoutArgsForCall)
}

func (fake *FakeGit) CheckoutCalls(stub func(string) error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = stub
}

func (fake *FakeGit) CheckoutArgsForCall(i int) string {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	argsForCall := fake.checkoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) CheckoutReturns(result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	fake.checkoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) CheckoutReturnsOnCall(i int, result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	if fake.checkoutReturnsOnCall == nil {
		fake.checkoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Clone(arg1 context.Context, arg2 string, arg3 string, arg4 string) (bool, error) {
	fake.cloneMutex.Lock()
	ret, specificReturn := fake.cloneReturnsOnCall[len(fake.cloneArgsForCall)]
	fake.cloneArgsForCall = append(fake.cloneArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CloneStub
	fakeReturns := fake.cloneReturns
	fake.recordInvocation("Clone", []interface{}{arg1, arg2, arg3, arg4})
	fake.cloneMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) CloneCallCount() int {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	return len(fake.cloneArgsForCall)
}

func (fake *FakeGit) CloneCalls(stub func(context.Context, string, string, string) (bool, error)) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = stub
}

func (fake *FakeGit) CloneArgsForCall(i int) (context.Context, string, string, string) {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	argsForCall := fake.cloneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGit) CloneReturns(result1 bool, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	fake.cloneReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) CloneReturnsOnCall(i int, result1 bool, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	if fake.cloneReturnsOnCall == nil {
		fake.cloneReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.cloneReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Commit(arg1 git.Commit, arg2 ...func(string) bool) (string, error) {
	fake.commitMutex.Lock()
	ret, specificReturn := fake.commitReturnsOnCall[len(fake.commitArgsForCall)]
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct {
		arg1 git.Commit
		arg2 []func(string) bool
	}{arg1, arg2})
	stub := fake.CommitStub
	fakeReturns := fake.commitReturns
	fake.recordInvocation("Commit", []interface{}{arg1, arg2})
	fake.commitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *FakeGit) CommitCalls(stub func(git.Commit, ...func(string) bool) (string, error)) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = stub
}

func (fake *FakeGit) CommitArgsForCall(i int) (git.Commit, []func(string) bool) {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	argsForCall := fake.commitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGit) CommitReturns(result1 string, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	fake.commitReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) CommitReturnsOnCall(i int, result1 string, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	if fake.commitReturnsOnCall == nil {
		fake.commitReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.commitReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) GetRemoteURL(arg1 string, arg2 string) (string, error) {
	fake.getRemoteURLMutex.Lock()
	ret, specificReturn := fake.getRemoteURLReturnsOnCall[len(fake.getRemoteURLArgsForCall)]
	fake.getRemoteURLArgsForCall = append(fake.getRemoteURLArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRemoteURLStub
	fakeReturns := fake.getRemoteURLReturns
	fake.recordInvocation("GetRemoteURL", []interface{}{arg1, arg2})
	fake.getRemoteURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) GetRemoteURLCallCount() int {
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	return len(fake.getRemoteURLArgsForCall)
}

func (fake *FakeGit) GetRemoteURLCalls(stub func(string, string) (string, error)) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = stub
}

func (fake *FakeGit) GetRemoteURLArgsForCall(i int) (string, string) {
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	argsForCall := fake.getRemoteURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGit) GetRemoteURLReturns(result1 string, result2 error) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = nil
	fake.getRemoteURLReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) GetRemoteURLReturnsOnCall(i int, result1 string, result2 error) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = nil
	if fake.getRemoteURLReturnsOnCall == nil {
		fake.getRemoteURLReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getRemoteURLReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Head() (string, error) {
	fake.headMutex.Lock()
	ret, specificReturn := fake.headReturnsOnCall[len(fake.headArgsForCall)]
	fake.headArgsForCall = append(fake.headArgsForCall, struct {
	}{})
	stub := fake.HeadStub
	fakeReturns := fake.headReturns
	fake.recordInvocation("Head", []interface{}{})
	fake.headMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) HeadCallCount() int {
	fake.headMutex.RLock()
	defer fake.headMutex.RUnlock()
	return len(fake.headArgsForCall)
}

func (fake *FakeGit) HeadCalls(stub func() (string, error)) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = stub
}

func (fake *FakeGit) HeadReturns(result1 string, result2 error) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = nil
	fake.headReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) HeadReturnsOnCall(i int, result1 string, result2 error) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = nil
	if fake.headReturnsOnCall == nil {
		fake.headReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.headReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Init(arg1 string, arg2 string, arg3 string) (bool, error) {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.InitStub
	fakeReturns := fake.initReturns
	fake.recordInvocation("Init", []interface{}{arg1, arg2, arg3})
	fake.initMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeGit) InitCalls(stub func(string, string, string) (bool, error)) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = stub
}

func (fake *FakeGit) InitArgsForCall(i int) (string, string, string) {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	argsForCall := fake.initArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGit) InitReturns(result1 bool, result2 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) InitReturnsOnCall(i int, result1 bool, result2 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Open(arg1 string) (*gita.Repository, error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OpenStub
	fakeReturns := fake.openReturns
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeGit) OpenCalls(stub func(string) (*gita.Repository, error)) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeGit) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) OpenReturns(result1 *gita.Repository, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 *gita.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) OpenReturnsOnCall(i int, result1 *gita.Repository, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 *gita.Repository
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 *gita.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Push(arg1 context.Context) error {
	fake.pushMutex.Lock()
	ret, specificReturn := fake.pushReturnsOnCall[len(fake.pushArgsForCall)]
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PushStub
	fakeReturns := fake.pushReturns
	fake.recordInvocation("Push", []interface{}{arg1})
	fake.pushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeGit) PushCalls(stub func(context.Context) error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = stub
}

func (fake *FakeGit) PushArgsForCall(i int) context.Context {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	argsForCall := fake.pushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) PushReturns(result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) PushReturnsOnCall(i int, result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	if fake.pushReturnsOnCall == nil {
		fake.pushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Read(arg1 string) ([]byte, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeGit) ReadCalls(stub func(string) ([]byte, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeGit) ReadArgsForCall(i int) string {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) ReadReturns(result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) ReadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeGit) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeGit) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Status() (bool, error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeGit) StatusCalls(stub func() (bool, error)) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeGit) StatusReturns(result1 bool, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) StatusReturnsOnCall(i int, result1 bool, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) ValidateAccess(arg1 context.Context, arg2 string, arg3 string) error {
	fake.validateAccessMutex.Lock()
	ret, specificReturn := fake.validateAccessReturnsOnCall[len(fake.validateAccessArgsForCall)]
	fake.validateAccessArgsForCall = append(fake.validateAccessArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ValidateAccessStub
	fakeReturns := fake.validateAccessReturns
	fake.recordInvocation("ValidateAccess", []interface{}{arg1, arg2, arg3})
	fake.validateAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) ValidateAccessCallCount() int {
	fake.validateAccessMutex.RLock()
	defer fake.validateAccessMutex.RUnlock()
	return len(fake.validateAccessArgsForCall)
}

func (fake *FakeGit) ValidateAccessCalls(stub func(context.Context, string, string) error) {
	fake.validateAccessMutex.Lock()
	defer fake.validateAccessMutex.Unlock()
	fake.ValidateAccessStub = stub
}

func (fake *FakeGit) ValidateAccessArgsForCall(i int) (context.Context, string, string) {
	fake.validateAccessMutex.RLock()
	defer fake.validateAccessMutex.RUnlock()
	argsForCall := fake.validateAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGit) ValidateAccessReturns(result1 error) {
	fake.validateAccessMutex.Lock()
	defer fake.validateAccessMutex.Unlock()
	fake.ValidateAccessStub = nil
	fake.validateAccessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) ValidateAccessReturnsOnCall(i int, result1 error) {
	fake.validateAccessMutex.Lock()
	defer fake.validateAccessMutex.Unlock()
	fake.ValidateAccessStub = nil
	if fake.validateAccessReturnsOnCall == nil {
		fake.validateAccessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateAccessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Write(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1, arg2Copy})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeGit) WriteCalls(stub func(string, []byte) error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeGit) WriteArgsForCall(i int) (string, []byte) {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGit) WriteReturns(result1 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) WriteReturnsOnCall(i int, result1 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	fake.headMutex.RLock()
	defer fake.headMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.validateAccessMutex.RLock()
	defer fake.validateAccessMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGit) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ git.Git = new(FakeGit)
