// Code generated by counterfeiter. DO NOT EDIT.
package gitfakes

import (
	"context"
	"sync"

	gita "github.com/go-git/go-git/v5"
	"github.com/weaveworks/weave-gitops/pkg/git"
)

type FakeGit struct {
	CheckoutStub        func(string) error
	checkoutMutex       sync.RWMutex
	checkoutArgsForCall []struct {
		arg1 string
	}
	checkoutReturns struct {
		result1 error
	}
	checkoutReturnsOnCall map[int]struct {
		result1 error
	}
	CloneStub        func(context.Context, string, string, string) (bool, error)
	cloneMutex       sync.RWMutex
	cloneArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	cloneReturns struct {
		result1 bool
		result2 error
	}
	cloneReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CommitStub        func(git.Commit, ...func(string) bool) (string, error)
	commitMutex       sync.RWMutex
	commitArgsForCall []struct {
		arg1 git.Commit
		arg2 []func(string) bool
	}
	commitReturns struct {
		result1 string
		result2 error
	}
	commitReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetRemoteURLStub        func(string, string) (string, error)
	getRemoteURLMutex       sync.RWMutex
	getRemoteURLArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getRemoteURLReturns struct {
		result1 string
		result2 error
	}
	getRemoteURLReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HeadStub        func() (string, error)
	headMutex       sync.RWMutex
	headArgsForCall []struct {
	}
	headReturns struct {
		result1 string
		result2 error
	}
	headReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	InitStub        func(string, string, string) (bool, error)
	initMutex       sync.RWMutex
	initArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	initReturns struct {
		result1 bool
		result2 error
	}
	initReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	OpenStub        func(string) (*gita.Repository, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 string
	}
	openReturns struct {
		result1 *gita.Repository
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 *gita.Repository
		result2 error
	}
	PushStub        func(context.Context) error
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 context.Context
	}
	pushReturns struct {
		result1 error
	}
	pushReturnsOnCall map[int]struct {
		result1 error
	}
	ReadStub        func(string) ([]byte, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 string
	}
	readReturns struct {
		result1 []byte
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	StatusStub        func() (bool, error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 bool
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ValidateAccessStub        func(context.Context, string, string) error
	validateAccessMutex       sync.RWMutex
	validateAccessArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	validateAccessReturns struct {
		result1 error
	}
	validateAccessReturnsOnCall map[int]struct {
		result1 error
	}
	WriteStub        func(string, []byte) error
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	writeReturns struct {
		result1 error
	}
	writeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGit) Checkout(arg1 string) error {
	fake.checkoutMutex.Lock()
	ret, specificReturn := fake.checkoutReturnsOnCall[len(fake.checkoutArgsForCall)]
	fake.checkoutArgsForCall = append(fake.checkoutArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckoutStub
	fakeReturns := fake.checkoutReturns
	fake.recordInvocation("Checkout", []interface{}{arg1})
	fake.checkoutMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) CheckoutCallCount() int {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	return len(fake.checkoutArgsForCall)
}

func (fake *FakeGit) CheckoutCalls(stub func(string) error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = stub
}

func (fake *FakeGit) CheckoutArgsForCall(i int) string {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	argsForCall := fake.checkoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) CheckoutReturns(result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	fake.checkoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) CheckoutReturnsOnCall(i int, result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	if fake.checkoutReturnsOnCall == nil {
		fake.checkoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Clone(arg1 context.Context, arg2 string, arg3 string, arg4 string) (bool, error) {
	fake.cloneMutex.Lock()
	ret, specificReturn := fake.cloneReturnsOnCall[len(fake.cloneArgsForCall)]
	fake.cloneArgsForCall = append(fake.cloneArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CloneStub
	fakeReturns := fake.cloneReturns
	fake.recordInvocation("Clone", []interface{}{arg1, arg2, arg3, arg4})
	fake.cloneMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) CloneCallCount() int {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	return len(fake.cloneArgsForCall)
}

func (fake *FakeGit) CloneCalls(stub func(context.Context, string, string, string) (bool, error)) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = stub
}

func (fake *FakeGit) CloneArgsForCall(i int) (context.Context, string, string, string) {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	argsForCall := fake.cloneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGit) CloneReturns(result1 bool, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	fake.cloneReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) CloneReturnsOnCall(i int, result1 bool, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	if fake.cloneReturnsOnCall == nil {
		fake.cloneReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.cloneReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Commit(arg1 git.Commit, arg2 ...func(string) bool) (string, error) {
	fake.commitMutex.Lock()
	ret, specificReturn := fake.commitReturnsOnCall[len(fake.commitArgsForCall)]
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct {
		arg1 git.Commit
		arg2 []func(string) bool
	}{arg1, arg2})
	stub := fake.CommitStub
	fakeReturns := fake.commitReturns
	fake.recordInvocation("Commit", []interface{}{arg1, arg2})
	fake.commitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *FakeGit) CommitCalls(stub func(git.Commit, ...func(string) bool) (string, error)) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = stub
}

func (fake *FakeGit) CommitArgsForCall(i int) (git.Commit, []func(string) bool) {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	argsForCall := fake.commitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGit) CommitReturns(result1 string, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	fake.commitReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) CommitReturnsOnCall(i int, result1 string, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	if fake.commitReturnsOnCall == nil {
		fake.commitReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.commitReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) GetRemoteURL(arg1 string, arg2 string) (string, error) {
	fake.getRemoteURLMutex.Lock()
	ret, specificReturn := fake.getRemoteURLReturnsOnCall[len(fake.getRemoteURLArgsForCall)]
	fake.getRemoteURLArgsForCall = append(fake.getRemoteURLArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRemoteURLStub
	fakeReturns := fake.getRemoteURLReturns
	fake.recordInvocation("GetRemoteURL", []interface{}{arg1, arg2})
	fake.getRemoteURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) GetRemoteURLCallCount() int {
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	return len(fake.getRemoteURLArgsForCall)
}

func (fake *FakeGit) GetRemoteURLCalls(stub func(string, string) (string, error)) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = stub
}

func (fake *FakeGit) GetRemoteURLArgsForCall(i int) (string, string) {
	fake.getRemoteURLMutex.RLock()
	defer fake.getRemoteURLMutex.RUnlock()
	argsForCall := fake.getRemoteURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGit) GetRemoteURLReturns(result1 string, result2 error) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = nil
	fake.getRemoteURLReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) GetRemoteURLReturnsOnCall(i int, result1 string, result2 error) {
	fake.getRemoteURLMutex.Lock()
	defer fake.getRemoteURLMutex.Unlock()
	fake.GetRemoteURLStub = nil
	if fake.getRemoteURLReturnsOnCall == nil {
		fake.getRemoteURLReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getRemoteURLReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Head() (string, error) {
	fake.headMutex.Lock()
	ret, specificReturn := fake.headReturnsOnCall[len(fake.headArgsForCall)]
	fake.headArgsForCall = append(fake.headArgsForCall, struct {
	}{})
	stub := fake.HeadStub
	fakeReturns := fake.headReturns
	fake.recordInvocation("Head", []interface{}{})
	fake.headMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) HeadCallCount() int {
	fake.headMutex.RLock()
	defer fake.headMutex.RUnlock()
	return len(fake.headArgsForCall)
}

func (fake *FakeGit) HeadCalls(stub func() (string, error)) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = stub
}

func (fake *FakeGit) HeadReturns(result1 string, result2 error) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = nil
	fake.headReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) HeadReturnsOnCall(i int, result1 string, result2 error) {
	fake.headMutex.Lock()
	defer fake.headMutex.Unlock()
	fake.HeadStub = nil
	if fake.headReturnsOnCall == nil {
		fake.headReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.headReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Init(arg1 string, arg2 string, arg3 string) (bool, error) {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.InitStub
	fakeReturns := fake.initReturns
	fake.recordInvocation("Init", []interface{}{arg1, arg2, arg3})
	fake.initMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeGit) InitCalls(stub func(string, string, string) (bool, error)) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = stub
}

func (fake *FakeGit) InitArgsForCall(i int) (string, string, string) {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	argsForCall := fake.initArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGit) InitReturns(result1 bool, result2 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) InitReturnsOnCall(i int, result1 bool, result2 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Open(arg1 string) (*gita.Repository, error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OpenStub
	fakeReturns := fake.openReturns
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeGit) OpenCalls(stub func(string) (*gita.Repository, error)) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeGit) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) OpenReturns(result1 *gita.Repository, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 *gita.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) OpenReturnsOnCall(i int, result1 *gita.Repository, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 *gita.Repository
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 *gita.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Push(arg1 context.Context) error {
	fake.pushMutex.Lock()
	ret, specificReturn := fake.pushReturnsOnCall[len(fake.pushArgsForCall)]
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PushStub
	fakeReturns := fake.pushReturns
	fake.recordInvocation("Push", []interface{}{arg1})
	fake.pushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeGit) PushCalls(stub func(context.Context) error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = stub
}

func (fake *FakeGit) PushArgsForCall(i int) context.Context {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	argsForCall := fake.pushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) PushReturns(result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) PushReturnsOnCall(i int, result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	if fake.pushReturnsOnCall == nil {
		fake.pushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Read(arg1 string) ([]byte, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeGit) ReadCalls(stub func(string) ([]byte, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeGit) ReadArgsForCall(i int) string {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) ReadReturns(result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) ReadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeGit) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeGit) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGit) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Status() (bool, error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGit) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeGit) StatusCalls(stub func() (bool, error)) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeGit) StatusReturns(result1 bool, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) StatusReturnsOnCall(i int, result1 bool, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGit) ValidateAccess(arg1 context.Context, arg2 string, arg3 string) error {
	fake.validateAccessMutex.Lock()
	ret, specificReturn := fake.validateAccessReturnsOnCall[len(fake.validateAccessArgsForCall)]
	fake.validateAccessArgsForCall = append(fake.validateAccessArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ValidateAccessStub
	fakeReturns := fake.validateAccessReturns
	fake.recordInvocation("ValidateAccess", []interface{}{arg1, arg2, arg3})
	fake.validateAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) ValidateAccessCallCount() int {
	fake.validateAccessMutex.RLock()
	defer fake.validateAccessMutex.RUnlock()
	return len(fake.validateAccessArgsForCall)
}

func (fake *FakeGit) ValidateAccessCalls(stub func(context.Context, string, string) error) {
	fake.validateAccessMutex.Lock()
	defer fake.validateAccessMutex.Unlock()
	fake.ValidateAccessStub = stub
}

func (fake *FakeGit) ValidateAccessArgsForCall(i int) (context.Context, string, string) {
	fake.validateAccessMutex.RLock()
	defer fake.validateAccessMutex.RUnlock()
	argsForCall := fake.validateAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGit) ValidateAccessReturns(result1 error) {
	fake.validateAccessMutex.Lock()
	defer fake.validateAccessMutex.Unlock()
	fake.ValidateAccessStub = nil
	fake.validateAccessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) ValidateAccessReturnsOnCall(i int, result1 error) {
	fake.validateAccessMutex.Lock()
	defer fake.validateAccessMutex.Unlock()
	fake.ValidateAccessStub = nil
	if fake.validateAccessReturnsOnCall == nil {
		fake.validateAccessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateAccessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Write(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1, arg2Copy})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGit) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeGit) WriteCalls(stub func(string, []byte) error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeGit) WriteArgsForCall(i int) (string, []byte) {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGit) WriteReturns(result1 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) WriteReturnsOnCall(i int, result1 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGit) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGit) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ git.Git = new(FakeGit)
